blueprint:
  name: "Cover Control Automation (CCA)"
  description: |
    # ‚≠ê Cover Control Automation (CCA) ‚≠ê
    ### A comprehensive and highly configurable blueprint for roller shutters and roller blinds

    **Version**: 2024.06.24
    **Help**: [Community Thread](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539)
    **Source Code**: [github.com/hvorragend](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml)
    **Tickets**: [Issues](https://github.com/hvorragend/ha-blueprints/issues)
    **Full Changelog**: [CHANGELOG.md](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/CHANGELOG.md)

    **If you would like to support me or say thank you, please click here:** üôè [Click Here](https://www.paypal.com/donate/?hosted_button_id=NQE5MFJXAA8BQ) üôè

    <details>
    <summary><strong>Features</strong></summary>

    ‚úÖ Automatic opening and closing the roller shutters
    ‚úÖ Freely configurable time windows for opening or closing
    ‚úÖ Brightness control and/or control via the sun-elevation
    ‚úÖ The use of scheduler helpers are possible
    ‚úÖ Ventilation feature (Currently for two-way sensors)
    ‚úÖ Resident feature: keep the cover closed if resident is asleep
    ‚úÖ Complete flexibility in almost all parameters (drive delays, waiting times, position tolerance)
    ‚úÖ Each feature can be activated or deactivated as required
    ‚úÖ Dynamic conditions possible (see examples in `Details`)
    ‚úÖ Extensive automatic sun shading with many different setting options (see features in `Details`)
    ‚úÖ Added the option to save the current status in a helper. This has the advantage that the cover can also be in other positions and the automation can still be executed. And manual interventions are not constantly overridden with every trigger.

    **Sun shading features**
    ‚úÖ Sun azimuth
    ‚úÖ Sun elevation
    ‚úÖ Solar irradiation/Light intensity/Illuminance
    ‚úÖ Weather Conditions
    ‚úÖ Two different temperature sensors (compare thresholds for indoor and/or outdoor sensors)
    ‚úÖ Not only the current temperature, but also the temperature forecast can also be taken into account.
    ‚úÖ If multiple criteria (e.g. temperature sensors and/or azimuth and/or elevation) are defined, shading will not occur until <ins>all</ins> criteria are met.

    </details>

    <details>
    <summary><strong>Important notes</strong></summary>

    - It is <ins>not</ins> possible to execute this automation manually!
    - If you want to use sun elevation and/or azimuth it's strongly advised to use sun.sun. And please make sure your sun.sun entity is enabled!
    - `time_up_early` should be earlier `than time_up_late`
    - `time_up_early_non_workday` should be earlier than `time_up_late_non_workday`
    - `time_down_early` should be earlier than `time_down_late`
    - `time_down_early_non_workday` should be earlier than `time_down_late_non_workday`
    - `shading_azimuth_start` should be lower than `shading_azimuth_end`
    - `shading_elevation_min` should be lower than `shading_elevation_max`
    - `shading_sun_brightness_start` should be higher than `shading_sun_brightness_end`
    - `open_position` should be higher than `close_position`
    - `open_position` should be higher than `ventilate_position`
    - `close_position` should be lower than `ventilate_position`
    - `shading_position` should be higher than `close_position`
    - `shading_position` should be lower than `open_position`
    - `resident_sensor` is only allowed to be on/off/true/false
    - cover must have a `current_position` attribute
    - After <ins>manual creation</ins> of the helper in the GUI, it will be filled with standard content on the <ins>first trigger</ins>.
      In rare cases, this may mean that the first trigger does not move the blinds. This may take care of itself with the next trigger later.
      Alternatively, the roller blinds must be moved shortly once so that the automation system knows what the current status is.

    </details>

    <details>
    <summary><strong>Changes in the last days</strong></summary>

    2024.06.24:
      - Breaking change: 'prevent_higher_position_shading_end' changed to new parameter 'prevent_lowering_when_closing_if_shaded'
      - Added: Limited templates for enabling automation triggers
      - Added: Shading sensor 2 is also checked again during shading
      - Fixed: Occasionally sun shading was performed without checking the weather conditions
      - Fixed: The ventilation position was not set correctly when closing the roller blind
      - Fixed: At the end of sun shading, the system no longer moves to the ventilation position
      - Fixed: Sun shading is now also calculated outside the configured times and can be taken into account when opening.
      - Fixed: Option "Prevent the cover from closing immediately after deactivating the lockout protection"
      - Many thanks to Eimeel and Bostil

    2024.06.05-01:
      - Added: Optional checking workday tomorrow sensor when closing the cover #71
      - Updated: GUI section icons to MDI icons

    2024.06.04-01:
      - Major GUI Update: Using blueprint sections now (Min-Core-Version: 2024.6.0)

    2024.05.28-01:
      - Complete restructuring and logic change for shading, lockout protection and ventilation:
          - When the cover is opened, the system checks whether a sun shading is already in place. If this is the case, the cover is not opened but moved directly into the shading position.
          - If the cover is to be closed and the contact is open, either lockout protection or ventilation mode is activated.
          - If the cover is closed and the corresponding contact is opened, the ventilation position is activated.
          - When the sun shading is activated, the lockout protection is taken into account if the contact is open. If the contact is closed, the cover moves back to the shading position.
          - When the sun shading is stopped, the lockout protection is checked. It is also possible to move to the ventilation position when the contact is open. If the contact is closed here, the cover is opened.

          <ins>Summary:</ins> CCA saves the temporary status (ventilation, lockout protection and shading) and the actual target status in the Cover Status Helper.
          - This means that the cover is simply opened or closed as before.
          - And it does <ins>not</ins> always return to the previous state (which may have changed in the meantime).
          - Instead, it switches to the state that should actually be current.
      - Fixed: Incorrect position detection during manual drives if shading_position is smaller than close_position
      - Added: Shading activation before opening. The cover can now move into the shading during the opening process. #4
      - Added: Prevent automatic closing due to the resident sensor #63
      - Added: Option to deactivate time control. This means that the system can now also be controlled exclusively via the brightness and the height of the sun. I
      - <strong>BREAKING CHANGES:</strong>
          - Cover Status Helper is now mandatory for ventilation, lockout protection and shading!
          - Invert the status of some options #61 ("Prevent the cover from being ... several times a day" instead of "Allow the cover to be ... several times a day")

    2024.05.22-01:
      - Added: Separation of the contact sensors for ventilation and lockout protection
        BREAKING CHANGE: Reconfiguration of lockout protection necessary!
      - Updated: Combining the shading triggers. No more problems with waiting times and retriggers.
      - Fixed: Do not drive down the cover after closing the contact if 'Automatic Closing Mode' is disabled
      - Fixed: Missing shading force trigger
      - Fixed: Prevent trigger with invalid status

    </details>

  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: "2024.6.0"
  input:
    blind:
      name: "üè† Cover"
      description: >-
        Which blind or roller shutter should be automated?

        <details>
        <summary><code><strong>CLICK HERE:</strong> Information about a cover group</code></summary>


        In principle, you can use a group here.
        But please note that there are problems with position detection for a group of covers!
        For example, one cover may be at position 100% and the other cover at position 0%.
        This results in a wrong group-value of 50%.


        My clear recommendation is to create **one automation for each cover**.

        </details>

      selector:
        entity:
          filter:
            - domain:
                - cover

    feature_section:
      name: "Automation Options" # ‚öôÔ∏è
      icon: mdi:window-shutter-cog
      collapsed: true
      input:
        auto_options:
          name: "üëâ Automation options"
          description: >-
            This <ins>basically</ins> determines whether the cover is allowed to open or close.


            <strong>Important note:</strong>
            The configuration of the Cover Status Helper is <ins>mandatory</ins> if you want to use the lockout protection, ventilation mode or shading.


            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            This can be extended by further conditions (see below). However, it is important that the options are still activated here.
            Otherwise the conditions will not take effect.


            **Please ensure that the corresponding sensors are also specified.**
            For example, the brightness control only works if a brightness sensor is also specified.

            </details>
          default:
            [
              auto_up_enabled,
              auto_down_enabled,
              auto_brightness_enabled,
              auto_sun_enabled,
            ]
          selector:
            select:
              options:
                - label: "üîº - Enable automatic daily cover opening"
                  value: "auto_up_enabled"
                - label: "üîª - Enable automatic daily cover closing"
                  value: "auto_down_enabled"
                - label: "üîÖ - Enable control (to open/close) via brightness values"
                  value: "auto_brightness_enabled"
                - label: "‚òÄÔ∏è - Enable control (to open/close) via sun elevation"
                  value: "auto_sun_enabled"
                - label: "üí® - Enable ventilation mode"
                  value: "auto_ventilate_enabled"
                - label: "üö™ - Enable lockout protection"
                  value: "auto_lockout_protection_enabled"
                - label: "ü•µ - Enable automatic sun shading / sun protection control"
                  value: "auto_shading_enabled"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        resident_sensor:
          name: "üõå Resident Mode"
          description: >-
            Overwrite mode for opening and unplannend closing.
            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            This switch can be used to override the automatic opening of the cover.
            If this sensor (input_boolean or binary_sensor) is set to ON, the cover will not open automatically.

            This can be used e.g. to define a resident for the room. In this case, the cover only opens when the resident is no longer asleep.
            <br />
            For this it is necessary to use a boolean sensor that returns TRUE/ON for sleeping and FALSE/OFF for non-sleeping.
            <br />
            The cover will also close (without checking the defined times) if this sensor switches to TRUE/ON (because the resident is sleeping).

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor

        individual_config:
          name: "‚öôÔ∏è Individual Configuration"
          description: >-
            Various different options for some fine adjustments

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            <ins>Prevent 'set_cover_position' and 'set_cover_tilt_position'</ins><br />
            There are devices that have problems when the two services 'set_cover_position' and 'set_cover_tilt_position' are executed directly one after the other.
            For example, there are Shelly devices that use the script [cover_position_tilt.yaml](https://gist.github.com/lukasvice/b364724d84c3ac4e160f7a7d8fa37066) here.
            Or Homematic blind actuators, which can better use their own service for this: [homematicip_local.set_cover_combined_position](https://github.com/danielperna84/custom_homematic?tab=readme-ov-file#homematicip_localset_cover_combined_position).
            This option can be used to disable the standard services and allows the control to be implemented individually via the addtional actions.

            </details>

          default: []
          selector:
            select:
              options:
                - label: "üö´ Prevent the cover from closing immediately after deactivating the lockout protection"
                  value: "prevent_close_after_lockout"
                - label: "üö´ Prevent the cover from moving to a higher position when closing in the evening"
                  value: "prevent_higher_position_closing"
                # - label: "üö´ INACTIVE: Prevent the cover from moving to a higher closing position at the end of sun shading"
                #   value: "prevent_higher_position_shading_end"
                - label: "üö´ Prevent the position from being lowered when closing in the evening if it is currently shaded" # If the cover is in the shading position, it should not be closed in the evening if the close position is lower than the shading position. The current shading position should therefore be kept."
                  value: "prevent_lowering_when_closing_if_shaded"
                - label: "üö´ Prevent the use of the 'get_forecasts' service"
                  value: "prevent_forecast_service"
                - label: "üö´ Prevent the end of sun shading when the cover is already closed"
                  value: "prevent_shading_end_if_closed"
                - label: "üö´ Prevent the use of 'set_cover_position' and 'set_cover_tilt_position' and only use the additional actions"
                  value: "prevent_default_cover_actions"
                - label: "üö´ Prevent the cover from being opened several times a day"
                  value: "prevent_opening_multiple_times"
                - label: "üö´ Prevent the cover from being closed several times a day"
                  value: "prevent_closing_multiple_times"
                - label: "üö´ Prevent the cover from being shaded several times a day"
                  value: "prevent_shading_multiple_times"
                - label: "üö´ Prevent automatic closing due to the resident sensor"
                  value: "prevent_closing_by_resident"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        ignore_after_manual_config:
          name: "‚öôÔ∏è Ignoring after manual position changes"
          description: >-
            Ignore the following actions after manual position changes.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            Ultimately, this means that the roller blind will not be opened, closed, etc.
            if a manual interaction has previously been made, e.g. using a wall switch.


            The reason behind this is that the human being wins with his decision and his
            conscious decision is weighted higher than the upcoming action of the automation.


            As soon as a cover has been moved manually, the status is recorded in the Cover Status Helper.
            This usually means that a person has deliberately decided against a status.

              - If option is not activated: The covers are moved even if a manual correction has been made.
              - If option is activated: The action to open, close, etc. is not performed because a conscious decision was made to do otherwise due to a manual intervention.


            A Cover Status Helper is required!

            </details>

          default: []
          selector:
            select:
              options:
                - label: "üîº Ignore next automatic opening after manual position changes"
                  value: "ignore_opening_after_manual"
                - label: "üîª Ignore next automatic closing after manual position changes"
                  value: "ignore_closing_after_manual"
                - label: "üí® Ignore next automatic ventilation after manual position changes"
                  value: "ignore_ventilation_after_manual"
                - label: "ü•µ Ignore next automatic sun shading after manual position changes"
                  value: "ignore_shading_after_manual"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        auto_ventilate_options:
          name: "üí® Ventilation Configuration"
          description: >-
            Various different ventilation options.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


              - <ins>Use a delay in ventilation mode after closing the contact:</ins>
                <br />
                Normally, when the window contact is closed, there is no delay in the upcoming drives. If you do want this, you can activate it here.
                <br /><br />
                The "Fixed Drive Delay" and "Random Drive Delay" settings which are already used everywhere are then used.
                <br /><br />
              - <ins>Allow ventilation even if cover is already in a higher position:</ins>
                <br />
                Activate ventilation mode even if the current position of the cover is already higher than the ventilation position.

            </details>
          default: []
          selector:
            select:
              options:
                - label: "üí® Use a delay in ventilation mode after closing the contact"
                  value: "ventilation_delay_enabled"
                - label: "üí® Allow ventilation even if cover is already in a higher position"
                  value: "ventilation_if_lower_enabled"
              multiple: true
              sort: false
              custom_value: false
              mode: list

    helper_section:
      name: "Cover Status Detection" #ü¶Æ
      icon: mdi:form-textbox
      collapsed: true
      input:
        cover_status_options:
          name: "ü¶Æ Status detection of the cover"
          description: >
            It is essential that the roller blind has the <em>current_position</em> attribute.
            Regardless of which option is selected here, the position detection is based on this attribute.
            The <em>current_tilt_position</em> attribute is <ins>not</ins> taken into account.


            <strong>Important note:</strong>
            I strongly recommend using the Cover Status Helper! The full range of functions is only available if this is configured.


            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            - <ins>Check the current position</ins><br />
            The automation only moves the cover if it is positioned at one of the defined positions (ventilate position, shading position, open position or closed position). Otherwise, the cover has been moved manually.
            After a manual drive, it is unclear what is intended to be achieved, so the automation no longer takes action.
            To automate the drive of the cover again, it must be moved to one of the defined positions beforehand.
            The advantage of this is that you don't have to create a helper in Home Assistant.
            Only basic features are available with this setting.


            - <ins>Use an external Cover Status Helper</ins><br />
            If you want to be able to do manual overrides and have the automation do the next drive as usual,
            then a helper is necessary. Without a helper, the manual override would always be overwritten by the automation.
            This has the advantage that the cover does not necessarily have to be in a defined position.
            With this choice, advanced functions are possible and you can always rely on the automation.


            </details>
          default: cover_helper_disabled
          selector:
            select:
              options:
                - label: "#Ô∏è‚É£ Check the current position"
                  value: "cover_helper_disabled"
                - label: "ü¶Æ Also use an external Cover Status Helper (better)"
                  value: "cover_helper_enabled"

        cover_status_helper:
          name: "ü¶Æ Cover Status Helper"
          description: >-
            Helper used to store the last cover event.
            *Attention:* You will need to manually create a [input_text](https://my.home-assistant.io/redirect/helpers/) entity with a <ins>length of 254 chars</ins> for this.
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              domain: input_text

        drive_time:
          name: "‚è≤Ô∏è Cover Drive Time"
          description: "Can be used to recognise manual control. Please round up a little and do not adjust too precisely. Is used to delay the trigger if too much or incorrect position data is sent back."
          default: 90
          selector:
            number:
              min: 0.0
              max: 180.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    position_section:
      name: "Position Configuration" # üìç
      icon: mdi:window-shutter-settings
      #  description: "If the cover and the integration support it, the tilt position can be used. However, the attribute 'current_position' is used for position detection and 'current_tilt_position' is not used or taken into account."
      collapsed: true
      input:
        open_position:
          name: "üîº Open Position"
          description: "What position should the cover be moved into when opening?"
          default: 100
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        open_tilt_position:
          name: "üîº Open Tilt Position"
          description: >-
            To which tilt position should the cover be moved when opening?

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            If the cover and the integration support it, the tilt position can be used.
            However, the attribute 'current_position' is used for position detection and
            'current_tilt_position' is not used or taken into account.

            </details>
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        close_position:
          name: "üîª Close Position"
          description: "What position should the cover be moved into when closing?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        close_tilt_position:
          name: "üîª Close Tilt Position"
          description: >-
            To which tilt position should the cover be moved when closing?

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            If the cover and the integration support it, the tilt position can be used.
            However, the attribute 'current_position' is used for position detection and
            'current_tilt_position' is not used or taken into account.

            </details>
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"

        ventilate_position:
          name: "üí® Ventilate Position"
          description: >-
            What position should the cover move to when opening the window/door and the cover is closed to allow ventilation?
            If closing is triggered and the <em>contact_sensor</em> is 'on' the cover will move to this position instead of closing completly
            <br /><br />Should not be 100. In this case please use 99. And please also note the information in the position tolerance.
            <br /><br />`Optional`
          default: 30
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        ventilate_tilt_position:
          name: "üí® Ventilate Tilt Position"
          description: >-
            To which tilt position should the cover be moved for ventilation?

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            If the cover and the integration support it, the tilt position can be used.
            However, the attribute 'current_position' is used for position detection and
            'current_tilt_position' is not used or taken into account.

            </details>
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"

        shading_position:
          name: "ü•µ Sun Shading Position"
          description: "To which position should the cover be moved for shading?<br /><br />`Shading`"
          default: 25
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        shading_tilt_position:
          name: "ü•µ Sun Shading Tilt Position"
          description: >-
            To which tilt position should the cover be moved for shading?
            <br /><br />`Shading`
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"

        position_tolerance:
          name: "„Ä∞Ô∏è Position Tolerance"
          description: >-
            Tolerance to be applied when comparing the current position with the to be position.
            These are absolute values. Not relative to the previous position values.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            Attention: Bear in mind that the other positions are not too close to each other if you include the tolerance.
            The following could cause problems and would then be <ins>incorrect</ins>:
            <br />
            - Open Position = 100<br />
            - Ventilate Position = 99<br />
            - Tolerance >= 1<br />

            </details>
          default: 0
          selector:
            number:
              min: 0.0
              max: 20.0
              unit_of_measurement: "%"

    time_section:
      name: "Time Control Configuration" #‚è≤Ô∏è
      icon: mdi:clock-time-two-outline
      collapsed: true
      input:
        time_control:
          name: "‚è≤Ô∏è Selection of time control options"
          description: >-
            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            The times for opening and closing the cover are usually configured here in the blueprint.
            There are various input fields here for this purpose.
            Even if you only want to control the covers using brightness values or the sun elevation,
            it is important to specify times. The times are used to divide the day into "morning" (up) and "evening" (down).

            However, you can also activate a scheduler helper mode at this point.
            This would allow you to configure a different time period for keeping the cover open for each day.
            Unfortunately, the HA core currently only has a 30-minute time grid for the time configuration.

            When using scheduler helper - Important difference to the usual input fields!

              - <ins>Without brightness or sun elevation control:</ins>
                As soon as the helper state is switched on, the cover is opened.
                The cover is closed when the helper state changes from off to on.

              - <ins>With brightness or sun elevation control:</ins>
                The cover is opened when the threshold is exceeded and the helper is on.
                The cover is closed when the threshold is undershot and the helper is off.

            <strong>Important information on using the schedule helper</strong>


            It is not possible to find out more about the status of the schedule helper in Home Assistant.
            I never know whether we are at the beginning or end of the period.
            However, this is important to avoid bouncing when controlling the brightness, for example.
            In order to recognise whether we are still in the opening period or the closing period,
            it is necessary to enter a very rough time period in the time variables in the blueprint.
            <br /><br />
            <ins>Example:</ins>
            If the schedule helper goes to the "ON" status at 08:00 and to the "OFF" status at 18:00, it is sufficient to configure the times as follows:
            <br /><br />
            Time For Drive Up - Early: 06:00<br />
            Time For Drive Up - Late: 12:00<br /><br />
            Time For Drive Down - Early: 16:00<br />
            Time For Drive Down - Late: 22:00<br />

            The times are not used for triggering, but only to divide the day into two halves!


            <ins>Disable time control and all time triggers</ins><br />
            Finally, you can also deactivate the time control completely.
            This means that the roller shutters are not opened or closed via time triggers.
            The sun-elevation and brightness control then also runs completely independently.

            </details>

          default: time_control_input
          selector:
            select:
              options:
                - label: "‚úèÔ∏è Use the time input fields in the blueprint"
                  value: "time_control_input"
                - label: "‚è≤Ô∏è Use an external schedule helper"
                  value: "time_control_schedule"
                - label: "üö´ Disable time control and all time triggers"
                  value: "time_control_disabled"
              sort: false
              multiple: false
              custom_value: false

        time_schedule_helper:
          name: "‚è≤Ô∏è Cover driving time schedule helper"
          description: >-
            If enabled above, please select the schedule helper here.
            Of course, it is also important that the times in the helper are configured accordingly.
            Please create only one period in total. Example: Start at 08:00 and end at 22:00.
            The helper can be created [here](https://my.home-assistant.io/redirect/helpers/).
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - schedule
              multiple: false

        workday_sensor:
          name: "üíº Sensor For Workday Today"
          description: >-
            It may be desired to open a cover at a different time on work days than on non-work days.
            The corresponding binary sensor can be defined here. If not set, the cover will open every time at time_up_early.
            <br /><br />
            Example: `binary_sensor.workday_today`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        workday_sensor_tomorrow:
          name: "üíº Sensor For Workday Tomorrow (only for closing)"
          description: >-
            When <ins>closing</ins> the blinds, you have the option of checking the times for tomorrow rather than the current day.
            This has the advantage that you can <ins>close</ins> the blinds earlier if <ins>tomorrow</ins> is a working day.
            This makes sense if, for example, there is school tomorrow but today is actually still the weekend.
            But the child has to go to bed earlier.<br />
            If this field is not configured here, the normal working day sensor is used.
            <br /><br />
            Example: `binary_sensor.workday_tomorrow`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        time_up_early:
          name: "üîº Time For Drive Up - Early On Workdays"
          description: >-
            The earliest time at which the cover may be opened. The cover will be opened if <ins>AFTER</ins> this time the defined brightness
            or sun-elevation value is high enough. (**NOTE**: If a resident is defined, he must also be awake).
          default: "06:00:00"
          selector:
            time: {}

        time_up_early_non_workday:
          name: "üîº Time For Drive Up - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "07:00:00"
          selector:
            time: {}

        time_up_late:
          name: "üîº Time For Drive Up - Late On Workdays"
          description: >-
            The latest time at which the cover should be opened.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be opened.
            (**NOTE**: If a resident is defined and he is still asleep, the cover will <ins>NOT</ins> be opened.
            It will only be opened when the resident has woken up).
          default: "08:00:00"
          selector:
            time: {}

        time_up_late_non_workday:
          name: "üîº Time For Drive Up - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "08:00:00"
          selector:
            time: {}

        time_down_early:
          name: "üîª Time For Drive Down - Early On Workdays"
          description: >-
            The earliest time at which the cover may be closed.
            The cover will be closed if <ins>AFTER</ins> this time the defined brightness or sun-elevation value is low enough.
          default: "16:00:00"
          selector:
            time: {}

        time_down_early_non_workday:
          name: "üîª Time For Drive Down - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "16:00:00"
          selector:
            time: {}

        time_down_late:
          name: "üîª Time For Drive Down - Late On Workdays"
          description: >-
            The latest time at which the cover should be closed.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be closed.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

        time_down_late_non_workday:
          name: "üîª Time For Drive Down - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

    brightness_section:
      name: "Brightness Configuration" #üîÖ
      icon: mdi:brightness-5
      collapsed: true
      input:
        default_brightness_sensor:
          name: "üîÖ Default Brightness Sensor"
          description: >-
            This default brightness sensor can be defined here, which is used for daily up and down.
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        brightness_time_duration:
          name: "üîÖ Brightness Time Duration"
          description: "Defines the time to given brightness sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        brightness_up:
          name: "üîÖ Brightness Value For Opening The Cover"
          description: "At what brightness value should the cover be opened?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        brightness_down:
          name: "üîÖ Brightness Value For Closing The Cover"
          description: "At what brightness value should the cover be closed? Must be lower then the brightness up value."
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

    sun_section:
      name: "Sun Elevation Settings" #‚òÄÔ∏è
      icon: mdi:weather-sunny
      collapsed: true
      input:
        default_sun_sensor:
          name: "‚òÄÔ∏è Sun Sensor"
          description: >-
            Which sensors provides attributes with current azimuth and elevation of sun.
            I strongly suggest to use sun.sun ([Sun integration](https://www.home-assistant.io/integrations/sun/)).
            Please make sure that the integration is activated and provides the attributes.
            <strong>Important: If you want to use automatic shading, the sensor must also be specified here.
            Regardless of whether the basic sun control is used.</strong>
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: "sun.sun"
          selector:
            entity:
              filter:
                - domain:
                    - sun

        sun_time_duration:
          name: "‚òÄÔ∏è Sun Time Duration"
          description: "Defines the time to given sun sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        sun_elevation_up:
          name: "‚òÄÔ∏è Sun Elevation Value For Opening The Cover"
          description: "The cover will be <ins>opened</ins> if the sun elevation is over this value"
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        sun_elevation_down:
          name: "‚òÄÔ∏è Sun Elevation Value For Closing The Cover"
          description: "The cover will be <ins>closed</ins> if the sun elevation is under this value"
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

    delay_section:
      name: "Delay Settings" #üïõ
      icon: mdi:timer-outline
      collapsed: true
      input:
        drive_delay_fix:
          name: "üïõ Fixed Drive Delay"
          description: >-
            Fixed drive delay to avoid radio interferences.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        drive_delay_random:
          name: "üïõ Random Drive Delay"
          description: "Additional random delay."
          default: 5
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        tilt_delay:
          name: "üïõ Tilt Delay"
          description: >-
            Delay between <em>set_cover_position</em> and <em>set_cover_tilt_position</em>.
            Only necessary when using the tilt functions.
            This separates the two commands in terms of time.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    contacts_section:
      name: "Contact Sensors" #üí®
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        contact_sensor:
          name: "üí® Contact Sensor Entity For Ventilation"
          description: >-
            The contact sensor is required for ventilation mode. It must be a binary two-way contact sensor.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.

            If the door contact changes to on/true, the cover is moved to the ventilation position.
            The prerequisite is that the cover is already closed.
            After the status changes to off/false, the close position is activated.
            The same applies in the shading-out situation.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

        contact_sensor_lockout:
          name: "üí® Contact Sensor Entity For Lockout Protection"
          description: >-
            The contact sensor is required for lockout protection. It must be a binary two-way contact sensor.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.

            The cover is not closed and the sun shading is not activated when the door contact is open.
            Note that the cover can close in the evening when the door contact is closed.
            It is not moved to the previously desired shading position!
            <br /><br />
            If the sun shading is cancelled, the door contact is open and the lockout protection is enabled,
            the blind does not move from the shading position to the ventilation position.
            Instead, the roller blind is opened.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

    shading_section:
      name: "Shading Settings" #ü•µ
      icon: mdi:shield-sun-outline
      collapsed: true
      input:
        shading_brightness_sensor:
          name: "ü•µ Brightness Sensor For Sun Shading"
          description: >-
            This sensor is only used for shading.
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_sun_brightness_start:
          name: "ü•µ Sun Shading Brightness Start Value"
          description: >-
            The minimum brightness value from which shading should start.
            (Must be above the value of brightness end!)
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: 35000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_sun_brightness_end:
          name: "ü•µ Sun Shading Brightness End Value"
          description: >-
            The brightness value from which shading is no longer necessary.
            (Must be below the value of brightness start!).
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: 25000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_azimuth_start:
          name: "ü•µ Sun Shading Azimuth Start Value"
          description: >-
            What is the minimum azimuth at which the sun hits the window? (Shading will start)
            <br /><br />`The attribute of default sun sensor (configured above) is used.`
            <br /><br />`Shading`
          default: 95
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_azimuth_end:
          name: "ü•µ Sun Shading Azimuth End Value"
          description: >-
            What is the maximum azimuth at which the sun hits the window? (Shading will stop)
            <br /><br />`The attribute of default sun sensor (configured above) is used.`
            <br /><br />`Shading`
          default: 265
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_elevation_min:
          name: "ü•µ Sun Shading Elevation Minimum Value"
          description: >-
            Starting from which elevation of the sun should the window be shaded?
            (Here it makes sense to consider surrounding buildings, trees, etc.).
            <br /><br />`The attribute of default sun sensor (configured above) is used.`
            <br /><br />`Shading`
          default: 25
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_elevation_max:
          name: "ü•µ Sun Shading Elevation Maximum Value"
          description: >-
            What is the maximal elevation for elevation?
            (In most cases, 90 degrees is probably the most reasonable value.
            However, this can also be different due to surrounding buildings, etc.).
            <br /><br />`The attribute of default sun sensor (configured above) is used.`
            <br /><br />`Shading`
          default: 90
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_temperatur_sensor1:
          name: "ü•µ Sun Shading Temperature Sensor 1 (eg. indoor)"
          description: >-
            This is the main temperature sensor.
            (Here, for example, the current indoor temperature can be used as a condition).
            <br /><br />`Optional`
            <br /><br />`Shading`
          selector:
            entity:
              filter:
                - domain:
                    - sensor
          default: []

        shading_min_temperatur1:
          name: "ü•µ Sun Shading Temperature Sensor 1 Minimum Value"
          description: >-
            Minimum temperature for sensor 1 above which shading should occur.
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: 18
          selector:
            number:
              min: 0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperatur_sensor2:
          name: "ü•µ Sun Shading Temperature Sensor 2 (eg. outdoor)"
          description: >-
            This is a secondary temperature sensor.
            (Here, for example, the current outdoor temperature can be used as a condition).
            <br />
            This sensor has another function. Please read the notes in the <ins>Sun Shading Forecast Temperatur Value</ins> entry below.
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_min_temperatur2:
          name: "ü•µ Sun Shading Temperature Sensor 2 Minimum Value"
          description: >-
            Minimum temperature for sensor 2 above which shading should occur.
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: 18
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_forecast_sensor:
          name: "ü•µ Sun Shading Forecast Temperature Sensor"
          description: >-
            Another temperature sensor. In this case, however, explicitly for use with a forecast.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            The idea is that it can happen, especially in spring, that the value of the Forecast Temperatur Value exceeded by
            strong solar radiation and the shading would be started.
            However, in spring you may not want shading, but the solar radiation as a welcome, free heating is desired.
            So you can define via the forecast sensor that shading is only started at an expected daily maximum temperature.
            <br /><br />
            **NOTE**:
              - Sensor must support weather.get_forecasts which has been introduced with HA 2023.9.
              - Currently, only the "Daily" forecast type is used.
            </details>
            <br /><br /><code>Optional</code>
            <br /><br /><code>Shading</code>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - weather

        shading_forecast_temp:
          name: "ü•µ Sun Shading Forecast Temperatur Value"
          description: >-
            Minimum temperature for forecast sensor above which shading should occur.
            <br />
            There is a special feature when comparing the shading forecast temperature. Please continue reading!

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            The forecast is not always correct. For this reason, the Sun Shading Temperature Sensor No.2 is compared in addition to this value.
            <br /><br />
            <strong>Conclusion:</strong>
            The returned value of the weather forecast for today is compared with
            <br />- <ins>Sun Shading Temperature Sensor 2</ins> and
            <br />- <ins>Sun Shading Forecast Temperatur Value</ins>.
            <br /><br />
            It is sufficient if one of the two exceeds the configured value.

            </details>
            <br /><br /><code>Optional</code>
            <br /><br /><code>Shading</code>
          default: 20
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_weather_conditions:
          name: "ü•µ Sun Shading Weather Conditions"
          description: >-
            Check the following weather conditions when activating the shading.
            **NOTE**: Forecast sensor needs to be defined
            <br /><br />`Optional`
            <br /><br />`Shading`
          default:
            - sunny
            - partlycloudy
            - cloudy
            - clear
          selector:
            select:
              multiple: true
              options:
                - "clear-night"
                - "clear"
                - "cloudy"
                - "fog"
                - "hail"
                - "lightning"
                - "lightning-rainy"
                - "partlycloudy"
                - "pouring"
                - "rainy"
                - "snowy"
                - "snowy-rainy"
                - "sunny"
                - "windy"
                - "windy-variant"
                - "exceptional"

        shading_waitingtime_start:
          name: "ü•µ Waiting Time For Sun Shading Start"
          description: >-
            To avoid overloading the motor, a waiting time can be defined here for the start of shading.
            The shade will then only start if <ins>all</ins> mandatory conditions are fulfilled for the entire waiting time.
            <br /><br />
            Note: The automated system only waits for the time when the roller blind is above the ventilation position.
            <br /><br />`Shading`
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

        shading_waitingtime_end:
          name: "ü•µ Waiting Time For Sun Shading End"
          description: >-
            To avoid excessive load on the motor, a waiting time can be defined here before the shading is ended.
            Shading ends if <ins>one</ins> of the conditions is <ins>not</ins> fulfilled for the entire waiting time.
            <br /><br />`Shading`
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

    condition_section:
      name: "Additional Conditions" #‚ùì
      icon: mdi:help-rhombus-outline
      collapsed: true
      input:
        auto_global_condition:
          name: "‚ùì Additional condition for the entire automation"
          description: >-
            This condition allows you to control the execution of the <ins>entire</ins> automation dynamically and outside of the blueprint configuration.
            With this option you could enable a party mode.<br /><br />
            This is the only condition that is also taken into account in the force features.
            Forcing Open/Close/Shading/Ventilation is therefore only possible if this condition remains empty or becomes valid.
            <br /><br />`Optional`
          default: []
          selector:
            condition: {}

        auto_up_condition:
          name: "üîº Additional Condition For Opening The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>opening</ins> of the cover.
            You can use this, for example, if the covers normally don't open, but you really want to do it on vacation.
            <br /><br />`Optional`
          default: []
          selector:
            condition: {}

        auto_down_condition:
          name: "üîª Additional Condition For Closing The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>closing</ins> of the cover.
            You can use this, for example, at Christmas time or if you want the covers to behave differently while on vacation.
            <br /><br />`Optional`
          default: []
          selector:
            condition: {}

        auto_ventilate_condition:
          name: "üí® Additional Condition For Ventilation"
          description: >-
            This condition can be used to dynamically control the <ins>start of the ventilation</ins> of the cover.
            <br /><br />`Optional`
          default: []
          selector:
            condition: {}

        auto_shading_start_condition:
          name: "ü•µ Additional Condition For Activating Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-IN-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br />
            Another example: Here you could also set that the shading is only triggered in the summer season.
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: []
          selector:
            condition: {}

        auto_shading_end_condition:
          name: "ü•µ Additional Condition For Disabling Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-OUT-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br /><br />`Optional`
            <br /><br />`Shading`
          default: []
          selector:
            condition: {}

    force_section:
      name: "Force Features" #üí™
      icon: mdi:arm-flex
      collapsed: true
      input:
        auto_up_force:
          name: "üîº Force Immediate Opening"
          description: >-
            If the status of this entity changes to on or true, the cover is opened immediately and without further checking.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            This can be used for the following purposes under certain circumstances: Antifreeze, RainProtection or WindProtection.

            Note:
              - However, after forcing a state, you must ensure that you move to the correct target position yourself. You are responsible for getting CCA back on track.
              - This cannot be performed in CCA and must therefore be done via a separate automation. Presumably in the same automation that sets the "Force"-boolean. It is sufficient, by the way, if a configured position is targeted. CCA then recognises the status.
              - Force is a final state that cannot be cancelled or resetted by CCA.
              - The default automations (open, close, and further) will never be able to override a force. The force feature must therefore be cancelled manually beforehand.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor

        auto_down_force:
          name: "üîª Force Immediate Closing"
          description: >-
            If the status of this entity changes to on or true, the cover is closed immediately and without further checking.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            This can be used for the following purposes under certain circumstances: Antifreeze, RainProtection or WindProtection.

            Note:
              - However, after forcing a state, you must ensure that you move to the correct target position yourself. You are responsible for getting CCA back on track.
              - This cannot be performed in CCA and must therefore be done via a separate automation. Presumably in the same automation that sets the "Force"-boolean. It is sufficient, by the way, if a configured position is targeted. CCA then recognises the status.
              - Force is a final state that cannot be cancelled or resetted by CCA.
              - The default automations (open, close, and further) will never be able to override a force. The force feature must therefore be cancelled manually beforehand.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor

        auto_ventilate_force:
          name: "üí® Force Immediate Ventilation"
          description: >-
            If the status of this entity changes to on or true, the cover is immediately set to ventilation mode and without further checking.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            This can be used for the following purposes under certain circumstances: Antifreeze, RainProtection or WindProtection.

            Note:
              - However, after forcing a state, you must ensure that you move to the correct target position yourself. You are responsible for getting CCA back on track.
              - This cannot be performed in CCA and must therefore be done via a separate automation. Presumably in the same automation that sets the "Force"-boolean. It is sufficient, by the way, if a configured position is targeted. CCA then recognises the status.
              - Force is a final state that cannot be cancelled or resetted by CCA.
              - The default automations (open, close, and further) will never be able to override a force. The force feature must therefore be cancelled manually beforehand.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor

        auto_shading_start_force:
          name: "ü•µ Force Activation Sun Shading"
          description: >-
            If the status of this entity changes to on or true, the shading is immediately activated and without further checking.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            This can be used for the following purposes under certain circumstances: Antifreeze, RainProtection or WindProtection.

            Note:
              - However, after forcing a state, you must ensure that you move to the correct target position yourself. You are responsible for getting CCA back on track.
              - This cannot be performed in CCA and must therefore be done via a separate automation. Presumably in the same automation that sets the "Force"-boolean. It is sufficient, by the way, if a configured position is targeted. CCA then recognises the status.
              - Force is a final state that cannot be cancelled or resetted by CCA.
              - The default automations (open, close, and further) will never be able to override a force. The force feature must therefore be cancelled manually beforehand.

            </details>
            <br /><code>Optional</code>
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor

    actions_section:
      name: "Additional Actions" # ‚ñ∂Ô∏è
      icon: mdi:run
      collapsed: true
      input:
        auto_up_action:
          name: "üîº Additional Actions After Opening The Cover"
          description: Additional actions to run after opening the cover
          default: []
          selector:
            action: {}

        auto_down_action:
          name: "üîª Additional Actions After Closing The Cover"
          description: Additional actions to run after closing the cover
          default: []
          selector:
            action: {}

        auto_ventilate_action:
          name: "üí® Additional Actions After Ventilating The Cover"
          description: Additional actions to run after ventilating the cover
          default: []
          selector:
            action: {}

        auto_shading_start_action:
          name: "ü•µ Additional Actions After Activating Sun Shading"
          description: Additional actions to run after activating sun shading
          default: []
          selector:
            action: {}

        auto_shading_end_action:
          name: "ü•µ Additional Actions After Disabling Sun Shading"
          description: Additional actions to run after disabling sun shading
          default: []
          selector:
            action: {}

    configcheck_section:
      name: "Configuration Check" #‚úîÔ∏è
      icon: mdi:invoice-text-check-outline
      collapsed: true
      input:
        check_config:
          name: "‚úîÔ∏è Check Configuration"
          description: >-
            With this boolean, you can enable or disable the basic plausibility check for the configuration.
            he check only takes place if the automation is executed manually.
          default: false
          selector:
            boolean: {}

        check_config_debuglevel:
          name: "‚úîÔ∏è Check Configuration - Debug level"
          description: >-
            Choose the debug level for Syslog messages in case of configuration issues
            <br />
            Please make sure that it suits your Home Assistant logger default level.
          default: "info"
          selector:
            select:
              multiple: false
              mode: dropdown
              options:
                - "critical"
                - "debug"
                - "error"
                - "info"
                - "warning"

trigger_variables:
  blind: !input blind

  # Positions
  open_position: !input open_position
  close_position: !input close_position
  shading_position: !input shading_position
  position_tolerance: !input position_tolerance

  # Modes
  auto_options: !input auto_options

  # Times
  time_up_early: !input time_up_early
  time_up_early_non_workday: !input time_up_early_non_workday
  time_up_late: !input time_up_late
  time_up_late_non_workday: !input time_up_late_non_workday
  time_down_early: !input time_down_early
  time_down_early_non_workday: !input time_down_early_non_workday
  time_down_late: !input time_down_late
  time_down_late_non_workday: !input time_down_late_non_workday
  workday_sensor: !input workday_sensor
  workday_sensor_tomorrow: !input workday_sensor_tomorrow

  # Brightness
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down

  # Sun
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down

  # Sensors
  contact_sensor: !input contact_sensor
  contact_sensor_lockout: !input contact_sensor_lockout
  resident_sensor: !input resident_sensor

  # Time controls
  time_control: !input time_control
  time_schedule_helper: !input time_schedule_helper

  # Shading
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_forecast_temp: !input shading_forecast_temp
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_weather_conditions: !input shading_weather_conditions

  # Internal code helper
  is_shading_enabled: "{{ 'auto_shading_enabled' in auto_options }}"
  is_up_enabled: "{{ 'auto_up_enabled' in auto_options }}"
  is_down_enabled: "{{ 'auto_down_enabled' in auto_options }}"
  is_brightness_enabled: "{{ 'auto_brightness_enabled' in auto_options }}"
  is_sun_elevation_enabled: "{{ 'auto_sun_enabled' in auto_options }}"
  is_ventilation_enabled: "{{ 'auto_ventilate_enabled' in auto_options }}"
  is_lockout_protection_enabled: "{{ 'auto_lockout_protection_enabled' in auto_options }}"
  is_time_field_enabled: "{{ 'time_control_input' in time_control or time_control == [] or time_schedule_helper == [] }}"
  is_schedule_helper_enabled: "{{ 'time_control_schedule' in time_control and time_schedule_helper != [] }}"
  is_time_control_disabled: "{{ 'time_control_disabled' in time_control }}"

variables:
  version: "2024.06.24"

  blind_entities: "{{ expand(blind) | map(attribute='entity_id') | list }}"
  current_position: "{{ state_attr(blind, 'current_position') if state_attr(blind, 'current_position') is not none else state_attr(blind, 'position') }}"
  current_sun_azimuth: "{{ state_attr(default_sun_sensor, 'azimuth') }}"
  current_sun_elevation: "{{ state_attr(default_sun_sensor, 'elevation') }}"

  # Delays
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time

  time_up_early_today: >-
    {% if time_up_early_non_workday == [] or workday_sensor == [] or (is_state(workday_sensor, 'on')) %}
      {{ time_up_early }}
    {% else %}
      {{ time_up_early_non_workday }}
    {% endif %}

  time_up_late_today: >-
    {% if time_up_late_non_workday == [] or workday_sensor == [] or (is_state(workday_sensor, 'on')) %}
      {{ time_up_late }}
    {% else %}
      {{ time_up_late_non_workday }}
    {% endif %}

  time_down_early_today: >-
    {% if
      (workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on')) or
      time_down_early_non_workday == [] or
      workday_sensor == [] or
      is_state(workday_sensor, 'on')
    %}
      {{ time_down_early }}
    {% else %}
      {{ time_down_early_non_workday }}
    {% endif %}

  time_down_late_today: >-
    {% if
      (workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on')) or
      time_down_late_non_workday == [] or
      workday_sensor == [] or
      is_state(workday_sensor, 'on')
    %}
      {{ time_down_late }}
    {% else %}
      {{ time_down_late_non_workday }}
    {% endif %}

  # Positions
  open_tilt_position: !input shading_tilt_position
  close_tilt_position: !input close_tilt_position
  ventilate_position: !input ventilate_position
  ventilate_tilt_position: !input ventilate_tilt_position

  # Force
  auto_up_force: !input auto_up_force
  auto_down_force: !input auto_down_force
  auto_ventilate_force: !input auto_ventilate_force
  auto_shading_start_force: !input auto_shading_start_force

  # Shading
  shading_tilt_position: !input shading_tilt_position

  # Config check
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel

  # Cover Status Helper
  cover_status_options: !input cover_status_options
  cover_status_helper: !input cover_status_helper
  is_status_helper_enabled: >-
    {{
      'cover_helper_enabled' in cover_status_options and
      cover_status_helper != [] and
      states(cover_status_helper) != [] and
      states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
      states(cover_status_helper) not in ["unavailable", "none", "unknown"]
    }}

  # Cover status assignments
  is_cover_open: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('open') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).open.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_open_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('open') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).open.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  is_cover_closed: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('close') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).close.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_closed_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('close') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).close.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  is_cover_ventilated: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('ventilate') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).ventilate.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_ventilated_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('ventilate') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).ventilate.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  is_cover_shaded: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('shading') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).shading.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_shaded_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('shading') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).shading.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  is_cover_locked: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('locked') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).locked.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_locked_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('locked') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).locked.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  is_cover_manual: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('manual') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).manual.a | bool }}
    {% else %}
      {{ false }}
    {% endif %}

  is_cover_manual_ts: >-
    {% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('manual') and (states(cover_status_helper)|from_json).v >= 2 %}
      {{ (states(cover_status_helper)|from_json).manual.t }}
    {% else %}
      {{ 0 }}
    {% endif %}

  cover_status_time: >-
    {{
      is_status_helper_enabled and
      (states(cover_status_helper)|from_json).t
    }}

  in_open_position: "{{ (current_position | int(default=101) <= open_position + position_tolerance) and (current_position | int(default=101) >= open_position - position_tolerance) }}"
  in_close_position: "{{ (current_position | int(default=101) <= close_position + position_tolerance) and (current_position | int(default=101) >= close_position - position_tolerance) }}"
  in_shading_position: "{{ (current_position | int(default=101) <= shading_position + position_tolerance) and (current_position | int(default=101) >= shading_position - position_tolerance) }}"
  in_ventilate_position: "{{ (current_position | int(default=101) <= ventilate_position + position_tolerance) and (current_position | int(default=101) >= ventilate_position - position_tolerance) }}"

  individual_config: !input individual_config
  prevent_close_after_lockout: "{{ 'prevent_close_after_lockout' in individual_config }}"
  prevent_higher_position_closing: "{{ 'prevent_higher_position_closing' in individual_config }}"
  # prevent_higher_position_shading_end: "{{ 'prevent_higher_position_shading_end' in individual_config }}"
  prevent_lowering_when_closing_if_shaded: "{{ 'prevent_lowering_when_closing_if_shaded' in individual_config }}"
  prevent_forecast_service: "{{ 'prevent_forecast_service' in individual_config }}"
  prevent_shading_end_if_closed: "{{ 'prevent_shading_end_if_closed' in individual_config }}"
  prevent_default_cover_actions: "{{ 'prevent_default_cover_actions' in individual_config }}"
  prevent_shading_multiple_times: "{{ 'prevent_shading_multiple_times' in individual_config }}"
  prevent_opening_multiple_times: "{{ 'prevent_opening_multiple_times' in individual_config }}"
  prevent_closing_multiple_times: "{{ 'prevent_closing_multiple_times' in individual_config }}"
  prevent_closing_by_resident: "{{ 'prevent_closing_by_resident' in individual_config }}"

  ignore_after_manual_config: !input ignore_after_manual_config
  ignore_opening_after_manual: "{{ 'ignore_opening_after_manual' in ignore_after_manual_config }}"
  ignore_closing_after_manual: "{{ 'ignore_closing_after_manual' in ignore_after_manual_config }}"
  ignore_ventilation_after_manual: "{{ 'ignore_ventilation_after_manual' in ignore_after_manual_config }}"
  ignore_shading_after_manual: "{{ 'ignore_shading_after_manual' in ignore_after_manual_config }}"

  auto_ventilate_options: !input auto_ventilate_options
  ventilation_delay_enabled: "{{ 'ventilation_delay_enabled' in auto_ventilate_options }}"
  ventilation_if_lower_enabled: "{{ 'ventilation_if_lower_enabled' in auto_ventilate_options }}"

mode: restart
max_exceeded: silent

trigger:
  ########################################
  # Trigger for opening cover
  ########################################

  - platform: template
    value_template: >-
      {% if time_up_early_non_workday == [] or workday_sensor == [] or (is_state(workday_sensor, 'on')) %}
        {{ now() >= today_at(time_up_early) }}
      {% else %}
        {{ now() >= today_at(time_up_early_non_workday) }}
      {% endif %}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_bo_1"

  - platform: template
    value_template: >-
      {% if time_up_late_non_workday == [] or workday_sensor == [] or (is_state(workday_sensor, 'on')) %}
        {{ now() >= today_at(time_up_late) }}
      {% else %}
        {{ now() >= today_at(time_up_late_non_workday) }}
      {% endif %}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_bo_2"

  - platform: template
    value_template: "{{ is_state(time_schedule_helper, ['true', 'on']) }}"
    enabled: "{{ is_schedule_helper_enabled and time_schedule_helper != [] }}"
    id: "t_bo_3"

  - platform: template
    value_template: "{{ states(default_brightness_sensor) | float(default=brightness_up) > brightness_up }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_bo_4"

  - platform: template
    value_template: "{{ state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_up) > sun_elevation_up }}"
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_bo_5"

  - platform: state
    entity_id: !input resident_sensor
    from: "on"
    to: "off"
    id: "t_bo_6"

  - platform: state
    entity_id: !input auto_up_force
    from: "off"
    to: "on"
    id: "t_bo_force"

  ########################################
  # Trigger for closing cover
  ########################################

  - platform: template
    value_template: >-
      {% if
        (workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on')) or
        time_down_early_non_workday == [] or
        workday_sensor == [] or
        is_state(workday_sensor, 'on')
      %}
        {{ is_time_field_enabled and now() >= today_at(time_down_early) }}
      {% else %}
        {{ is_time_field_enabled and now() >= today_at(time_down_early_non_workday) }}
      {% endif %}
    enabled: "{{ not is_time_control_disabled }}"
    id: "t_bc_1"

  - platform: template
    value_template: >-
      {% if
        (workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on')) or
        time_down_late_non_workday == [] or
        workday_sensor == [] or
        is_state(workday_sensor, 'on')
      %}
        {{ is_time_field_enabled and now() >= today_at(time_down_late) }}
      {% else %}
        {{ is_time_field_enabled and now() >= today_at(time_down_late_non_workday) }}
      {% endif %}
    enabled: "{{ not is_time_control_disabled }}"
    id: "t_bc_2"

  - platform: template
    value_template: "{{ is_state(time_schedule_helper, ['false', 'off']) }}"
    enabled: "{{ is_schedule_helper_enabled and time_schedule_helper != [] }}"
    id: "t_bc_3"

  - platform: template
    value_template: "{{ (states(default_brightness_sensor) | float(default=brightness_down) < brightness_down) }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_bc_4"

  - platform: template
    value_template: "{{ state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_down) < sun_elevation_down }}"
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_bc_5"

  - platform: state
    entity_id: !input resident_sensor
    from: "off"
    to: "on"
    id: "t_bc_6"

  - platform: state
    entity_id: !input auto_down_force
    from: "off"
    to: "on"
    id: "t_bc_force"

  #################################################
  # Trigger for ventilation and lockout protection
  #################################################

  - platform: template
    value_template: "{{ is_state(contact_sensor, ['true', 'on']) }}"
    enabled: "{{ is_ventilation_enabled and contact_sensor != [] }}"
    id: "t_ct_vent_open"

  - platform: template
    value_template: "{{ is_state(contact_sensor, ['false', 'off']) }}"
    enabled: "{{ is_ventilation_enabled and contact_sensor != [] }}"
    id: "t_ct_vent_close"

  - platform: template
    value_template: "{{ is_state(contact_sensor_lockout, ['false', 'off']) }}"
    enabled: "{{ is_lockout_protection_enabled and contact_sensor_lockout != [] }}"
    id: "t_ct_lock_close"

  - platform: state
    entity_id: !input auto_ventilate_force
    from: "off"
    to: "on"
    id: "t_ve_force"

  ########################################
  # Triggers for shading start
  ########################################

  - platform: template
    value_template: >-
      {{
        default_sun_sensor != [] and
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start) > shading_azimuth_start and
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) < shading_azimuth_end and
        state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) > shading_elevation_min and
        (shading_brightness_sensor == [] or states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > shading_sun_brightness_start) and
        (shading_temperatur_sensor1 == [] or states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > shading_min_temperatur1) and
        (shading_temperatur_sensor2 == [] or states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > shading_min_temperatur2) and
        (shading_forecast_sensor == [] or shading_weather_conditions == [] or states(shading_forecast_sensor) in shading_weather_conditions)
      }}
    for:
      seconds: !input shading_waitingtime_start
    enabled: "{{ is_shading_enabled }}"
    id: "t_si_1"

  - platform: state
    entity_id: !input auto_shading_start_force
    from: "off"
    to: "on"
    id: "t_si_force"

  ########################################
  # Triggers for shading end
  ########################################

  - platform: template
    value_template: >-
      {{
        (shading_temperatur_sensor1 != [] and states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) < shading_min_temperatur1) or
        (shading_temperatur_sensor2 != [] and states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) < shading_min_temperatur2) or
        (shading_brightness_sensor != [] and states(shading_brightness_sensor) | float(default=shading_sun_brightness_end) < shading_sun_brightness_end) or
        (shading_forecast_sensor != [] and states(shading_forecast_sensor) not in shading_weather_conditions) or
            default_sun_sensor != [] and
            (
                (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) > shading_elevation_max) or
                (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) > shading_elevation_max) or
                (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) > shading_azimuth_end) or
                (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) < shading_elevation_min)
            )
      }}
    for:
      seconds: !input shading_waitingtime_end
    enabled: "{{ is_shading_enabled }}"
    id: "t_so_1"

  ########################################
  # Trigger for manual cover controls
  ########################################

  - platform: state
    entity_id: !input blind
    attribute: current_position
    id: "t_ma_1"
    for: "00:01:00"

  ########################################
  # Global conditions
  ########################################

condition:
  - condition: !input auto_global_condition
  - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}" # The following values are not valid to trigger
  - "{{ state_attr(this.entity_id,'current') | int(99) == 0 }}" # Avoid multiple triggering

  ###############################################################################################
  # ACTION
  #
  #   Note: I really have a lot of repetitive YAML code here in the blueprint.
  #   I'm not used to this and I would like to encapsulate it in functions or something similar
  #   or make the process more generic. Unfortunately, my hands are tied in an HA blueprint
  #   and there is this really large amount of - actually nonsensical - repetition.
  #   So please don't be surprised. I don't like that either. :-)
  ###############################################################################################

action:
  # Querying the weather forecast
  - if:
      - "{{ is_shading_enabled }}"
      - "{{ not prevent_forecast_service }}"
      - "{{ (shading_forecast_sensor != [] ) }}"
      - condition: trigger # Important: All triggers for shading start necessary!
        id:
          - "t_si_1"
          - "t_bo_1"
          - "t_bo_3"
    then:
      - service: weather.get_forecasts
        target:
          entity_id: !input shading_forecast_sensor
        data:
          type: daily
        response_variable: weather_forecast

  # Initialise empty helper with JSON default values
  - if:
      - "{{ 'cover_helper_enabled' in cover_status_options }}"
      - "{{ cover_status_helper != [] }}"
      - or:
          - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") }}'
          - '{{ states(cover_status_helper) in ["unavailable", "none", "unknown"] }}'
    then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: |
            {% set dict_var = {
              'open':{'a':false,'t':0},
              'close':{'a':false,'t':0},
              'ventilate':{'a':false,'t':0},
              'shading':{'a':false,'t':0},
              'locked':{'a':false,'t':0},
              'manual':{'a':false,'t':0},
              'p':current_position,
              'v':4,
              't':as_timestamp(now()) | round(0)
              }
            %}
            {{ dict_var | to_json }}

  # Upgrade JSON-helper to current version
  - if:
      - "{{ is_status_helper_enabled }}"
      - "{{ (states(cover_status_helper)|from_json).v != 4 }}"
    then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: |
            {% set dict_var = {
              'open':{'a':is_cover_open,'t':is_cover_open_ts},
              'close':{'a':is_cover_closed,'t':is_cover_closed_ts},
              'ventilate':{'a':is_cover_ventilated,'t':is_cover_ventilated_ts},
              'shading':{'a':is_cover_shaded,'t':is_cover_shaded_ts},
              'locked':{'a':is_cover_locked,'t':is_cover_locked_ts},
              'manual':{'a':is_cover_manual,'t':is_cover_manual_ts},
              'p':current_position,
              'v':4,
              't':cover_status_time | round(0)
              }
            %}
            {{ dict_var | to_json }}

  - choose:
      ############################################################
      # ANCHOR: OPEN
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Open, Shading
      ############################################################

      - alias: "Check for opening"
        conditions:
          - "{{ is_up_enabled }}"
          - condition: !input auto_up_condition
          - condition: trigger
            id:
              - "t_bo_1"
              - "t_bo_2"
              - "t_bo_3"
              - "t_bo_4"
              - "t_bo_5"
              - "t_bo_6"
          - "{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force, ['false', 'off']) }}"
          - or: # Check the current positions
              - "{{ is_status_helper_enabled and not is_cover_open }}"
              - "{{ is_ventilation_enabled and in_ventilate_position }}"
              - "{{ in_close_position }}"
          - or: # Ignore check
              - "{{ not is_status_helper_enabled }}"
              - "{{ is_status_helper_enabled and not is_cover_manual }}"
              - "{{ is_status_helper_enabled and ignore_opening_after_manual }}"
              - "{{ is_status_helper_enabled and is_cover_manual and not ignore_opening_after_manual }}"
          - or: # Only once a day?
              - "{{ not is_status_helper_enabled }}"
              - "{{ not prevent_opening_multiple_times }}"
              - "{{ is_status_helper_enabled and prevent_opening_multiple_times and (now().day != is_cover_open_ts|timestamp_custom('%-d')|int) }}"
          - or:
              - "{{ resident_sensor == [] }}"
              - "{{ is_state(resident_sensor, ['false', 'off']) }}"
          - or: # Now we have to check different opening scenarios
              - and: # Control via times disabled
                  - "{{ is_time_control_disabled }}"
              - and: # Opening - Up late reached
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_up_late_today) }}"
                  - "{{ now() <= today_at(time_down_early_today) - timedelta(seconds = 5) }}"
              - and: # Opening - Scheduler changes to on
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  - "{{ is_state(time_schedule_helper, 'on') }}"
                  - condition: trigger
                    id: "t_bo_3"
              - and: # Opening - Up early reached or schedule helper is on and brightness/sun above minimum
                  - or:
                      - and:
                          - "{{ is_time_control_disabled }}"
                      - and:
                          - "{{ is_time_field_enabled }}"
                          - "{{ now() >= today_at(time_up_early_today) }}"
                          - "{{ now() <= today_at(time_up_late_today) + timedelta(seconds = 5) }}"
                      - and:
                          - "{{ is_schedule_helper_enabled }}"
                          - "{{ time_schedule_helper != [] }}"
                          - "{{ is_state(time_schedule_helper, 'on') }}"
                          - "{{ now() >= today_at([time_up_early, time_up_early_non_workday] | min) - timedelta(seconds = 5) }}"
                          - "{{ now() <= today_at([time_up_late, time_up_late_non_workday] | max) + timedelta(seconds = 5) }}"
                  - or:
                      - or:
                          - "{{ is_brightness_enabled and default_brightness_sensor == [] }}"
                          - "{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor) | float(default=brightness_up) > brightness_up) }}"
                      - or:
                          - "{{ is_sun_elevation_enabled and default_sun_sensor == [] }}"
                          - "{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation | float(default=sun_elevation_up) > sun_elevation_up) }}"

        sequence:
          - delay:
              seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

          - choose:
              ###################################
              # Cover should be shaded
              ###################################
              - alias: "Shading detected. Move to shading position"
                conditions:
                  - "{{ is_cover_shaded }}"
                  - "{{ is_status_helper_enabled }}"
                sequence:
                  - service: input_text.set_value # Set shading to true, but do not overwrite shading time
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - alias: "Moving the cover to shading position"
                              service: cover.set_cover_position
                              data:
                                position: !input shading_position
                              target:
                                entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input shading_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_shading_start_action

            ###################################
            # Cover should be opened
            ###################################
            default:
              - alias: "Normal opening of the cover"
                if:
                  - "{{ is_status_helper_enabled }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - if:
                  - "{{ not prevent_default_cover_actions}}"
                then:
                  - repeat:
                      for_each: "{{ blind_entities|list }}"
                      sequence:
                        - if:
                            - "{{ open_position == 100 }}"
                          then:
                            - alias: "Moving the cover to open position"
                              service: cover.open_cover
                              data: {}
                              target:
                                entity_id: "{{ repeat.item }}"
                          else:
                            - alias: "Moving the cover to open position"
                              service: cover.set_cover_position
                              data:
                                position: !input open_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - if:
                            - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                          then:
                            - alias: "Tilt Delay"
                              delay:
                                seconds: !input tilt_delay
                            - alias: "Moving the cover to tilt position"
                              service: cover.set_cover_tilt_position
                              data:
                                tilt_position: !input open_tilt_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - delay:
                            seconds: "{{ (range(1, 3)|random|int) }}"

              - choose: []
                default: !input auto_up_action

          - stop: "Stop automation: OPEN"

      ############################################################
      # ANCHOR: CLOSE
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Close, Lockout, Ventilation
      ############################################################

      - alias: "Check for closing cover"
        conditions:
          - "{{ is_down_enabled }}"
          - condition: !input auto_down_condition
          - condition: trigger
            id:
              - "t_bc_1"
              - "t_bc_2"
              - "t_bc_3"
              - "t_bc_4"
              - "t_bc_5"
              - "t_bc_6" # Resident sensor
          - "{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, ['false', 'off']) }}"
          - "{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force, ['false', 'off']) }}"
          - or: # Check the current positions
              - "{{ is_status_helper_enabled and not is_cover_closed }}"
              - "{{ in_open_position }}"
          - or: # Ignore check
              - "{{ not is_status_helper_enabled }}"
              - "{{ is_status_helper_enabled and not is_cover_manual }}"
              - "{{ is_status_helper_enabled and ignore_closing_after_manual }}"
              - "{{ is_status_helper_enabled and is_cover_manual and not ignore_closing_after_manual }}"
          - or: # Only once a day?
              - "{{ not is_status_helper_enabled }}"
              - "{{ not prevent_closing_multiple_times }}"
              - "{{ is_status_helper_enabled and prevent_closing_multiple_times and (is_cover_closed_ts < today_at(time_down_early_today) | as_timestamp) }}"
          - or:
              - and: # Control via times disabled
                  - "{{ is_time_control_disabled }}"
              - and: # Closing - Down late reached
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_down_late_today) }}"
              - and: # Closing - Scheduler changes to off
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  - "{{ is_state(time_schedule_helper, 'off') }}"
                  - condition: trigger
                    id: "t_bc_3"
              - and: # Closing - Down early reached and brightness/sun below minimum
                  - or:
                      - and: # Control via times disabled
                          - "{{ is_time_control_disabled }}"
                      - and:
                          - "{{ is_time_field_enabled }}"
                          - "{{ now() >= today_at(time_down_early_today) }}"
                          - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
                      - and:
                          - "{{ is_schedule_helper_enabled }}"
                          - "{{ time_schedule_helper != [] }}"
                          - "{{ is_state(time_schedule_helper, 'on') }}"
                          - "{{ now() >= today_at([time_down_early, time_down_early_non_workday] | min) - timedelta(seconds = 5) }}"
                          - "{{ now() <= today_at([time_down_late, time_down_late_non_workday] | max) + timedelta(seconds = 5) }}"
                  - or:
                      - or:
                          - "{{ is_brightness_enabled and default_brightness_sensor == [] }}"
                          - "{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor) | float(default=brightness_down) < brightness_down) }}"
                      - or:
                          - "{{ is_sun_elevation_enabled and default_sun_sensor == [] }}"
                          - "{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation | float(default=sun_elevation_down) < sun_elevation_down) }}"
              - and: # Closing - due to resident goes sleeping
                  - condition: trigger
                    id: t_bc_6
                  - "{{ resident_sensor != [] }}"
                  - "{{ is_state(resident_sensor, ['true', 'on']) }}"
                  - "{{ not prevent_closing_by_resident }}"

        sequence:
          - choose:
              ###########################################
              # Consider lockout protection when closing
              ###########################################
              - alias: "Consider lockout protection when closing"
                conditions:
                  - "{{ is_lockout_protection_enabled }}"
                  - "{{ contact_sensor_lockout != [] }}"
                  - "{{ is_state(contact_sensor_lockout, ['true', 'on']) }}"
                  - "{{ is_status_helper_enabled }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              ###################################################
              # Move to ventilation position instead of closing
              ###################################################
              - alias: "Move to ventilation position"
                conditions:
                  - "{{ is_ventilation_enabled }}"
                  - "{{ contact_sensor != [] }}"
                  - "{{ is_state(contact_sensor, ['true', 'on']) }}"
                  - "{{ is_status_helper_enabled }}"
                  # The following lines make no sense here, as we are in the closing process.
                  # And there the roller blind will almost always be fully open.
                  # - or:
                  #     - "{{ (current_position | int(default=101) < ventilate_position) }}"
                  #     - "{{ ventilation_if_lower_enabled and (current_position | int(default=101) >= ventilate_position) }}"
                sequence:
                  - delay:
                      seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'ventilate':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - alias: "Moving the cover to ventilate position"
                              service: cover.set_cover_position
                              data:
                                position: !input ventilate_position
                              target:
                                entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input ventilate_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_ventilate_action

              ###################################
              # Cover is already (almost) closed
              ###################################

              - alias: "Only status change if cover is already 'near' the close position" # No driving here!
                conditions:
                  - or:
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ is_status_helper_enabled }}"
                          - "{{ prevent_lowering_when_closing_if_shaded }}"
                          - "{{ is_cover_shaded }}"
                          - "{{ close_position > shading_position }}"
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ prevent_lowering_when_closing_if_shaded }}"
                          - "{{ in_shading_position }}" # Always, no further checks for 'is_status_helper_enabled'
                          - "{{ close_position > shading_position }}"
                      - and: # Stop if close-position is higher than the current position
                          - "{{ prevent_higher_position_closing }}"
                          - "{{ (current_position | int(default=101) <= close_position) }}"
                sequence:
                  - if:
                      - "{{ is_status_helper_enabled }}"
                    then:
                      - service: input_text.set_value
                        data:
                          entity_id: !input cover_status_helper # Manual not set here! Keep old value
                          value: |
                            {% set dict_var = states(cover_status_helper) | from_json %}
                            {% set dict_new = dict(dict_var, **{
                              'open':{'a':false,'t':dict_var.open.t},
                              'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                              'ventilate':{'a':false,'t':dict_var.ventilate.t},
                              'shading':{'a':false,'t':dict_var.shading.t},
                              'locked':{'a':false,'t':dict_var.locked.t},
                              'p':current_position,
                              'v':4,
                              't':as_timestamp(now()) | round(0)
                              })
                            %}
                            {{ dict_new | to_json }}

            ###################################
            # Normal closing of the cover
            ###################################
            default:
              - alias: "Normal closing of the cover"
                delay:
                  seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

              - if:
                  - "{{ is_status_helper_enabled }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - if:
                  - "{{ not prevent_default_cover_actions}}"
                then:
                  - repeat:
                      for_each: "{{ blind_entities|list }}"
                      sequence:
                        - if:
                            - "{{ close_position == 0 }}"
                          then:
                            - alias: "Moving the cover to close position"
                              service: cover.close_cover
                              data: {}
                              target:
                                entity_id: "{{ repeat.item }}"
                          else:
                            - alias: "Moving the cover to close position"
                              service: cover.set_cover_position
                              data:
                                position: !input close_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - if:
                            - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                          then:
                            - alias: "Tilt Delay"
                              delay:
                                seconds: !input tilt_delay
                            - alias: "Moving the cover to tilt position"
                              service: cover.set_cover_tilt_position
                              data:
                                tilt_position: !input close_tilt_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - delay:
                            seconds: "{{ (range(1, 3)|random|int) }}"

              - choose: []
                default: !input auto_down_action

          - stop: "Stop automation: CLOSE"

      ############################################################
      # ANCHOR: SHADING START
      #   Source: Open (all gt shading_position)
      #   Target: Shading, Lockout
      ############################################################

      - alias: "Check for shading start"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_shading_start_condition
          - condition: trigger
            id:
              - "t_si_1"
              - "t_bo_1" # time_up_early
              - "t_bo_3" # schedule helper state change
          - "{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, ['false', 'off']) }}"
          - "{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force, ['false', 'off']) }}"
          - "{{ current_sun_azimuth > shading_azimuth_start and current_sun_azimuth < shading_azimuth_end }}"
          - "{{ current_sun_elevation > shading_elevation_min and current_sun_elevation < shading_elevation_max }}"
          - or: # Check the current positions
              - "{{ not is_cover_shaded }}"
              - "{{ not (is_cover_ventilated or is_cover_locked) }}"
          - or: # Ignore check
              - "{{ not is_cover_manual }}"
              - "{{ ignore_shading_after_manual }}"
              - "{{ is_cover_manual and not ignore_shading_after_manual }}"
          - or: # Only once a day?
              - "{{ not prevent_shading_multiple_times }}"
              - "{{ prevent_shading_multiple_times and (now().day != is_cover_shaded_ts|timestamp_custom('%-d')|int) }}"
          # Moved to the sequence
          # The shading must also be calculated outside the times so that this can be taken into account when opening the roller blind.
          #
          # - or:
          #     - and:
          #         - "{{ is_time_control_disabled }}"
          #     - and:
          #         - "{{ is_time_field_enabled }}"
          #         - "{{ now() >= today_at(time_up_early_today) }}"
          #         - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
          #     - and:
          #         - "{{ is_schedule_helper_enabled }}"
          #         - "{{ time_schedule_helper != [] }}"
          #         - "{{ is_state(time_schedule_helper, 'on') }}"
          - or:
              - "{{ shading_temperatur_sensor1 == [] }}"
              - "{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > shading_min_temperatur1 }}"
          - or:
              - "{{ shading_temperatur_sensor2 == [] }}"
              - "{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > shading_min_temperatur2 }}"
          - or:
              - "{{ shading_brightness_sensor == [] }}"
              - "{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > shading_sun_brightness_start }}"
          - or:
              - "{{ prevent_forecast_service }}"
              - "{{ shading_forecast_sensor == [] }}"
              - "{{ shading_forecast_temp == [] }}"
              - "{{ (not prevent_forecast_service) and weather_forecast[shading_forecast_sensor].forecast[0].temperature | float(default=shading_forecast_temp) > shading_forecast_temp }}"
              - "{{ (shading_temperatur_sensor2 != [] ) and (states(shading_temperatur_sensor2) | int(default=shading_forecast_temp) > shading_forecast_temp) }}" # Continue even if the actual temperature is higher than the forecast value. Occasionally the forecast is wrong.
          - or:
              - "{{ prevent_forecast_service }}"
              - "{{ shading_forecast_sensor == [] }}"
              - "{{ shading_weather_conditions == [] }}"
              - "{{ (not prevent_forecast_service) and weather_forecast[shading_forecast_sensor].forecast[0].condition in shading_weather_conditions }}"
          - or:
              - "{{ resident_sensor == [] }}"
              - "{{ is_state(resident_sensor, ['false', 'off']) }}"

        sequence:
          - choose:
              ##################################################
              # Consider lockout protection when shading starts
              ##################################################
              - alias: "Consider lockout protection when shading starts"
                conditions:
                  - "{{ is_lockout_protection_enabled }}"
                  - "{{ contact_sensor_lockout != [] }}"
                  - "{{ is_state(contact_sensor_lockout, ['true', 'on']) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'locked':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              ###################################
              # Start Shading
              ###################################
              - alias: "Start Shading"
                conditions:
                  - "{{ current_position | int(default=101) > shading_position }}"
                  - or: # Here the shading is executed during the day and therefore the time comparison must be made here.
                      - and:
                          - "{{ is_time_control_disabled }}"
                      - and:
                          - "{{ is_time_field_enabled }}"
                          - "{{ now() >= today_at(time_up_early_today) }}"
                          - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
                      - and:
                          - "{{ is_schedule_helper_enabled }}"
                          - "{{ time_schedule_helper != [] }}"
                          - "{{ is_state(time_schedule_helper, 'on') }}"
                sequence:
                  - delay:
                      seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - alias: "Moving the cover to shading position"
                              service: cover.set_cover_position
                              data:
                                position: !input shading_position
                              target:
                                entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input shading_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_shading_start_action

              ####################################
              # Save shading state for the future
              ####################################
              - alias: "Save shading state for the future"
                conditions:
                  - "{{ is_cover_closed }}" # At this point, the times for shading are not taken into account so that the correct value is available when the roller blind is opened.
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

          - stop: "Stop automation: SHADING START"

      ############################################################
      # ANCHOR: SHADING END
      #   Source: Shading
      #   Target: Open (not any longer: Ventilation, Lockout)
      ############################################################

      - alias: "Check for shading end" # TODO: No forecast sensor trigger atm
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_shading_end_condition
          - condition: trigger
            id: "t_so_1"
          - "{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force, ['false', 'off']) }}"
          - or:
              - and:
                  - "{{ is_time_control_disabled }}"
              - and:
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_up_early_today) }}"
                  - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
              - and:
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  - "{{ is_state(time_schedule_helper, 'on') }}"
          - or: # Ignore check
              - "{{ not is_cover_manual }}"
              - "{{ ignore_shading_after_manual }}"
              - "{{ is_cover_manual and not ignore_shading_after_manual }}"
          - or:
              - "{{ is_cover_shaded }}"
              - "{{ in_shading_position }}" # Be careful if the tolerance value is too high!
          - or: # Optional: Continue if cover is not already closed
              - "{{ not prevent_shading_end_if_closed }}"
              - "{{ prevent_shading_end_if_closed and not in_close_position}}"

        sequence:
          # It makes no sense to move to the ventilation position during the day if more air can flow in when the blind is open.
          #
          # - choose:
          #     ###################################
          #     # Ventilation after shading ends
          #     ###################################
          #     - alias: "Ventilation after shading ends"
          #       conditions:
          #         - "{{ is_ventilation_enabled }}"
          #         - "{{ contact_sensor != [] }}"
          #         - "{{ is_state(contact_sensor, ['true', 'on']) }}"
          #         - or:
          #             - "{{ (current_position | int(default=101) < ventilate_position) }}"
          #             - "{{ ventilation_if_lower_enabled and (current_position | int(default=101) >= ventilate_position) }}"
          #         - or: # The cover is not allowed to be lowered when the lockout protection is enabled
          #             - "{{ not is_lockout_protection_enabled }}"
          #             - "{{ contact_sensor_lockout == [] }}"
          #             - "{{ is_state(contact_sensor_lockout, ['false', 'off']) }}"
          #       sequence:
          #         ################################################
          #         # Consider lockout protection when shading ends
          #         ################################################
          #         - alias: "Consider lockout protection when shading ends" # Only required in this branch. So no separate choose-condition.
          #           if:
          #             - "{{ is_lockout_protection_enabled }}"
          #             - "{{ contact_sensor_lockout != [] }}"
          #             - "{{ is_state(contact_sensor_lockout, ['true', 'on']) }}"
          #           then:
          #             - service: input_text.set_value
          #               data:
          #                 entity_id: !input cover_status_helper
          #                 value: |
          #                   {% set dict_var = states(cover_status_helper) | from_json %}
          #                   {% set dict_new = dict(dict_var, **{
          #                     'open':{'a':true,'t':as_timestamp(now()) | round(0)},
          #                     'close':{'a':false,'t':dict_var.close.t},
          #                     'ventilate':{'a':false,'t':dict_var.ventilate.t},
          #                     'shading':{'a':false,'t':dict_var.shading.t},
          #                     'locked':{'a':true,'t':as_timestamp(now()) | round(0)},
          #                     'manual':{'a':false,'t':dict_var.manual.t},
          #                     'p':current_position,
          #                     'v':4,
          #                     't':as_timestamp(now()) | round(0)
          #                     })
          #                   %}
          #                   {{ dict_new | to_json }}

          #             - stop: "Stop automation: Lockout protection when shading ends"

          #         - service: input_text.set_value
          #           data:
          #             entity_id: !input cover_status_helper
          #             value: |
          #               {% set dict_var = states(cover_status_helper) | from_json %}
          #               {% set dict_new = dict(dict_var, **{
          #                 'open':{'a':true,'t':as_timestamp(now()) | round(0)},
          #                 'close':{'a':false,'t':dict_var.close.t},
          #                 'ventilate':{'a':true,'t':as_timestamp(now()) | round(0)},
          #                 'shading':{'a':false,'t':dict_var.shading.t},
          #                 'locked':{'a':false,'t':dict_var.locked.t},
          #                 'manual':{'a':false,'t':dict_var.manual.t},
          #                 'p':current_position,
          #                 'v':4,
          #                 't':as_timestamp(now()) | round(0)
          #                 })
          #               %}
          #               {{ dict_new | to_json }}

          #         - if:
          #             - "{{ not prevent_default_cover_actions}}"
          #           then:
          #             - repeat:
          #                 for_each: "{{ blind_entities|list }}"
          #                 sequence:
          #                   - alias: "Moving the cover to ventilate position"
          #                     service: cover.set_cover_position
          #                     data:
          #                       position: !input ventilate_position
          #                     target:
          #                       entity_id: "{{ repeat.item }}"
          #                   - if:
          #                       - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
          #                     then:
          #                       - alias: "Tilt Delay"
          #                         delay:
          #                           seconds: !input tilt_delay
          #                       - alias: "Moving the cover to tilt position"
          #                         service: cover.set_cover_tilt_position
          #                         data:
          #                           tilt_position: !input ventilate_tilt_position
          #                         target:
          #                           entity_id: "{{ repeat.item }}"
          #                   - delay:
          #                       seconds: "{{ (range(1, 3)|random|int) }}"

          #         - choose: []
          #           default: !input auto_ventilate_action

          #   default:
          #
          ###################################
          # Move cover to open position
          ###################################
          - alias: "Move cover to open position"
            service: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: |
                {% set dict_var = states(cover_status_helper) | from_json %}
                {% set dict_new = dict(dict_var, **{
                  'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                  'close':{'a':false,'t':dict_var.close.t},
                  'ventilate':{'a':false,'t':dict_var.ventilate.t},
                  'shading':{'a':false,'t':dict_var.shading.t},
                  'locked':{'a':false,'t':dict_var.locked.t},
                  'manual':{'a':false,'t':dict_var.manual.t},
                  'p':current_position,
                  'v':4,
                  't':as_timestamp(now()) | round(0)
                  })
                %}
                {{ dict_new | to_json }}

          - if:
              - "{{ not prevent_default_cover_actions}}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - if:
                        - "{{ open_position == 100 }}"
                      then:
                        - alias: "Moving the cover to open position"
                          service: cover.open_cover
                          data: {}
                          target:
                            entity_id: "{{ repeat.item }}"
                      else:
                        - alias: "Moving the cover to open position"
                          service: cover.set_cover_position
                          data:
                            position: !input open_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Tilt Delay"
                          delay:
                            seconds: !input tilt_delay
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input open_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - delay:
                        seconds: "{{ (range(1, 3)|random|int) }}"

          - choose: []
            default: !input auto_shading_end_action

          - stop: "Stop automation: SHADING END"

      ############################################################
      # ANCHOR: CONTACT OPEN
      #   Source: Shading, Close
      #   Target: Ventilation
      ############################################################

      - alias: "Contact sensor opened"
        conditions:
          - "{{ is_ventilation_enabled }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_ventilate_condition
          - condition: trigger
            id: "t_ct_vent_open"
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"
          - "{{ contact_sensor != [] }}"
          - "{{ is_state(contact_sensor, ['true', 'on']) }}"
          - "{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force, ['false', 'off']) }}"
          - or:
              - "{{ (current_position | int(default=101) < ventilate_position) }}"
              - "{{ ventilation_if_lower_enabled and (current_position | int(default=101) >= ventilate_position) }}"
          - or:
              - or: # Source: Close
                  - "{{ is_cover_closed }}"
                  - "{{ in_close_position }}" # Always and independently of the helper
              - or: # Source: Shading
                  - "{{ is_cover_shaded }}"
                  - "{{ in_shading_position }}" # Always and independently of the helper
        sequence:
          - choose:
              #################################################
              # Consider lockout protection when contact opens
              #################################################
              - alias: "Consider lockout protection when contact opens" # TODO: Do I really need this here?
                conditions:
                  - "{{ is_lockout_protection_enabled }}"
                  - "{{ contact_sensor_lockout != [] }}"
                  - "{{ is_state(contact_sensor_lockout, ['true', 'on']) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper # TODO Do not set ventilate to true here, too?
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'locked':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

            ########################################################
            # Move to ventilate position because contact was opened
            ########################################################
            default:
              - service: input_text.set_value
                data:
                  entity_id: !input cover_status_helper
                  value: |
                    {% set dict_var = states(cover_status_helper) | from_json %}
                    {% set dict_new = dict(dict_var, **{
                      'ventilate':{'a':true,'t':as_timestamp(now()) | round(0)},
                      'p':current_position,
                      'v':4,
                      't':as_timestamp(now()) | round(0)
                      })
                    %}
                    {{ dict_new | to_json }}

              - if:
                  - "{{ not prevent_default_cover_actions}}"
                then:
                  - repeat:
                      for_each: "{{ blind_entities|list }}"
                      sequence:
                        - alias: "Moving the cover to ventilate position"
                          service: cover.set_cover_position
                          data:
                            position: !input ventilate_position
                          target:
                            entity_id: "{{ repeat.item }}"
                        - if:
                            - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                          then:
                            - alias: "Tilt Delay"
                              delay:
                                seconds: !input tilt_delay
                            - alias: "Moving the cover to tilt position"
                              service: cover.set_cover_tilt_position
                              data:
                                tilt_position: !input ventilate_tilt_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - delay:
                            seconds: "{{ (range(1, 3)|random|int) }}"

              - choose: []
                default: !input auto_ventilate_action

          - stop: "Stop automation: CONTACT OPEN"

      ############################################################
      # ANCHOR: CONTACT CLOSED
      #   Source: Ventilation, Lockout
      #   Target: Open, Close, Shading
      ############################################################

      - alias: "Contact sensor closed"
        conditions:
          - "{{ is_down_enabled }}" # Only close if it is allowed
          - "{{ is_status_helper_enabled }}"
          - "{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, ['false', 'off']) }}"
          - "{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force, ['false', 'off']) }}"
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"
          - or:
              - and:
                  - "{{ is_ventilation_enabled }}"
                  - condition: trigger
                    id: "t_ct_vent_close"
                  - "{{ contact_sensor != [] }}"
                  - "{{ is_state(contact_sensor, ['false', 'off']) }}"
                  - or:
                      - "{{ is_cover_ventilated }}" # Status check
                      - "{{ in_ventilate_position }}" # Position check
                  - or: # Ignore check
                      - "{{ not is_cover_manual }}"
                      - "{{ ignore_ventilation_after_manual }}"
                      - "{{ is_cover_manual and not ignore_ventilation_after_manual }}"
              - and:
                  - "{{ is_lockout_protection_enabled and not prevent_close_after_lockout }}"
                  - condition: trigger
                    id: "t_ct_lock_close"
                  - "{{ contact_sensor_lockout != [] }}"
                  - "{{ is_state(contact_sensor_lockout, ['false', 'off']) }}"
                  - "{{ is_cover_locked }}" # Status check

        sequence:
          - if:
              - "{{ ventilation_delay_enabled }}"
            then:
              - delay:
                  seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

          - choose:
              ###################################################
              # Consider lockout protection when contact closes
              ###################################################
              - alias: "Consider lockout protection when contact closes"
                conditions:
                  - "{{ is_lockout_protection_enabled }}"
                  - "{{ contact_sensor_lockout != [] }}"
                  - "{{ is_state(contact_sensor_lockout, ['true', 'on']) }}"
                  - "{{ not is_cover_open }}" # Not required if the cover is opened anyway
                  - "{{ is_cover_closed }}"
                  - "{{ is_cover_shaded }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'ventilate':{'a':false,'t':as_timestamp(now()) | round(0)},
                          'locked':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              ########################################
              # Contact sensor closed. Open the cover
              ########################################
              - alias: "Contact sensor closed. Open the cover"
                conditions:
                  - "{{ is_cover_open }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - if:
                                - "{{ open_position == 100 }}"
                              then:
                                - alias: "Moving the cover to open position"
                                  service: cover.open_cover
                                  data: {}
                                  target:
                                    entity_id: "{{ repeat.item }}"
                              else:
                                - alias: "Moving the cover to open position"
                                  service: cover.set_cover_position
                                  data:
                                    position: !input open_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input open_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_up_action

              ########################################
              # Contact sensor closed. Close the cover
              ########################################
              - alias: "Contact sensor closed. Close the cover"
                conditions:
                  - "{{ is_cover_closed }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - if:
                                - "{{ close_position == 0 }}"
                              then:
                                - alias: "Moving the cover to close position"
                                  service: cover.close_cover
                                  data: {}
                                  target:
                                    entity_id: "{{ repeat.item }}"
                              else:
                                - alias: "Moving the cover to close position"
                                  service: cover.set_cover_position
                                  data:
                                    position: !input close_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input close_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_down_action

              ##########################################
              # Contact sensor closed. Activate shading
              ##########################################
              - alias: "Contact sensor closed. Activate shading"
                conditions:
                  - "{{ is_cover_shaded }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

                  - if:
                      - "{{ not prevent_default_cover_actions}}"
                    then:
                      - repeat:
                          for_each: "{{ blind_entities|list }}"
                          sequence:
                            - alias: "Moving the cover to shading position"
                              service: cover.set_cover_position
                              data:
                                position: !input shading_position
                              target:
                                entity_id: "{{ repeat.item }}"
                            - if:
                                - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                              then:
                                - alias: "Tilt Delay"
                                  delay:
                                    seconds: !input tilt_delay
                                - alias: "Moving the cover to tilt position"
                                  service: cover.set_cover_tilt_position
                                  data:
                                    tilt_position: !input shading_tilt_position
                                  target:
                                    entity_id: "{{ repeat.item }}"
                            - delay:
                                seconds: "{{ (range(1, 3)|random|int) }}"

                  - choose: []
                    default: !input auto_shading_start_action

          - stop: "Stop automation: CONTACT CLOSED"

      ############################################################
      # ANCHOR: FORCE OPEN
      ############################################################

      - alias: "Forced opening of the cover"
        conditions:
          - condition: trigger
            id: "t_bo_force"
          - "{{ auto_up_force != [] and is_state(auto_up_force, ['true', 'on']) }}"
        sequence:
          - if:
              - "{{ is_status_helper_enabled }}"
            then:
              - service: input_text.set_value
                data:
                  entity_id: !input cover_status_helper
                  value: |
                    {% set dict_var = states(cover_status_helper) | from_json %}
                    {% set dict_new = dict(dict_var, **{
                      'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                      'close':{'a':false,'t':dict_var.close.t},
                      'ventilate':{'a':false,'t':dict_var.ventilate.t},
                      'shading':{'a':false,'t':dict_var.shading.t},
                      'locked':{'a':false,'t':dict_var.locked.t},
                      'manual':{'a':false,'t':dict_var.manual.t},
                      'p':current_position,
                      'v':4,
                      't':as_timestamp(now()) | round(0)
                      })
                    %}
                    {{ dict_new | to_json }}

          - if:
              - "{{ not prevent_default_cover_actions}}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - if:
                        - "{{ open_position == 100 }}"
                      then:
                        - alias: "Moving the cover to open position"
                          service: cover.open_cover
                          data: {}
                          target:
                            entity_id: "{{ repeat.item }}"
                      else:
                        - alias: "Moving the cover to open position"
                          service: cover.set_cover_position
                          data:
                            position: !input open_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Tilt Delay"
                          delay:
                            seconds: !input tilt_delay
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input open_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - delay:
                        seconds: "{{ (range(1, 3)|random|int) }}"

          - choose: []
            default: !input auto_up_action

          - stop: "Stop automation: FORCE OPEN"

      ############################################################
      # ANCHOR: FORCE CLOSE
      ############################################################

      - alias: "Forced closing of the cover"
        conditions:
          - condition: trigger
            id: "t_bc_force"
          - "{{ auto_down_force != [] and is_state(auto_down_force, ['true', 'on']) }}"
        sequence:
          - if:
              - "{{ is_status_helper_enabled }}"
            then:
              - service: input_text.set_value
                data:
                  entity_id: !input cover_status_helper
                  value: |
                    {% set dict_var = states(cover_status_helper) | from_json %}
                    {% set dict_new = dict(dict_var, **{
                      'open':{'a':false,'t':dict_var.open.t},
                      'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                      'ventilate':{'a':false,'t':dict_var.ventilate.t},
                      'shading':{'a':false,'t':dict_var.shading.t},
                      'locked':{'a':false,'t':dict_var.locked.t},
                      'manual':{'a':false,'t':dict_var.manual.t},
                      'p':current_position,
                      'v':4,
                      't':as_timestamp(now()) | round(0)
                      })
                    %}
                    {{ dict_new | to_json }}

          - if:
              - "{{ not prevent_default_cover_actions}}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - if:
                        - "{{ close_position == 0 }}"
                      then:
                        - alias: "Moving the cover to close position"
                          service: cover.close_cover
                          data: {}
                          target:
                            entity_id: "{{ repeat.item }}"
                      else:
                        - alias: "Moving the cover to close position"
                          service: cover.set_cover_position
                          data:
                            position: !input close_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Tilt Delay"
                          delay:
                            seconds: !input tilt_delay
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input close_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - delay:
                        seconds: "{{ (range(1, 3)|random|int) }}"

          - choose: []
            default: !input auto_down_action

          - stop: "Stop automation: FORCE CLOSE"

      ############################################################
      # ANCHOR: FORCE VENTILATION
      ############################################################

      - alias: "Forced ventilation of the cover"
        conditions:
          - condition: trigger
            id: "t_ve_force"
          - "{{ auto_ventilate_force != [] and is_state(auto_ventilate_force, ['true', 'on']) }}"
          - "{{ is_status_helper_enabled }}"
        sequence:
          - service: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: |
                {% set dict_var = states(cover_status_helper) | from_json %}
                {% set dict_new = dict(dict_var, **{
                  'open':{'a':false,'t':dict_var.open.t},
                  'close':{'a':false,'t':dict_var.close.t},
                  'ventilate':{'a':true,'t':as_timestamp(now()) | round(0)},
                  'shading':{'a':false,'t':dict_var.shading.t},
                  'locked':{'a':false,'t':dict_var.locked.t},
                  'manual':{'a':false,'t':dict_var.manual.t},
                  'p':current_position,
                  'v':4,
                  't':as_timestamp(now()) | round(0)
                  })
                %}
                {{ dict_new | to_json }}

          - if:
              - "{{ not prevent_default_cover_actions}}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - alias: "Moving the cover to ventilate position"
                      service: cover.set_cover_position
                      data:
                        position: !input ventilate_position
                      target:
                        entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Tilt Delay"
                          delay:
                            seconds: !input tilt_delay
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input ventilate_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - delay:
                        seconds: "{{ (range(1, 3)|random|int) }}"

          - choose: []
            default: !input auto_ventilate_action

          - stop: "Stop automation: FORCE VENTILATION"

      ############################################################
      # ANCHOR: FORCE SHADING START
      ############################################################

      - alias: "Forced activating of the sun shading"
        conditions:
          - condition: trigger
            id: "t_si_force"
          - "{{ auto_shading_start_force != [] and is_state(auto_shading_start_force, ['true', 'on']) }}"
          - "{{ is_status_helper_enabled }}"
        sequence:
          - service: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: |
                {% set dict_var = states(cover_status_helper) | from_json %}
                {% set dict_new = dict(dict_var, **{
                  'open':{'a':false,'t':dict_var.open.t},
                  'close':{'a':false,'t':dict_var.close.t},
                  'ventilate':{'a':false,'t':dict_var.ventilate.t},
                  'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                  'locked':{'a':false,'t':dict_var.locked.t},
                  'manual':{'a':false,'t':dict_var.manual.t},
                  'p':current_position,
                  'v':4,
                  't':as_timestamp(now()) | round(0)
                  })
                %}
                {{ dict_new | to_json }}

          - if:
              - "{{ not prevent_default_cover_actions}}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - alias: "Moving the cover to shading position"
                      service: cover.set_cover_position
                      data:
                        position: !input shading_position
                      target:
                        entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Tilt Delay"
                          delay:
                            seconds: !input tilt_delay
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input shading_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - delay:
                        seconds: "{{ (range(1, 3)|random|int) }}"

          - choose: []
            default: !input auto_shading_start_action

          - stop: "Stop automation: FORCE SHADING START"

      ############################################################
      # ANCHOR: MANUAL
      ############################################################

      - alias: "Checking for manual position changes"
        conditions:
          - "{{ 'cover_helper_enabled' in cover_status_options }}" # Do not use 'is_status_helper_enabled' (with the embedded regex here), because it could be set after variable declaration
          - "{{ cover_status_helper != [] }}"
          - "{{ as_timestamp(now()) > cover_status_time + drive_time + 60 }}" # Drive time + trigger waiting time
          - condition: trigger
            id: "t_ma_1"
          - "{{ is_number(trigger.to_state.attributes.current_position) and is_number(trigger.from_state.attributes.current_position) }}" # Avoid status change from -unavailable- (common with Homematic)
          - "{{ trigger.to_state.attributes.current_position != trigger.from_state.attributes.current_position }}" # Probably not necessary, otherwise the trigger would not have been activated.
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"

        sequence:
          - choose:
              - conditions: # Manually opened
                  - "{{ is_up_enabled }}"
                  - or:
                      - "{{ in_open_position }}"
                      - "{{ (current_position | int(default=101) > ventilate_position) }}"
                      - "{{ (current_position | int(default=101) >= open_position) }}"
                      - "{{ (current_position | int(default=101) == 100) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually ventilated
                  - "{{ is_ventilation_enabled }}"
                  - "{{ in_ventilate_position }}"
                  - "{{ not in_open_position }}" # If ventilate_position and open_position are too close together, the ventilation-status should not be assigned.
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually shaded
                  - "{{ is_shading_enabled }}"
                  - "{{ in_shading_position }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually closed
                  - "{{ is_down_enabled }}"
                  - "{{ not in_shading_position }}"
                  - or:
                      - "{{ in_close_position }}"
                      - "{{ (current_position | int(default=101) < shading_position) and (current_position | int(default=101) < ventilate_position) }}" # This can cause problems if shadingPos < closedPos in cover status helper
                      - "{{ (current_position | int(default=101) <= close_position) }}"
                      - "{{ (current_position | int(default=101) == 0) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Defined positions can be assigned
                  - not:
                      - "{{ is_up_enabled and in_open_position }}"
                      - "{{ is_down_enabled and in_close_position }}"
                      - "{{ is_ventilation_enabled and in_ventilate_position }}"
                      - "{{ is_shading_enabled and in_shading_position }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = dict(dict_var, **{
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'locked':{'a':false,'t':dict_var.locked.t},
                          'manual':{'a':true,'t':as_timestamp(now()) | round(0)},
                          'p':current_position,
                          'v':4,
                          't':as_timestamp(now()) | round(0)
                          })
                        %}
                        {{ dict_new | to_json }}

    default:
      - if:
          - "{{ check_config }}"
        then:
          # Checking time slots
          - if:
              - "{{ not is_time_control_disabled and (today_at(time_up_early) >= today_at(time_up_late)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_up_early should be earlier than time_up_late - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ not is_time_control_disabled and (today_at(time_up_early_non_workday) >= today_at(time_up_late_non_workday)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_up_early_non_workday should be earlier than time_up_late_non_workday - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ not is_time_control_disabled and (today_at(time_down_early) >= today_at(time_down_late)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_down_early should be earlier than time_down_late - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ not is_time_control_disabled and (today_at(time_down_early_non_workday) >= today_at(time_down_late_non_workday)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_down_early_non_workday should be earlier than time_down_late_non_workday - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking shading
          - if:
              - "{{ shading_azimuth_start >= shading_azimuth_end }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_azimuth_start should be lower than shading_azimuth_end - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ shading_elevation_min >= shading_elevation_max }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_elevation_min should be lower than - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ shading_sun_brightness_start <= shading_sun_brightness_end }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_sun_brightness_start should be higher than shading_sun_brightness_end - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking positions
          - if:
              - "{{ (open_position - position_tolerance) <= (close_position + position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: open_position should be higher than close_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (open_position - position_tolerance) <= (ventilate_position + position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: open_position should be higher than ventilate_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (close_position + position_tolerance) >= (ventilate_position - position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: close_position should be lower than ventilate_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (shading_position - position_tolerance) <= (close_position + position_tolerance)}}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_position should be higher than close_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (shading_position + position_tolerance) >= (open_position - position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_position should be lower than open_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ ( (resident_sensor != [] ) and (not is_state(resident_sensor, ['false', 'off','true', 'on'])) ) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: resident_sensor is only allowed to be on/off/true/false - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking if cover entity has the right attributes
          - if:
              - "{{ state_attr(blind, 'current_position') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: cover is missing attribute current_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking if sun sensor has the right attributes
          - if:
              - "{{ state_attr(default_sun_sensor, 'elevation') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: sun sensor is missing attribute elevation - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ state_attr(default_sun_sensor, 'azimuth') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: sun sensor is missing attribute azimuth - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking if brightness sensor is defined
          - if:
              - or:
                  - "{{ is_brightness_enabled and default_brightness_sensor == [] }}"
                  - "{{ is_brightness_enabled and not is_number(states(default_brightness_sensor)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: brightness sensor not defined or state is not numeric - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          # Checking helper
          - if:
              - "{{ 'cover_helper_enabled' in cover_status_options }}"
              - "{{ state_attr(cover_status_helper, 'max') < 254 }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: Wrong length of the cover status helper - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"

      - stop: "Stopping the automation - DEFAULT"
