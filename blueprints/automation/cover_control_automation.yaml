blueprint:
  name: "Cover Control Automation (CCA)"
  description: |
    # Cover Control Automation (CCA)

    **Version: 2024.02.06-01** / hvorragend

    This is a comprehensive and highly configurable blueprint that can be used for the following basic purposes:
    - Opening and closing the roller shutters (depending on brightness, <ins>sun-elevation</ins> and within time windows)
    - Ventilation feature (Currently for two-way sensors)
    - Resident feature: keep the cover closed if resident is asleep
    - Complete flexibility in almost all parameters (drive delays, waiting times, position tolerance)
    - Each feature can be activated or deactivated as required. Not only through a switch in the blueprint, but also through dynamic conditions outside the automation (see examples in `Details`).
    - Extensive automatic sun shading with many different setting options (see features in `Details`).
    - Added the option to save the current status in a helper. This has the advantage that the roller blind can also be in other positions and the automation can still be executed. And manual interventions are not constantly overridden with every trigger.

    <details>

    *This was originally a fork of Eimeel's blueprint [automatic_blinds_shading.yaml](https://gist.github.com/jmerifjKriwe/bffbc7424dd04f4a31d6a71f7012cd1f) and is largely based on his programming.*
    Note: My blueprint is not compatible with Eimeel's variant. I have used his basis, but the variables are completely different from his design.<br />

    **Condition examples**
    - If, for example, your blinds on the upper floor only close automatically and are not opened via the automation, you can also enable the blinds to be opened during this time by activating a vacation mode boolean.
    - If you have visitors or a party, you may not want the blinds to close. This can be easily configured using a party mode boolean.
    - If, for any reason, you want to pause the activation of shading or the ending of shading, this can be controlled via a shading boolean.
    - If you want to suspend the entire roller blind control for a short time, perhaps because maintenance work or window cleaning is being carried out, this is possible with just one boolean.
    - Are the roller blinds on side doors normally only opened by the automation system and never closed because you don't want to lock yourself out? But on vacation, the blinds should still be closed. This is how the conditions work.

    **Shading features**
    - Sun azimuth
    - Sun elevation
    - Solar irradiation/Light intensity/Illuminance
    - Weather Conditions
    - Two different temperature sensors (compare thresholds for indoor and/or outdoor sensors)
    - Not only the current temperature, but also the temperature forecast can also be taken into account.
    - If multiple criteria (e.g. temperature sensors and/or azimuth and/or elevation) are defined, shading will not occur until <ins>all</ins> criteria are met.

    **Important notes**
    - It is <ins>not</ins> possible to execute this automation manually!
    - If you want to use sun elevation and/or azimuth it's strongly advised to use sun.sun. And please make sure your sun.sun entity is enabled!
    - `time_up_early` should be earlier `than time_up_late`
    - `time_up_early_non_workday` should be earlier than `time_up_late`
    - `time_down_early` should be earlier than `time_down_late`
    - `shading_azimuth_start` should be lower than `shading_azimuth_end`
    - `shading_elevation_min` should be lower than `shading_elevation_max`
    - `shading_sun_brightness_start` should be higher than `shading_sun_brightness_end`
    - `open_position` should be higher than `close_position`
    - `open_position` should be higher than `ventilate_position`
    - `close_position` should be lower than `ventilate_position`
    - `shading_position` should be higher than `close_position`
    - `shading_position` should be lower than `open_position`
    - `resident_sensor` is only allowed to be on/off/true/false
    - cover must have a `current_position` attribute
    - After <ins>manual creation</ins> of the helper in the GUI, it will be filled with standard content on the <ins>first trigger</ins>.
      In rare cases, this may mean that the first trigger does not move the blinds. This may take care of itself with the next trigger later.
      Alternatively, the roller blinds must be moved shortly once so that the automation system knows what the current status is.

    **Changelog**
    2024.01.29-01:
      - Updated hints
      - Fixed one resident condition (thx to Eimeel)
      - Added version number to json (thx to Eimeel)

    2024.01.29-02:
      - Added: Implemented configuration check to perform some basic checks (idea and code by Eimeel)
      - Added: Cover Drive Time
      - A few logic changes

    2024.01.29-03:
      - Added config check for sun attributes
      - Fixed: Wrong trigger condition while closing

    2024.01.29-04/2024.01.29-05:
      - Updated descriptions

    2024.01.30-01/2024.01.30-02:
      - Fixed and extended config check
      - Fixed closing condition. Wrong fix yesterday. Back to the origin. Will check this later.

    2024.02.01-01:
      - Minor Layout changes
      - Removed commented out code
      - Fixed closing-condition
      - Fixed cover status helper initialisation and still make the first cover drive possible

    2024.02.02-01:
      - *BREAKING CHANGE:* Please reconfigure/rename the variables close_position and shading_position in your blueprint config.
        Old: closed_position - New: close_position
        Old: shading_cover_position - New: shading_position
      - Added tilt positions for open, close and ventilation

    2024.02.03-01:
      - Strict separation of the two brightness sensors. The previous problem was that the shading sensor used the same values to open or close the blinds as the normal sensor. Depending on the sensor (different edge, slope, median, filter, etc.), incorrect triggers occur.
        Important: If required, please register both brightness sensors.

    2024.02.03-02:
      - Opening the blinds only until time_down_early. Otherwise, overlaps may occur if the brightness values are not set correctly. Avoid bouncing the blinds.

    2024.02.06-01:
      - Added: Helper length validation
      - Comprehensive JSON changes / Now multidimensional JSON
      - Roller blind movements can now only be executed once a day when the helpers are used.

    [GitHub Source](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml)

    </details>

  # - Todo: Add Antifreeze to examples
  # - Todo: Add RainProtection to examples
  # - Todo: Add WindProtection to exammple
  # - Todo: Add ExternalTrigger
  # - Todo: Allow force open/force close? With forced position?
  # - Todo: Use Calendar or Scheduler?
  # - Checkbox: ignore shading, ventilation, open, close after manual movement?
  # - Checkbox? "{{ cover_status_helper_enabled and cover_status_shading and (close_position < shading_position) }}"

  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: "2023.9.0"
  input:
    blind:
      name: "üè† Cover"
      description: "Which blind or roller shutter should be automated?"
      selector:
        entity:
          filter:
            - domain:
                - cover

    auto_options:
      name: "üëâ Automation options"
      description: >-
        This <ins>basically</ins> determines whether the roller blinds are allowed to open or close.
        This can be extended by further conditions (see below). However, it is important that the options are still activated here.
        Otherwise the conditions will not take effect.


        **Please ensure that the corresponding sensors are also specified.**
        For example, the brightness control only works if a brightness sensor is also specified.
      default:
        [
          auto_up_enabled,
          auto_down_enabled,
          auto_brightness_enabled,
          auto_sun_enabled,
        ]
      selector:
        select:
          options:
            - label: "1 - üîº - Activate automatic cover opening"
              value: "auto_up_enabled"
            - label: "2 - üîª - Activate automatic cover closing"
              value: "auto_down_enabled"
            - label: "3 - üîÖ - Activate control via brightness values"
              value: "auto_brightness_enabled"
            - label: "4 - ‚òÄÔ∏è - Activate control via sun elevation"
              value: "auto_sun_enabled"
            - label: "5 - üí® - Activate ventilation mode"
              value: "auto_ventilate_enabled"
            - label: "6 - üï∂Ô∏è - Activate automatic shading"
              value: "auto_shading_enabled"
          multiple: true
          sort: false
          custom_value: false
          mode: list

    auto_global_condition:
      name: "‚ùì Additional condition for the entire automation"
      description: >-
        This condition allows you to control the execution of the <ins>entire</ins> automation dynamically and outside of the blueprint configuration.
        With this option you could enable a party mode.
        <br /><br />`Optional`
      default: []
      selector:
        condition: {}

    open_position:
      name: "üîº Open Position"
      description: "What position should the cover be moved into when opening?"
      default: 100
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: "%"
    open_tilt_position:
      name: "üîº Open Tilt Position"
      description: "To which tilt position should the cover be moved when opening?"
      default: 50
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
    time_up_early:
      name: "üîº Time For Drive Up - Early On Workdays"
      description: >-
        The earliest time at which the cover may be opened. The cover will be opened if <ins>AFTER</ins> this time the defined brightness
        or sun-elevation value is high enough. (**NOTE**: If a resident is defined, he must also be awake).
      default: "06:00:00"
      selector:
        time: {}
    time_up_early_non_workday:
      name: "üîº Time For Drive Up - Early On Non-Workdays"
      description: "As directly above, but for non-workdays."
      default: "07:00:00"
      selector:
        time: {}
    time_up_late:
      name: "üîº Time For Drive Up - Late"
      description: >-
        The latest time at which the cover should be opened.
        If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be opened.
        (**NOTE**: If a resident is defined and he is still asleep, the cover will <ins>NOT</ins> be opened.
        It will only be opened when the resident has woken up).
      default: "08:00:00"
      selector:
        time: {}
    auto_up_condition:
      name: "üîº Additional Condition For Opening The Cover"
      description: >-
        This condition can be used to dynamically control the <ins>opening</ins> of the cover.
        You can use this, for example, if the covers normally don't open, but you really want to do it on vacation.
        <br /><br />`Optional`
      default: []
      selector:
        condition: {}

    close_position:
      name: "üîª Close Position"
      description: "What position should the cover be moved into when closing?"
      default: 0
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: "%"
    close_tilt_position:
      name: "üîª Close Tilt Position"
      description: "To which tilt position should the cover be moved when closing?"
      default: 50
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
    time_down_early:
      name: "üîª Time For Drive Down - Early"
      description: >-
        The earliest time at which the cover may be closed.
        The cover will be closed if <ins>AFTER</ins> this time the defined brightness or sun-elevation value is low enough.
      default: "16:00:00"
      selector:
        time: {}
    time_down_late:
      name: "üîª Time For Drive Down - Late"
      description: >-
        The latest time at which the cover should be closed.
        If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time,
        the cover will still be closed.
      default: "22:00:00"
      selector:
        time: {}
    auto_down_condition:
      name: "üîª Additional Condition For Closing The Cover"
      description: >-
        This condition can be used to dynamically control the <ins>closing</ins> of the cover.
        You can use this, for example, at Christmas time or if you want the covers to behave differently while on vacation.
        <br /><br />`Optional`
      default: []
      selector:
        condition: {}

    default_brightness_sensor:
      name: "üîÖ Default Brightness Sensor"
      description: >-
        This default brightness sensor can be defined here, which is used for daily up and down.
        <br /><br />`Optional`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - sensor
    brightness_time_duration:
      name: "üîÖ Brightness Time Duration"
      description: "Defines the time to given brightness sensor must be stay above/below the thresholds."
      default: 30
      selector:
        number:
          min: 0.0
          max: 600.0
          mode: slider
          step: 1.0
          unit_of_measurement: seconds

    brightness_up:
      name: "üîÖüîº Brightness Value For Opening The Cover"
      description: "At what brightness value should the cover be opened?"
      default: 0
      selector:
        number:
          min: 0.0
          max: 1000.0
          unit_of_measurement: lx
          step: 10.0
    brightness_down:
      name: "üîÖüîª Brightness Value For Closing The Cover"
      description: "At what brightness value should the cover be closed? Must be lower then the brightness up value."
      default: 0
      selector:
        number:
          min: 0.0
          max: 1000.0
          unit_of_measurement: lx
          step: 10.0

    default_sun_sensor:
      name: "‚òÄÔ∏è Sun Sensor"
      description: >-
        Which sensors provides attributes with current azimuth and elevation of sun.
        I strongly suggest to use sun.sun. Please make sure that the integration is activated and provides the attributes.
        <strong>Important: If you want to use automatic shading, the sensor must also be specified here.
        Regardless of whether the basic sun control is used.</strong>
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: "sun.sun"
      selector:
        entity:
          filter:
            - domain:
                - sun
    sun_time_duration:
      name: "‚òÄÔ∏è Sun Time Duration"
      description: "Defines the time to given sun sensor must be stay above/below the thresholds."
      default: 30
      selector:
        number:
          min: 0.0
          max: 600.0
          mode: slider
          step: 1.0
          unit_of_measurement: seconds
    sun_elevation_up:
      name: "‚òÄÔ∏èüîº Sun Elevation Value For Opening The Cover"
      description: "The cover will be <ins>opened</ins> if the sun elevation is over this value"
      default: 0
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: ¬∞
          step: 0.1
          mode: slider
    sun_elevation_down:
      name: "‚òÄÔ∏èüîª Sun Elevation Value For Closing The Cover"
      description: "The cover will be <ins>closed</ins> if the sun elevation is under this value"
      default: 0
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: ¬∞
          step: 0.1
          mode: slider

    workday_sensor:
      name: "üíº Sensor For Workday/Non-Workday"
      description: >-
        It may be desired to open a cover at a different time on work days than on non-work days.
        The corresponding binary sensor can be defined here. If not set, the cover will open every time at time_up_early.
        <br /><br />`Optional`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
    resident_sensor:
      name: "üõå Resident Mode"
      description: >-
        Overwrite Mode For Opening and Unplannend Closing: This switch can be used to override the automatic opening of the cover.
        If this sensor (input_boolean or binary_sensor) is set to ON, the cover will not open automatically.
        <br />
        This can be used e.g. to define a resident for the room. In this case, the cover only opens when the resident is no longer asleep.
        <br />
        For this it is necessary to use a boolean sensor that returns TRUE/ON for sleeping and FALSE/OFF for non-sleeping.
        <br />
        The cover will also close (without checking the defined times) if this sensor switches to TRUE/ON (because the resident is sleeping).
        <br /><br />`Optional`
      default: []
      selector:
        entity:
          domain:
            - input_boolean
            - binary_sensor
    contact_cover_place:
      name: "üö™ Cover Belongs To"
      description: >-
        Does the cover belong to a window or a door?
        In the case of a door, an attempt is made to prevent the cover from being lowered
        when the door is open in order to prevent it from being locked out. (without guarantee!)
        <br /><br />`Optional`
      default: "window"
      selector:
        select:
          options:
            - label: "Window"
              value: "window"
            - label: "Door"
              value: "door"
    contact_sensor:
      name: "üö™ Contact Sensor Entity"
      description: >-
        This can be used to define whether the cover belongs to a window or an (outer) door with a window opening sensor.
        If this is the case, the ventilation function can be used.
        This means that the ventilate position is approached when the window is opened/tilted.
        This sensor can be defined here.
        <br /><br />`Optional`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
    ventilate_position:
      name: "üí® Ventilate Position"
      description: >-
        What position should the cover move to when opening the window/door and the cover is closed to allow ventilation?
        If closing is triggered and the contact_sensor is 'on' the cover will move to this position instead of closing completly
        <br /><br />Should not be 100. In this case please use 99
        <br /><br />`Optional`
      default: 30
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: "%"
    ventilate_tilt_position:
      name: "üí® Ventilate Tilt Position"
      description: "To which tilt position should the cover be moved for ventilation?"
      default: 50
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"

    drive_delay_fix:
      name: "üïõ Fixed Drive Delay"
      description: >-
        Fixed drive delay to avoid radio interferences.
        <br /><br />`Optional`
      default: 0
      selector:
        number:
          min: 0.0
          max: 600.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider
    drive_delay_random:
      name: "üïõ Random Drive Delay"
      description: "Additional random delay."
      default: 5
      selector:
        number:
          min: 0.0
          max: 600.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider
    position_tolerance:
      name: "„Ä∞Ô∏è Position Tolerance"
      description: >-
        Tolerance to be applied when comparing the current position with the to be position.
        <br /><br />`Optional`
      default: 0
      selector:
        number:
          min: 0.0
          max: 20.0
          unit_of_measurement: "%"

    cover_status_options:
      name: "ü¶Æ Checking the current position or saving the cover status in a helper?"
      description: |

        - **CHECK THE CURRENT POSITION**
        The automation only moves the cover if it is positioned at one of the defined positions (ventilate position, shading position, open position or closed position). Otherwise, the cover has been moved manually.
        After a manual movement, it is unclear what is intended to be achieved, so the automation no longer takes action.
        To automate the movement of the cover again, it must be moved to one of the defined positions beforehand.
        The advantage of this is that you don't have to create a helper in Home Assistant.

        - **USE AN EXTERNAL HELPER**
        If you want to be able to intervene manually and the automation should execute the next movement as usual, a helper is required.
        *Without helper, the manual override would always be overwritten by the automation.*
        This has the advantage that the roller blind does not necessarily have to be in a defined position.
      default: cover_helper_disabled
      selector:
        select:
          options:
            - label: "Check the current position"
              value: "cover_helper_disabled"
            - label: "Use an external helper"
              value: "cover_helper_enabled"
    cover_status_helper:
      name: "ü¶Æ Cover Status Helper"
      description: >-
        Helper used to store the last cover event.
        *Attention:* You will need to manually create a input_text entity with a <ins>length of 254 chars</ins> for this.
        <br /><br />`Optional`
      default: []
      selector:
        entity:
          domain: input_text
    drive_time:
      name: "ü¶Æ Cover Drive Time"
      description: "Can be used to recognise manual control. Please round up a little and do not adjust too precisely."
      default: 90
      selector:
        number:
          min: 0.0
          max: 180.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider

    shading_position:
      name: "üï∂Ô∏è Shading Position"
      description: "To which position should the cover be moved for shading?<br /><br />`Shading`"
      default: 25
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: "%"
    shading_tilt_position:
      name: "üï∂Ô∏èShading Tilt Position"
      description: >-
        To which tilt position should the cover be moved for shading?
        <br /><br />`Shading`
      default: 50
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
    shading_brightness_sensor:
      name: "üï∂Ô∏è Brightness Sensor For Shading"
      description: >-
        An additional brightness sensor can be defined here, which is only used for shading.
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - sensor
    shading_sun_brightness_start:
      name: "üï∂Ô∏è Shading Brightness Start Value"
      description: >-
        The minimum brightness value from which shading should start.
        (Must be above the value of brightness out!)
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: 35000
      selector:
        number:
          min: 0.0
          max: 100000.0
          unit_of_measurement: lx
          step: 10.0
    shading_sun_brightness_end:
      name: "üï∂Ô∏è Shading Brightness End Value"
      description: >-
        The brightness value from which shading is no longer necessary.
        (Must be BELOW the value of brightness in!).
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: 25000
      selector:
        number:
          min: 0.0
          max: 100000.0
          unit_of_measurement: lx
          step: 10.0
    shading_azimuth_start:
      name: "üï∂Ô∏è Shading Azimuth Start Value"
      description: >-
        What is the minimum azimuth at which the sun hits the window? (Shading will start)
        <br /><br />`The attribute of default sun sensor (configured above) is used.`
        <br /><br />`Shading`
      default: 95
      selector:
        number:
          min: 0
          max: 365
          unit_of_measurement: "¬∞"
    shading_azimuth_end:
      name: "üï∂Ô∏è Shading Azimuth End Value"
      description: >-
        What is the maximum azimuth at which the sun hits the window? (Shading will stop)
        <br /><br />`The attribute of default sun sensor (configured above) is used.`
        <br /><br />`Shading`
      default: 265
      selector:
        number:
          min: 0
          max: 365
          unit_of_measurement: "¬∞"
    shading_elevation_min:
      name: "üï∂Ô∏è Shading Elevation Minimum Value"
      description: >-
        Starting from which elevation of the sun should the window be shaded?
        (Here it makes sense to consider surrounding buildings, trees, etc.).
        <br /><br />`The attribute of default sun sensor (configured above) is used.`
        <br /><br />`Shading`
      default: 25
      selector:
        number:
          min: 0
          max: 90
          unit_of_measurement: "¬∞"
    shading_elevation_max:
      name: "üï∂Ô∏è Shading Elevation Maximum Value"
      description: >-
        What is the maximal elevation for elevation?
        (In most cases, 90 degrees is probably the most reasonable value.
        However, this can also be different due to surrounding buildings, etc.).
        <br /><br />`The attribute of default sun sensor (configured above) is used.`
        <br /><br />`Shading`
      default: 90
      selector:
        number:
          min: 0
          max: 90
          unit_of_measurement: "¬∞"
    shading_temperatur_sensor1:
      name: "üï∂Ô∏è Shading Temperature Sensor 1"
      description: >-
        This is the main temperature sensor. (Here, for example, the current outdoor or indoor temperature can be used as a condition).
        This sensor does not have to be defined if the shading is to take place independently of it.
        <br /><br />`Optional`
        <br /><br />`Shading`
      selector:
        entity:
          filter:
            - domain:
                - sensor
      default: []
    shading_min_temperatur1:
      name: "üï∂Ô∏è Shading Temperature Sensor 1 Minimum Value"
      description: >-
        Minimum temperature for sensor 1 above which shading should occur.
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: 18
      selector:
        number:
          min: 0.0
          max: 50.0
          unit_of_measurement: "¬∞C"
    shading_temperatur_sensor2:
      name: "üï∂Ô∏è Shading Temperature Sensor 2"
      description: >-
        This is a secondary temperature sensor.
        (Here, for example, a temperature difference sensor can be used as a criterion.
        Or, if Sensor1 is outdoor temperature, you can use indoor temperature).
        This sensor does not have to be defined.
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - sensor
    shading_min_temperatur2:
      name: "üï∂Ô∏è Shading Temperature Sensor 2 Minimum Value"
      description: >-
        Minimum temperature for sensor 1 above which shading should occur.
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: 18
      selector:
        number:
          min: 0.0
          max: 50.0
          unit_of_measurement: "¬∞C"
    shading_forecast_sensor:
      name: "üï∂Ô∏è Forecast Temperature Sensor"
      description: >-
        Another temperature sensor. In this case, however, explicitly for use with a forecast.
        The idea is that it can happen, especially in spring, that the value for the temperature sensor1 is exceeded by
        strong solar radiation and the shading would be started.
        However, in spring you may not want shading, but the solar radiation as a welcome, free heating is desired.
        So you can define via the forecast sensor that shading is only started at an expected daily maximum temperature.
        **NOTE**: Sensor must support weather.get_forecasts which has been introduced with HA 2023.9
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: []
      selector:
        entity:
          filter:
            - domain:
                - weather
    shading_forecast_temp:
      name: "üï∂Ô∏è Forecast Temperatur Value"
      description: >-
        Minimum temperature for forecast sensor above which shading should occur.
        **NOTE**: If temperature sensor1 is also defined and its temperature rises above the value defined here,
        this condition is considered to be TRUE.
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: 20
      selector:
        number:
          min: 0.0
          max: 50.0
          unit_of_measurement: "¬∞C"
    shading_weather_conditions:
      name: "üï∂Ô∏è Weather Conditions"
      description: >-
        Check the following weather conditions when activating the shading.
        **NOTE**: Forecast sensor needs to be defined
        <br /><br />`Optional`
        <br /><br />`Shading`
      default:
        - sunny
        - partlycloudy
        - cloudy
        - clear
      selector:
        select:
          multiple: true
          options:
            - "clear-night"
            - "clear"
            - "cloudy"
            - "fog"
            - "hail"
            - "lightning"
            - "lightning-rainy"
            - "partlycloudy"
            - "pouring"
            - "rainy"
            - "snowy"
            - "snowy-rainy"
            - "sunny"
            - "windy"
            - "windy-variant"
            - "exceptional"
    shading_waitingtime_start:
      name: "üï∂Ô∏è Waiting Time For Shading Start"
      description: >-
        To prevent excessive stress on the motor, a waiting time for starting shading can be defined here.
        Shading then only STARTs when the conditions are fulfilled over the entire waiting time IN.
        <br /><br />`Shading`
      default: 300
      selector:
        number:
          min: 0
          max: 3600
          unit_of_measurement: seconds
    shading_waitingtime_end:
      name: "üï∂Ô∏è Waiting Time For Shading End"
      description: >-
        To prevent excessive stress on the motor, a waiting time can be defined here.
        Shading then ENDs when ONE of the conditions is NOT fulfilled over the entire waiting time OUT.
        <br /><br />`Shading`
      default: 900
      selector:
        number:
          min: 0
          max: 3600
          unit_of_measurement: seconds
    auto_shading_start_condition:
      name: "üï∂Ô∏è Additional Condition For Activating Sun Shading"
      description: >-
        This condition can be used to dynamically control the <ins>shading-IN-automation</ins> of the cover.
        This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: []
      selector:
        condition: {}
    auto_shading_end_condition:
      name: "üï∂Ô∏è Additional Condition For Disabling Sun Shading"
      description: >-
        This condition can be used to dynamically control the <ins>shading-OUT-automation</ins> of the cover.
        This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
        <br /><br />`Optional`
        <br /><br />`Shading`
      default: []
      selector:
        condition: {}

    check_config:
      name: "‚úîÔ∏è Check configuration"
      description: >-
        With this boolean, you can enable or disable the basic plausibility check for the configuration.
        he check only takes place if the automation is executed manually.
      default: false
      selector:
        boolean: {}
    check_config_debuglevel:
      name: "‚úîÔ∏è Check configuration - Debug level"
      description: >-
        Choose the debug level for Syslog messages in case of configuration issues
        <br />
        Please make sure that it suits your Home Assistant logger default level.
      default: "info"
      selector:
        select:
          multiple: false
          mode: dropdown
          options:
            - "critical"
            - "debug"
            - "error"
            - "info"
            - "warning"

mode: restart
max_exceeded: silent

variables:
  blind: !input blind
  blind_entities: "{{ expand(blind) | map(attribute='entity_id') | list }}"

  # Modes
  auto_options: !input auto_options
  auto_global_condition: !input auto_global_condition
  auto_up_condition: !input auto_up_condition
  auto_down_condition: !input auto_down_condition
  auto_shading_start_condition: !input auto_shading_start_condition
  auto_shading_end_condition: !input auto_shading_end_condition

  # Brightness
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down

  # Sun
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down

  # Times / Delays
  time_up_early: !input time_up_early
  time_up_late: !input time_up_late
  time_up_early_non_workday: !input time_up_early_non_workday
  time_down_early: !input time_down_early
  time_down_late: !input time_down_late
  workday_sensor: !input workday_sensor
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time

  # Positions
  open_position: !input open_position
  open_tilt_position: !input shading_tilt_position
  close_position: !input close_position
  close_tilt_position: !input close_tilt_position
  ventilate_position: !input ventilate_position
  ventilate_tilt_position: !input ventilate_tilt_position
  position_tolerance: !input position_tolerance

  # Sensors
  contact_cover_place: !input contact_cover_place
  contact_sensor: !input contact_sensor
  resident_sensor: !input resident_sensor

  # Shading
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_position: !input shading_position
  shading_tilt_position: !input shading_tilt_position
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_waitingtime_start: !input shading_waitingtime_start
  shading_waitingtime_end: !input shading_waitingtime_end
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_forecast_temp: !input shading_forecast_temp
  shading_weather_conditions: !input shading_weather_conditions

  # Config check
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel

  # Little helper for leaner code
  current_position: "{{ state_attr(blind, 'current_position') if state_attr(blind, 'current_position') is not none else state_attr(blind, 'position') }}"
  current_sun_azimuth: "{{ state_attr(default_sun_sensor, 'azimuth') }}"
  current_sun_elevation: "{{ state_attr(default_sun_sensor, 'elevation') }}"
  now_ts: "{{ as_timestamp(now()) | round(0) }}" # May not be used everywhere because we occasionally need the time stamp at runtime.

  # Cover Status Helper
  cover_status_options: !input cover_status_options
  cover_status_helper: !input cover_status_helper
  cover_status_helper_enabled: >-
    {{
      "cover_helper_enabled" in cover_status_options and
      cover_status_helper != [] and
      states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)")
    }}
  # Fallback for disabled helper. Absolutely necessary for the first run if the helper is not yet set.
  cover_status_helper_disabled: >-
    {{
      "cover_helper_disabled" in cover_status_options or
      cover_status_helper == [] or
      states(cover_status_helper) == [] or
      not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") or
      states(cover_status_helper) not in ["unavailable", "none", "unknown"]
    }}
  # After a few weeks, I will delete the downward compatibility in the form of the version checks.
  cover_status_open: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).version == 1, (states(cover_status_helper)|from_json).open, (states(cover_status_helper)|from_json).open.a, false) | bool
    }}
  cover_status_open_ts: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).v == 2, (states(cover_status_helper)|from_json).open.t, now_ts, 0 )
    }}
  cover_status_close: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).version == 1, (states(cover_status_helper)|from_json).close, (states(cover_status_helper)|from_json).close.a, false ) | bool
    }}
  cover_status_close_ts: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).v == 2, (states(cover_status_helper)|from_json).close.t, now_ts, 0 )
    }}
  cover_status_ventilate: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).version == 1, (states(cover_status_helper)|from_json).ventilate, (states(cover_status_helper)|from_json).ventilate.a, false) | bool
    }}
  cover_status_ventilate_ts: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).v == 2, (states(cover_status_helper)|from_json).ventilate.t, now_ts, 0 )
    }}
  cover_status_shading: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).version == 1, (states(cover_status_helper)|from_json).shading, (states(cover_status_helper)|from_json).shading.a, false) | bool
    }}
  cover_status_shading_ts: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).v == 2, (states(cover_status_helper)|from_json).shading.t, now_ts, 0 )
    }}
  cover_status_manual: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).version == 1, (states(cover_status_helper)|from_json).manual, (states(cover_status_helper)|from_json).manual.a, false) | bool
    }}
  cover_status_manual_ts: >-
    {{
      cover_status_helper_enabled and
      iif ((states(cover_status_helper)|from_json).v == 2, (states(cover_status_helper)|from_json).manual.t, now_ts, 0 )
    }}
  cover_status_time: >-
    {{
      cover_status_helper_enabled and
      (states(cover_status_helper)|from_json).t
    }}

trigger:
  # triggers for shading in
  - platform: numeric_state
    entity_id: !input shading_temperatur_sensor1
    above: !input shading_min_temperatur1
    id: "t_si_1"
  - platform: numeric_state
    entity_id: !input shading_temperatur_sensor2
    above: !input shading_min_temperatur2
    id: "t_si_2"
  - platform: numeric_state
    entity_id: !input shading_brightness_sensor
    above: !input shading_sun_brightness_start
    id: "t_si_3"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: elevation
    above: !input shading_elevation_min
    id: "t_si_4"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: azimuth
    above: !input shading_azimuth_start
    below: !input shading_azimuth_end
    id: "t_si_5"
  - platform: numeric_state
    entity_id: !input shading_temperatur_sensor1
    above: !input shading_forecast_temp
    id: "t_si_6"

  # triggers for shading out
  - platform: numeric_state
    entity_id: !input shading_temperatur_sensor1
    below: !input shading_min_temperatur1
    id: "t_so_1"
  - platform: numeric_state
    entity_id: !input shading_temperatur_sensor2
    below: !input shading_min_temperatur2
    id: "t_so_2"
  - platform: numeric_state
    entity_id: !input shading_brightness_sensor
    below: !input shading_sun_brightness_end
    id: "t_so_3"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: elevation
    above: !input shading_elevation_max
    id: "t_so_4"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: azimuth
    above: !input shading_azimuth_end
    id: "t_so_5"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: elevation
    below: !input shading_elevation_min
    id: "t_so_6"

  # trigger for opening cover
  - platform: numeric_state
    entity_id: !input default_brightness_sensor
    above: !input brightness_up
    for:
      seconds: !input brightness_time_duration
    id: "t_bo_1"
  - platform: time
    at: !input time_up_late
    id: "t_bo_2"
  - platform: time
    at: !input time_up_early
    id: "t_bo_3"
  - platform: time
    at: !input time_up_early_non_workday
    id: "t_bo_4"
  - platform: state
    entity_id: !input resident_sensor
    from: "on"
    to: "off"
    id: "t_bo_5"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    above: !input sun_elevation_up
    attribute: elevation
    for:
      seconds: !input sun_time_duration
    id: "t_bo_7"

  # trigger for closing cover
  - platform: numeric_state
    entity_id: !input default_brightness_sensor
    below: !input brightness_down
    for: !input brightness_time_duration
    id: "t_bc_1"
  - platform: time
    at: !input time_down_early
    id: "t_bc_2"
  - platform: time
    at: !input time_down_late
    id: "t_bc_3"
  - platform: state
    entity_id: !input contact_sensor
    from: "on"
    to: "off"
    id: "t_bc_4"
  - platform: state
    entity_id: !input resident_sensor
    from: "off"
    to: "on"
    id: "t_bc_5"
  - platform: numeric_state
    entity_id: !input default_sun_sensor
    attribute: elevation
    below: !input sun_elevation_down
    for:
      seconds: !input sun_time_duration
    id: "t_bc_7"

  # trigger for ventilate
  - platform: state
    entity_id: !input contact_sensor
    from: "off"
    to: "on"
    id: "t_bv_1"

  # trigger for manual blind movements
  - platform: state
    entity_id: !input blind
    attribute: current_position
    id: "t_ma_1"
    for: "00:01:00"

condition:
  - condition: !input auto_global_condition
  - or:
      - "{{ 'auto_shading_enabled' in auto_options }}"
      - "{{ 'auto_up_enabled' in auto_options }}"
      - "{{ 'auto_down_enabled' in auto_options }}"

action:
  # we have to call a service for forecast due to HA changes
  - if:
      - "{{ (shading_forecast_sensor != [] ) }}"
    then:
      - service: weather.get_forecasts
        target:
          entity_id: !input shading_forecast_sensor
        data:
          type: daily
        response_variable: forecast

  # If the helper is empty, the initial values are set here once.
  - if:
      - "{{ 'cover_helper_enabled' in cover_status_options }}"
      - "{{ cover_status_helper != [] }}"
      - or:
          - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") }}'
          - '{{ states(cover_status_helper) in ["unavailable", "none", "unknown"] }}'
    then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: |
            {% set dict_var = {
              'open':{'a':false,'t':0},
              'close':{'a':false,'t':0},
              'ventilate':{'a':false,'t':0},
              'shading':{'a':false,'t':0},
              'manual':{'a':false,'t':0},
              'v':2,
              't': as_timestamp(now()) | round(0)
              }
            %}
            {{ dict_var | to_json }}

  # Upgrade json to v2
  - if:
      - "{{ cover_status_helper_enabled }}"
      - "{{ (states(cover_status_helper)|from_json).version == 1}}"
    then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: |
            {% set dict_var = {
              'open':{'a':cover_status_open,'t':0},
              'close':{'a':cover_status_close,'t':0},
              'ventilate':{'a':cover_status_ventilate,'t':0},
              'shading':{'a':cover_status_shading,'t':0},
              'manual':{'a':cover_status_manual,'t':0},
              'v':2,
              't': cover_status_time | round(0)
              }
            %}
            {{ dict_var | to_json }}

  - choose:
      - alias: "Check and perform shading in or covers up"
        conditions:
          - or:
              - "{{ 'auto_shading_enabled' in auto_options }}"
              - "{{ 'auto_up_enabled' in auto_options }}"
          - or:
              # Check if we have a trigger for shading in
              - condition: trigger
                id:
                  - "t_si_1" # shading_min_temperatur1
                  - "t_si_2" # shading_min_temperatur2
                  - "t_si_3" # shading_sun_brightness_start
                  - "t_si_4" # shading_elevation_min
                  - "t_si_5" # shading_azimuth
                  - "t_si_6" # shading_forecast_temp
              # Check if we have a trigger for covers up
              - condition: trigger
                id:
                  - "t_bo_1" # brightness_up - default_brightness_sensor
                  - "t_bo_2" # time_up_late
                  - "t_bo_3" # time_up_early
                  - "t_bo_4" # time_up_early_non_workday
                  - "t_bo_5" # resident
                  - "t_bo_7" # sun_elevation_up
        sequence:
          - choose:
              - alias: "Checking for shading in"
                conditions:
                  - and: # Check if we want to perform shading in
                      - "{{ 'auto_shading_enabled' in auto_options }}"
                      - condition: !input auto_shading_start_condition
                      - "{{ now() >= today_at(time_up_early) }}"
                      - "{{ now() <= today_at(time_down_late) + timedelta(seconds = 5) }}"
                      - "{{ ( (shading_temperatur_sensor1 == [] ) or (states(shading_temperatur_sensor1) | int(default=shading_min_temperatur1) >= shading_min_temperatur1) ) }}"
                      - "{{ ( (shading_temperatur_sensor2 == [] ) or (states(shading_temperatur_sensor2) | int(default=shading_min_temperatur2) >= shading_min_temperatur2) ) }}"
                      - "{{ ( (shading_brightness_sensor == [] ) or (states(shading_brightness_sensor) | int(default=shading_sun_brightness_start) >= shading_sun_brightness_start) ) }}"
                      - "{{ current_sun_azimuth >= shading_azimuth_start and current_sun_azimuth <= shading_azimuth_end }}"
                      - "{{ current_sun_elevation >= shading_elevation_min and current_sun_elevation <= shading_elevation_max }}"
                      - "{{ current_position | int(default=101) > shading_position }}"
                      - "{{ resident_sensor == [] or is_state(resident_sensor, ['false', 'off']) }}"
                      - or:
                          - "{{ ( shading_forecast_sensor == [] ) and (shading_temperatur_sensor1 == [] ) }}"
                          - "{{ ( shading_forecast_sensor != [] ) and ( forecast.forecast[0].temperature | int(default=shading_forecast_temp) >= shading_forecast_temp ) }}"
                          - "{{ ( shading_temperatur_sensor1 != [] ) and (states(shading_temperatur_sensor1) | int(default=shading_forecast_temp) >= shading_forecast_temp) }}"
                      - "{{ ( shading_forecast_sensor == [] ) or (states(shading_forecast_sensor) in shading_weather_conditions) }}"
                sequence:
                  # we are ready for shading in
                  - if: # check helper or if cover is higher than ventilate position. In this case we consider cover position like open and therefor we want to use the delay timer
                      - or:
                          - "{{ cover_status_helper_enabled and (now_ts - 86400 >= cover_status_shading_ts) and not cover_status_shading }}"
                          - "{{ cover_status_helper_disabled and (current_position | int(default=101) > ventilate_position) }}"
                    then:
                      - alias: "Wait the number of seconds set in shading_waitingtime"
                        delay:
                          seconds: !input shading_waitingtime_start
                  - delay: "00:00:{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - repeat:
                      for_each: "{{ blind_entities|list }}"
                      sequence:
                        - alias: "Moving the cover to shading position"
                          service: cover.set_cover_position
                          data:
                            position: !input shading_position
                          target:
                            entity_id: "{{ repeat.item }}"
                        - if:
                            - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                          then:
                            - alias: "Moving the cover to tilt position"
                              service: cover.set_cover_tilt_position
                              data:
                                tilt_position: !input shading_tilt_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                          delay: "00:00:{{ (range(1, 3)|random|int) }}"
                  - if:
                      - "{{ 'cover_helper_enabled' in cover_status_options }}"
                    then:
                      - service: input_text.set_value
                        data:
                          entity_id: !input cover_status_helper
                          value: |
                            {% set dict_var = states(cover_status_helper) | from_json %}
                            {% set dict_new = {
                              'open':{'a':false,'t':dict_var.open.t},
                              'close':{'a':false,'t':dict_var.close.t},
                              'ventilate':{'a':false,'t':dict_var.ventilate.t},
                              'shading':{'a':true,'t':now_ts},
                              'manual':{'a':false,'t':dict_var.manual.t},
                              'v':2,
                              't': as_timestamp(now()) | round(0)
                              }
                            %}
                            {{ dict_new | to_json }}
                  - stop: "Stop the automation"

              - alias: "Check for opening"
                conditions:
                  - "{{ 'auto_up_enabled' in auto_options }}"
                  - condition: !input auto_up_condition
                  - or: # Check if the trigger is for normal cover opening
                      - condition: trigger
                        id:
                          - "t_bo_1" # brightness_up - default_brightness_sensor
                          - "t_bo_2" # time_up_late
                          - "t_bo_3" # time_up_early
                          - "t_bo_4" # time_up_early_non_workday
                          - "t_bo_5" # resident
                          - "t_bo_7" # sun_elevation_up
                  - or:
                      - "{{ cover_status_helper_enabled and (now_ts - 86400 >= cover_status_open_ts) and not cover_status_open }}"
                      - "{{ cover_status_helper_disabled and (current_position | int(default=101) == ventilate_position) }}"
                      - "{{ cover_status_helper_disabled and (current_position | int(default=110) <= close_position + position_tolerance) and (current_position | int(default=110) >= close_position - position_tolerance)}}"
                  - "{{ resident_sensor == [] or is_state(resident_sensor, ['false', 'off']) }}"
                  # Now we have to check different opening scenarios
                  - or:
                      - and: # Covers - opening - up late reached
                          - "{{ now() >= today_at(time_up_late) }}"
                          - "{{ now() <= today_at(time_down_early) - timedelta(seconds = 5) }}"
                      - and: # Covers - opening - up early reached and brightness/sun above minimum
                          - or:
                              - and:
                                  - "{{ workday_sensor == [] or (is_state(workday_sensor, 'on')) }}"
                                  - "{{ now() >= today_at(time_up_early) }}"
                              - and:
                                  - "{{ workday_sensor == [] or (is_state(workday_sensor, 'off')) }}"
                                  - "{{ now() >= today_at(time_up_early_non_workday) }}"
                          - "{{ now() <= today_at(time_up_late) + timedelta(seconds = 5) }}"
                          - or:
                              - or:
                                  - "{{ 'auto_brightness_enabled' in auto_options and default_brightness_sensor == [] }}"
                                  - "{{ 'auto_brightness_enabled' in auto_options and default_brightness_sensor != [] and (states(default_brightness_sensor) | int(default=brightness_up) >= brightness_up) }}"
                              - or:
                                  - "{{ 'auto_sun_enabled' in auto_options and default_sun_sensor == [] }}"
                                  - "{{ 'auto_sun_enabled' in auto_options and default_sun_sensor != [] and (current_sun_elevation | int(default=sun_elevation_up) >= sun_elevation_up) }}"

                sequence:
                  # ok, we can open the cover
                  - delay: "00:00:{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - repeat:
                      for_each: "{{ blind_entities|list }}"
                      sequence:
                        - if:
                            - "{{ open_position == 100 }}"
                          then:
                            - alias: "Moving the cover to open position"
                              service: cover.open_cover
                              data: {}
                              target:
                                entity_id: "{{ repeat.item }}"
                          else:
                            - alias: "Moving the cover to open position"
                              service: cover.set_cover_position
                              data:
                                position: !input open_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - if:
                            - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                          then:
                            - alias: "Moving the cover to tilt position"
                              service: cover.set_cover_tilt_position
                              data:
                                tilt_position: !input open_tilt_position
                              target:
                                entity_id: "{{ repeat.item }}"
                        - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                          delay: "00:00:{{ (range(1, 3)|random|int) }}"

                  - if:
                      - "{{ 'cover_helper_enabled' in cover_status_options }}"
                    then:
                      - service: input_text.set_value
                        data:
                          entity_id: !input cover_status_helper
                          value: |
                            {% set dict_var = states(cover_status_helper) | from_json %}
                            {% set dict_new = {
                              'open':{'a':true,'t':now_ts},
                              'close':{'a':false,'t':dict_var.close.t},
                              'ventilate':{'a':false,'t':dict_var.ventilate.t},
                              'shading':{'a':false,'t':dict_var.shading.t},
                              'manual':{'a':false,'t':dict_var.manual.t},
                              'v':2,
                              't': as_timestamp(now()) | round(0)
                              }
                            %}
                            {{ dict_new | to_json }}
                  - stop: "Stop the automation"

            default:
              - stop: "Stop the automation"

      - alias: "Check and perform shading out"
        conditions:
          - "{{ 'auto_shading_enabled' in auto_options }}"
          - condition: !input auto_shading_end_condition
          - "{{ now() >= today_at(time_up_early) }}"
          - "{{ now() <= today_at(time_down_late) + timedelta(seconds = 5) }}"
          - or:
              - condition: trigger
                id:
                  - "t_so_1" # shading_min_temperatur1
                  - "t_so_2" # shading_min_temperatur2
                  - "t_so_3" # shading_sun_brightness_end
                  - "t_so_4" # shading_elevation_max
                  - "t_so_5" # shading_azimuth_end
                  - "t_so_6" # shading_elevation_min
          - or:
              - "{{ cover_status_helper_enabled and cover_status_shading }}"
              - "{{ cover_status_helper_disabled and (current_position | int(default=101) == shading_position) }}"
        sequence:
          - if:
              # if sun is outside of shading window (azimuth or elevation) we immedately stop shading
              - and:
                  - "{{ current_sun_azimuth >= shading_azimuth_start and current_sun_azimuth <= shading_azimuth_end }}"
                  - "{{ current_sun_elevation >= shading_elevation_min and current_sun_elevation <= shading_elevation_max }}"
            then:
              - alias: "Wait the number of seconds set in shading_waitingtime_end"
                delay:
                  seconds: !input shading_waitingtime_end
          - if:
              - "{{ contact_sensor != [] and is_state(contact_sensor, 'on') }}"
              - "{{ 'auto_ventilate_enabled' in auto_options }}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - alias: "Moving the cover to ventilate position"
                      service: cover.set_cover_position
                      data:
                        position: !input ventilate_position
                      target:
                        entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input ventilate_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                      delay: "00:00:{{ (range(1, 3)|random|int) }}"
              - if:
                  - "{{ 'cover_helper_enabled' in cover_status_options }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':true,'t':now_ts},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}
            else:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - if:
                        - "{{ open_position == 100 }}"
                      then:
                        - alias: "Moving the cover to open position"
                          service: cover.open_cover
                          data: {}
                          target:
                            entity_id: "{{ repeat.item }}"
                      else:
                        - alias: "Moving the cover to open position"
                          service: cover.set_cover_position
                          data:
                            position: !input open_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input open_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                      delay: "00:00:{{ (range(1, 3)|random|int) }}"
              - if:
                  - "{{ 'cover_helper_enabled' in cover_status_options }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':true,'t':now_ts},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}
          - stop: "Stop the automation"

      - alias: "Check for closing cover"
        conditions:
          - or:
              - "{{ 'auto_down_enabled' in auto_options }}"
              - "{{ 'auto_ventilate_enabled' in auto_options }}"
          - condition: !input auto_down_condition
          - or:
              # Check if we have a trigger for cover down
              - condition: trigger
                id:
                  - "t_bc_1" # brightness_down
                  - "t_bc_2" # time_down_early
                  - "t_bc_3" # time_down_late
                  - "t_bc_4" # contact_sensor
                  - "t_bc_5" # resident_sensor
                  - "t_bc_7" # sun_elevation_down
          # check to allow a window but a door only if contact_sensor not open - we want protection
          - or:
              - "{{ contact_cover_place == 'window' }}"
              - "{{ contact_cover_place == 'door' and contact_sensor == [] }}"
              - "{{ contact_cover_place == 'door' and contact_sensor != [] and is_state(contact_sensor, 'off') }}"
          # - "{{ cover_status_helper_disabled or (cover_status_helper_enabled and cover_status_shading and (close_position < shading_position)) }}" # TODO: Keep this?
          - or:
              - "{{ cover_status_helper_enabled and (now_ts - 86400 >= cover_status_close_ts) and not cover_status_close }}"
              - "{{ cover_status_helper_disabled and (current_position | int(default=110) <= open_position + position_tolerance) and (current_position | int(default=110) >= open_position - position_tolerance)}}"
              - "{{ cover_status_helper_disabled and (current_position == ventilate_position) }}"
          - or:
              # Covers - closing - down late reached
              - and:
                  - "{{ 'auto_down_enabled' in auto_options }}"
                  - "{{ now() >= today_at(time_down_late) }}"
              # Covers - closing - down early reached and brightness/sun below minimum
              - and:
                  - "{{ 'auto_down_enabled' in auto_options }}"
                  - "{{ now() >= today_at(time_down_early) }}"
                  - "{{ now() <= today_at(time_down_late) + timedelta(seconds = 5) }}"
                  - or:
                      - or:
                          - "{{ 'auto_brightness_enabled' in auto_options and default_brightness_sensor == [] }}"
                          - "{{ 'auto_brightness_enabled' in auto_options and default_brightness_sensor != [] and (states(default_brightness_sensor) | int(default=brightness_down) <= brightness_down) }}"
                      - or:
                          - "{{ 'auto_sun_enabled' in auto_options and default_sun_sensor == [] }}"
                          - "{{ 'auto_sun_enabled' in auto_options and default_sun_sensor != [] and (current_sun_elevation | int(default=sun_elevation_down) <= sun_elevation_down) }}"

              # Covers - closing - due to resident goes sleeping
              - and:
                  - "{{ 'auto_down_enabled' in auto_options }}"
                  - "{{ resident_sensor != [] and is_state(resident_sensor, ['true', 'on']) }}"
                  - condition: trigger #  Resident_sensor
                    id: t_bc_5

              # Covers - closing after ventilate
              - and:
                  - condition: trigger # contact_sensor
                    id: "t_bc_4"
                  - "{{ 'auto_ventilate_enabled' in auto_options }}"
                  - "{{ contact_sensor != [] and states(contact_sensor) == 'off' }}"
                  - or:
                      - "{{ cover_status_helper_enabled and cover_status_ventilate }}"
                      - "{{ cover_status_helper_disabled and (current_position | int(default=101) == ventilate_position) }}"

        sequence:
          - if:
              - not:
                  - condition: trigger # Windows sensor
                    id: "t_bc_4"
            then:
              - delay: "00:00:{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
          - if:
              - "{{ contact_sensor != [] and is_state(contact_sensor, 'on') }}"
              - "{{ 'auto_ventilate_enabled' in auto_options }}"
            then:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - alias: "Moving the cover to ventilate position"
                      service: cover.set_cover_position
                      data:
                        position: !input ventilate_position
                      target:
                        entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input ventilate_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                      delay: "00:00:{{ (range(1, 3)|random|int) }}"
              - if:
                  - "{{ 'cover_helper_enabled' in cover_status_options }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':true,'t':now_ts},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}
            else:
              - repeat:
                  for_each: "{{ blind_entities|list }}"
                  sequence:
                    - if:
                        - "{{ close_position == 0 }}"
                      then:
                        - alias: "Moving the cover to close position"
                          service: cover.close_cover
                          data: {}
                          target:
                            entity_id: "{{ repeat.item }}"
                      else:
                        - alias: "Moving the cover to close position"
                          service: cover.set_cover_position
                          data:
                            position: !input close_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - if:
                        - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                      then:
                        - alias: "Moving the cover to tilt position"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: !input close_tilt_position
                          target:
                            entity_id: "{{ repeat.item }}"
                    - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                      delay: "00:00:{{ (range(1, 3)|random|int) }}"
              - if:
                  - "{{ 'cover_helper_enabled' in cover_status_options }}"
                then:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':now_ts},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':false,'t':dict_var.manual.t},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}
          - stop: "Stop the automation"

      - alias: Window sensor - opened
        conditions:
          - condition: trigger # contact_sensor
            id: "t_bv_1"
          - "{{ 'auto_ventilate_enabled' in auto_options }}"
          - "{{ contact_sensor != [] and is_state(contact_sensor, 'on') }}"
          - or:
              - "{{ cover_status_helper_enabled and cover_status_close }}"
              - "{{ cover_status_helper_disabled and (current_position | int(default=110) <= close_position + position_tolerance) and (current_position | int(default=110) >= close_position - position_tolerance) }}"
        sequence:
          - repeat:
              for_each: "{{ blind_entities|list }}"
              sequence:
                - alias: "Moving the cover to ventilate position"
                  service: cover.set_cover_position
                  data:
                    position: !input ventilate_position
                  target:
                    entity_id: "{{ repeat.item }}"
                - if:
                    - "{{ state_attr(repeat.item, 'current_tilt_position') != none }}"
                  then:
                    - alias: "Moving the cover to tilt position"
                      service: cover.set_cover_tilt_position
                      data:
                        tilt_position: !input ventilate_tilt_position
                      target:
                        entity_id: "{{ repeat.item }}"
                - alias: "Wait 1-5 random seconds to prevent sending to many commands to covers at same time"
                  delay: "00:00:{{ (range(1, 3)|random|int) }}"
          - if:
              - "{{ 'cover_helper_enabled' in cover_status_options }}"
            then:
              - service: input_text.set_value
                data:
                  entity_id: !input cover_status_helper
                  value: |
                    {% set dict_var = states(cover_status_helper) | from_json %}
                    {% set dict_new = {
                      'open':{'a':false,'t':dict_var.open.t},
                      'close':{'a':false,'t':dict_var.close.t},
                      'ventilate':{'a':true,'t':now_ts},
                      'shading':{'a':false,'t':dict_var.shading.t},
                      'manual':{'a':false,'t':dict_var.manual.t},
                      'v':2,
                      't': as_timestamp(now()) | round(0)
                      }
                    %}
                    {{ dict_new | to_json }}
          - stop: "Stop the automation"

      - alias: "Blind Movement" # Checking for manual position changes
        conditions:
          - condition: trigger
            id: "t_ma_1"
          - "{{ 'cover_helper_enabled' in cover_status_options }}" #Do not use 'cover_status_helper_enabled' (with the embedded regex here), because it could be set after variable declaration
          - "{{ cover_status_helper != [] }}"
          - "{{ as_timestamp(now()) - cover_status_time > (drive_time + 60)}}" # Drive time + trigger waiting time
        sequence:
          - choose:
              - conditions: # Now defined positions can be assigned
                  - not:
                      - "{{ ('auto_up_enabled' in auto_options) and (current_position | int(default=110) <= open_position + position_tolerance) and (current_position | int(default=110) >= open_position - position_tolerance) }}"
                      - "{{ ('auto_down_enabled' in auto_options) and (current_position | int(default=110) <= close_position + position_tolerance) and (current_position | int(default=110) >= close_position - position_tolerance) }}"
                      - "{{ ('auto_ventilate_enabled' in auto_options) and (current_position | int(default=110) <= ventilate_position + position_tolerance) and (current_position | int(default=110) >= ventilate_position - position_tolerance) }}"
                      - "{{ ('auto_shading_enabled' in auto_options) and (current_position | int(default=110) <= shading_position + position_tolerance) and (current_position | int(default=110) >= shading_position - position_tolerance) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':true,'t':now_ts},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually opened
                  - or:
                      - "{{ ('auto_up_enabled' in auto_options) and (current_position | int(default=110) <= open_position + position_tolerance) and (current_position | int(default=110) >= open_position - position_tolerance) }}"
                      - "{{ ('auto_up_enabled' in auto_options) and (current_position | int(default=110) > ventilate_position) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':true,'t':now_ts},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':true,'t':now_ts},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually closed
                  - or:
                      - "{{ ('auto_down_enabled' in auto_options) and (current_position | int(default=110) <= close_position + position_tolerance) and (current_position | int(default=110) >= close_position - position_tolerance) }}"
                      - "{{ ('auto_down_enabled' in auto_options) and (current_position | int(default=110) < shading_position) and (current_position | int(default=110) < ventilate_position) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':true,'t':now_ts},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':true,'t':now_ts},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually ventilated
                  - "{{ ('auto_ventilate_enabled' in auto_options) and (current_position | int(default=110) <= ventilate_position + position_tolerance) and (current_position | int(default=110) >= ventilate_position - position_tolerance) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':true,'t':now_ts},
                          'shading':{'a':false,'t':dict_var.shading.t},
                          'manual':{'a':true,'t':now_ts},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}

              - conditions: # Manually shaded
                  - "{{ ('auto_shading_enabled' in auto_options) and (current_position | int(default=110) <= shading_position + position_tolerance) and (current_position | int(default=110) >= shading_position - position_tolerance) }}"
                sequence:
                  - service: input_text.set_value
                    data:
                      entity_id: !input cover_status_helper
                      value: |
                        {% set dict_var = states(cover_status_helper) | from_json %}
                        {% set dict_new = {
                          'open':{'a':false,'t':dict_var.open.t},
                          'close':{'a':false,'t':dict_var.close.t},
                          'ventilate':{'a':false,'t':dict_var.ventilate.t},
                          'shading':{'a':true,'t':now_ts},
                          'manual':{'a':true,'t':now_ts},
                          'v':2,
                          't': as_timestamp(now()) | round(0)
                          }
                        %}
                        {{ dict_new | to_json }}

    default:
      # TODO: I'm not sure whether I want to have this checked with every default run.
      - if:
          - "{{ check_config }}"
        then:
          ## checking time slots
          - if:
              - "{{ today_at(time_up_early) >= today_at(time_up_late) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_up_early should be earlier than time_up_late - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ today_at(time_up_early_non_workday) >= today_at(time_up_late) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_up_early_non_workday should be earlier than time_up_late - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ today_at(time_down_early) >= today_at(time_down_late) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: time_down_early should be earlier than time_down_late - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking shading
          - if:
              - "{{ shading_azimuth_start >= shading_azimuth_end }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_azimuth_start should be lower than shading_azimuth_end - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ shading_elevation_min >= shading_elevation_max }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_elevation_min should be lower than - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ shading_sun_brightness_start <= shading_sun_brightness_end }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_sun_brightness_start should be higher than shading_sun_brightness_end - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking positions
          - if:
              - "{{ (open_position - position_tolerance) <= (close_position + position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: open_position should be higher than close_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (open_position - position_tolerance) <= (ventilate_position + position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: open_position should be higher than ventilate_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (close_position + position_tolerance) >= (ventilate_position - position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: close_position should be lower than ventilate_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (shading_position - position_tolerance) <= (close_position + position_tolerance)}}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_position should be higher than close_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ (shading_position + position_tolerance) >= (open_position - position_tolerance) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: shading_position should be lower than open_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ ( (resident_sensor != [] ) and (not is_state(resident_sensor, ['false', 'off','true', 'on'])) ) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: resident_sensor is only allowed to be on/off/true/false - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking if blind entity has the right attributes
          - if:
              - "{{ state_attr(blind, 'current_position') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: blind is missing attribute current_position - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking if sun sensor has the right attributes
          - if:
              - "{{ state_attr(default_sun_sensor, 'elevation') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: sun sensor is missing attribute elevation - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          - if:
              - "{{ state_attr(default_sun_sensor, 'azimuth') is none }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: sun sensor is missing attribute azimuth - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking if brightness sensor is defined
          - if:
              - or:
                  - "{{ 'auto_brightness_enabled' in auto_options and default_brightness_sensor == [] }}"
                  - "{{ 'auto_brightness_enabled' in auto_options and not is_number(states(default_brightness_sensor)) }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: brightness sensor not defined or state is not numeric - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"
          ## checking helper
          - if:
              - or:
                  - "{{ 'cover_helper_enabled' in cover_status_options }}"
                  - "{{ state_attr(cover_status_helper, 'max') <= 254 }}"
            then:
              - service: system_log.write
                data:
                  level: "{{ check_config_debuglevel }}"
                  message: "Cover Control Automation (CCA): Config issue: Wrong length of the cover status helper - {{this.entity_id}}"
                  logger: "blueprints.hvorragend.cover_control_automation"

      - stop: "Stopping the automation - Reset"
