blueprint:
  name: "Cover Control Automation (CCA)"
  description: |
    # ‚≠ê Cover Control Automation (CCA) ‚≠ê
    ### A comprehensive and highly configurable blueprint for roller shutters and roller blinds

    **Version**: 2025.06.13
    **Help**: [Community Thread](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539) | **Source Code**: [github.com/hvorragend](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml) | **Tickets**: [Issues](https://github.com/hvorragend/ha-blueprints/issues)

    **If you would like to support me or say thank you, please click here:**
    ### üôè [PayPal Donation](https://www.paypal.com/donate/?hosted_button_id=NQE5MFJXAA8BQ) | [Buy me a Coffee](https://buymeacoffee.com/herr.vorragend) üôè

    <details>
    <summary><strong>Features</strong></summary>

    ‚úÖ Automatic opening and closing the roller shutters
    ‚úÖ Freely configurable time windows for opening or closing
    ‚úÖ Brightness control and/or control via the sun-elevation
    ‚úÖ The use of scheduler helpers are possible
    ‚úÖ Ventilation feature (Currently for two-way sensors)
    ‚úÖ Resident feature: keep the cover closed if resident is asleep
    ‚úÖ Complete flexibility in almost all parameters (drive delays, waiting times, position tolerance)
    ‚úÖ Each feature can be activated or deactivated as required
    ‚úÖ Dynamic conditions possible (see examples in `Details`)
    ‚úÖ Extensive automatic sun shading with many different setting options (see features in `Details`)
    ‚úÖ Added the option to save the current status in a helper. This has the advantage that the cover can also be in other positions and the automation can still be executed. And manual interventions are not constantly overridden with every trigger.

    **Sun shading features**
    ‚úÖ Sun azimuth
    ‚úÖ Sun elevation
    ‚úÖ Solar irradiation/Light intensity/Illuminance
    ‚úÖ Weather Conditions
    ‚úÖ Two different temperature sensors (compare thresholds for indoor and/or outdoor sensors)
    ‚úÖ Not only the current temperature, but also the temperature forecast can also be taken into account.
    ‚úÖ If multiple criteria (e.g. temperature sensors and/or azimuth and/or elevation) are defined, shading will not occur until <ins>all</ins> criteria are met.

    </details>

    <details>
    <summary><strong>License notice</strong></summary>

    *(Based on the text by SirGoodenough)*
    * Copies of the original Blueprint that were converted via the 'Take Control' feature or other means are officially not supported by me.
    * I may or may not be able to support you when you have a problem after you make changes to my code, as some of the code is no longer mine.
    * I & my license also require attribution as a link back to the original should you use this code in your own creation.
    * [Here is a link to my license & the original github post](https://github.com/hvorragend/ha-blueprints/?tab=License-1-ov-file) expected to be followed & referenced as attribution should you use this code elsewhere.

    </details>

    <details>
    <summary><strong>Important notes</strong></summary>

    - <strong>It is <ins>not</ins> not possible to execute this automation manually! Unless you use it exclusively for the configuration check!!</strong>
    - If you want to use sun elevation and/or azimuth it's strongly advised to use sun.sun. And please make sure your sun.sun entity is enabled!
    - `time_up_early` should be earlier than `time_up_late`
    - `time_up_early_non_workday` should be earlier than `time_up_late_non_workday`
    - `time_down_early` should be earlier than `time_down_late`
    - `time_down_early_non_workday` should be earlier than `time_down_late_non_workday`
    - `shading_azimuth_start` should be lower than `shading_azimuth_end`
    - `shading_elevation_min` should be lower than `shading_elevation_max`
    - `shading_sun_brightness_start` should be higher than `shading_sun_brightness_end`
    - `open_position` should be higher than `close_position`
    - `open_position` should be higher than `ventilate_position`
    - `close_position` should be lower than `ventilate_position`
    - `shading_position` should be higher than `close_position`
    - `shading_position` should be lower than `open_position`
    - `resident_sensor` is only allowed to be on/off/true/false
    - cover must have a `current_position` attribute

    </details>

    <details>
    <summary><strong>Latest changes</strong></summary>

    **Full Changelog**: [CHANGELOG.md](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/CHANGELOG.md)

    2025.06.13
      - Quick fixes

    2025.06.12
      - Fixed: Increased the delay to 20 seconds for the ‚ÄúEnd Sun Shading Immediately When Out Of Range‚Äù feature. This change aims to ensure the new trigger executes reliably, as Home Assistant appears to ignore shorter delay values.
      - Updated: Refactored helper_state_json to include a more robust fallback mechanism.
      - Improved: Shading end triggers have been restructured to activate only when shading is currently active.
      - Refactored: Codebase has been restructured to use YAML anchors, improving maintainability and reducing redundancy.

    2025.06.11
      - Fixed: Error fixed if the Workday Tomorrow sensor was not specified

    2025.06.10
      - Fixed: The detection of weekdays and weekends is working again.

    2025.06.07
      - Added: Resident check for ventilation #216 (Thanks for the pull request, Astado)
      - Added: Better description for shading_forecast_sensor (Thanks you, Eimeel)
      - Fixed: Solve Issue with sun shading end if Tilt Position Control is enabled #216 (Thanks for the pull request, Astado)
      - Fixed: Shades are being opened or closed even if they are already #219
      - Fixed:
        When the ‚ÄúEnd Sun Shading Immediately When Out Of Range‚Äù mode was activated, the shading of the cover was not canceled.
        This was because the new waiting time was set to 0 seconds and CCA could not trigger itself in the same second via a helper.
      - Updated: Extensive code refactoring
      - Updated:
        Automation mode changed to 'single' as a test, because otherwise new triggers in the delay would interfere with processing.
        In the worst case, I will have to work with {{ state_attr('automation.cca_automation', 'current') > 0 }} as before to be able
        to intercept the reciprocal triggers.

    2025.05.27
      - Updated: Revised information text for configuring the position configuration
      - Added: The schedule helper state has been added as a variable. This is just for debugging purposes. #214
      - Fixed: The problems with the start of shading have been corrected. #212 #211
        If the shading conditions were not still fulfilled after the end of the waiting time, the sun protection was sometimes not activated correctly.
        Now we have a new feature and we can select the following options:
          - If the conditions were not permanently fulfilled, we can wait for another trigger to be executed. The previous pending status is now successfully reset.
          - And much better: CCA can be configured so that we can periodically check the shading during the day. The system then checks again and again until the conditions are valid again.

    2025.05.20
      - Fixed: Wrong default value for shading_forecast_temp

    2025.05.14
      - Added: Falling below shading_elevation_max now also triggers Shading Start #193
      - Fixed: When detecting manual position changes, values greater than Ventilation were incorrectly assumed to be Open. This was too This was too wide-ranging.

    2025.05.13
      - Fixed: The nightly shading reset has changed the timestamp and therefore a new shading with active 'prevent_shading_multiple_times' can never be executed.

    2025.05.12:
      - Fixed: Multiple triggering of a detected shading has skipped the waiting time until execution #206

    2025.05.11:
      - Fixed: Fixed bug that the cover can be opened again by the time-up-late-trigger despite existing shading.

    2025.05.07:
      - Fixed: Shading is now also recognized and temporarily stored in the helper if the resident sensor contains the value true. #131
      - Added: Tilt Reposition Feature (Thanks for the pull request, Astado) #196
      - Update: Better textual clarification of what the result of the additional condition should look like #204
      - Update: Only shade the cover when it is not in the shading position. Purely as a precautionary measure in case the target state and actual state do not match.

    2025.05.04:
      - Added: Allow immediate ending of shading if the sun is out of the defined azimuth or elevation range #202 (Thanks for the pull request, jpawlowski)
      - Added: Option to close cover instead of opening when shading ends (ideal for awnings) #203 (Thanks for the pull request, jpawlowski)
      - Updated: Note that the weather sensor specification is optional #198

    2025.05.02-02:
      - Fixed: A bug has been fixed that caused the shading to be recognized but not executed. But only if shading was only allowed to be executed once a day.

    2025.05.02-01:
      - Fixed: Also take into account for shading that a door contact only needs to be tested when ventilation mode is switched on #197
      - Fixed: Removed protocol error that occurs during manual execution.
      - Added: Catching an incorrect weather configuration
      - Added: Ability to specify an existing sensor if it already provides daily maximum temperature forecast instead of weather entity #199
      - Added: Add hysteresis for temperature sensor based shading #189

    2025.04.18:
      - Updated: Just to be more bulletproof, the tilt position control can now be specifically switched on or off. Please activate if necessary. #163
      - Updated: There is no default value for "Sun Shading Forecast Temperature" here now. To not compare the forecast temperature, leave this field empty. #179
      - Added: Allow entities of the switch domain as resident sensor or with the force entities #167
      - Added: New additional actions: Commands can now be executed before opening, closing, shading and ventilation #166
      - Fixed: Fixed problems resetting manual override #184
      - Fixed: Make sure that the reset of the manual override is only executed once #178
      - Fixed: Problems with lockout protection and partial ventilation solved #181
      - Fixed: There was no latest time for closing the cover when the scheduler was used with sun/brightness #170
      - Added: Added Sun elevation examples into the description #175
      - Added: New feature 'Allow opening the cover when resident is still present' #192
      - Breaking change: Please reconfigure "Allow sun protection when resident is still present" ('resident_shading_enabled' was renamed)

    2024.12.20:
      - Added: Additional Condition For Disabling Ventilation
      - Fixed: Small scheduler fix and description also updated
      - Update: Update of the logic and documentation for the resident sensor #158

    2024.10.21:
      - Added: The delay values in relation to the contact sensors can now be configured individually #149
      - Fixed: A problem with the scheduler in connection with the sun height/brightness has been fixed
      - Updated: YAML-Syntax for automations. Minimum version of the core raised to 2024.10.

    2024.09.25:
      - Fixed: Shutter up in the morning while Resident asleep #145
      - Fixed: Some warnings
      - Minor clean-up work

    2024.09.19:
      - Fixed: Fixed some warnings in the log. No influence on functionality #141
      - Fixed: Brightness Down not working #144
      - Fixed: Shutter up after resident on not (always) functional #139

    2024.09.05:
      - Added check for a shading shading start/end time > 0

    2024.09.04:
      - Major Update:
          - Complete redesign of the logic behind the contact sensors.
          - Splitting the contact sensors into "Tilted windows" and "Open windows"
          - Lockout protection removed from the automation options
          - Lockout protection can be configured individually
          - <strong>Please reconfigure contacts,  residents and manual override settings!</strong>

      - Major Update:
          - Complete redesign of the shading triggers.
            I have now separated the originally combined triggers again.
            And the waiting time is no longer taken into account in the trigger and also not as a delay in the action sequences.
            Instead, the new trigger time is now saved in the helper.
            This has the wonderful advantage that we can work with several shading triggers again, which do not reset and restart each other.
            Unfortunately, this makes things more complicated in support, as I now need traces for both triggers (pending and execution).
            But I also hope to have fewer customer service calls in the long term.
            In addition, you can now see traces again that were previously not available because they were cancelled directly in the for-wait time.

      - Updated: If you previously used the manual control reset at a certain time, you now have to reconfigure this feature once. I had to rename the variable is_reset_time to is_reset_fixed_time.
      - Added: Config check for schedule helper
      - Added: Sun shading can now be allowed even if a resident is present #131
      - Fixed: A delay is now also taken into account when the sun shading is ended #128
      - Fixed: When checking the end of shading, a True was always output if the weather conditions array was empty #133
      - Fixed: Prevent double triggering if early+late times are identical.

      - Breaking Changes:
          <ins>Removed settings:</ins>
          - "Prevent the cover from closing immediately after deactivating the lockout protection" (prevent_close_after_lockout)
          - "Enable lockout protection" (auto_lockout_protection_enabled)
          - "Contact Sensor Entity For Ventilation" (contact_sensor)
          - "Contact Sensor Entity For Lockout Protectio" (contact_sensor_lockout)
          - "Prevent automatic closing due to the resident sensor" (prevent_closing_by_resident)

          <ins>Please delete the following variables in the YAML code:</ins>
          - prevent_close_after_lockout
          - auto_lockout_protection_enabled
          - contact_sensor
          - contact_sensor_lockout
          - prevent_closing_by_resident
          - is_reset_time (replaces with is_reset_fixed_time)

    2024.08.03:
      - Fixed: Helper length analysis template variable warning #120
      - Fixed: New trigger "t_shading_reset" causes errors #119
      - Fixed: "Manual Override" don't work #122 (Thanks for the pull request, Eimeel)
      - Fixed: Commenting out the check of the position information in the config check #121
      - Fixed: Blinds not opening with resident mode when auto close disabled #115

    2024.07.31:
      - Fixed: Override conditions were incorrect #109
      - Fixed: Faulty timing triggers although they have been deactivated #104
      - Fixed: Removed duplicate line of code without effect #105
      - Fixed: Reset shading status at midnight that is no longer required - but still saved #106
      - Fixed: Empty weather conditions are now taken into account when shading is ended #110
      - Fixed: When the shading is ended, the resident sensor is now also checked so that nobody is woken up #116
      - Updated: All force situations are now fully cross-checked in all choose-branches
      - Added: Save the length of the helper for better debugging #107
      - Added: The ventilation position can now be moved to after the sun shading has ended (if the contact is open)

    2024.07.06:
      - Fixed: Return to shading after ventilation #43
      - Fixed: When closing the ventilation contact, do not move the roller blind if it is already in the correct position #102
      - Updated: Trigger name renamed to make debugging easier for beginners
      - Added: Additional information on when a Cover Status Helper is required
      - Added: License notification and notice about the new <em>Take Control</em>-feature

    2024.06.30:
      - Fixed: Preventing errors and warning on manual execution
      - Fixed: Incorrect time adopted if tomorrow is a working day and today is a weekend

    2024.06.29:
      - <strong>Breaking change:</strong>: The checkbox introduced in the last update "reset_manual_detection" has been moved to a separate selection. Please reconfigure.
      - Added: Time and timeout in minutes to reset the manual override #95
      - Added: Additional Actions After Override Reset #94
      - Fixed: The cover may also be closed after ventilation if the down mode is not activated
      - Many thanks to crandler for the ideas

    2024.06.27:
      - Minor bugfix

    2024.06.26:
      - <strong>Breaking change:</strong> The option <em>"Prevent the use of the 'get_forecasts' service (prevent_forecast_service)"</em> has been removed and replaced by the configuration option under <em>"Sun Shading Forecast Type"</em>
      - Fixed: If tomorrow is not a working day, the right time is taken now - #80
      - Fixed: If the blind is moved manually below the shading and ventilation position, this is no longer recognised as closed.
      - Added: Additional Actions After Manual Change - #87
      - Added: You can now decide whether you want to use the hourly or daily weather forecast.
      - Added: It is now possible to reset the manual detection of roller blind movements at 00:01 - #86

    2024.06.24:
      - <strong>Breaking change:</strong> 'prevent_higher_position_shading_end' changed to new parameter 'prevent_lowering_when_closing_if_shaded'
      - Added: Limited templates for enabling automation triggers
      - Added: Shading sensor 2 is also checked again during shading
      - Fixed: Occasionally sun shading was performed without checking the weather conditions
      - Fixed: The ventilation position was not set correctly when closing the roller blind
      - Fixed: At the end of sun shading, the system no longer moves to the ventilation position
      - Fixed: Sun shading is now also calculated outside the configured times and can be taken into account when opening.
      - Fixed: Option "Prevent the cover from closing immediately after deactivating the lockout protection"
      - Many thanks to Eimeel and Bostil

    2024.06.05-01:
      - Added: Optional checking workday tomorrow sensor when closing the cover #71
      - Updated: GUI section icons to MDI icons

    2024.06.04-01:
      - Major GUI Update: Using blueprint sections now (Min-Core-Version: 2024.6.0)

    </details>

  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: "2024.10.0"
  input:
    blind:
      name: "üè† Cover"
      description: >-
        Which blind or roller shutter should be automated?

        <details>
        <summary><code><strong>CLICK HERE:</strong> Information about a cover group</code></summary>


        In principle, you can use a group here.
        But please note that there are problems with position detection for a group of covers!
        For example, one cover may be at position 100% and the other cover at position 0%.
        This results in a wrong group-value of 50%.


        My clear recommendation is to create **one automation for each cover**.

        </details>

      selector:
        entity:
          filter:
            - domain:
                - cover

    feature_section:
      name: "Automation Options"
      icon: mdi:window-shutter-cog
      collapsed: true
      input:
        auto_options:
          name: "üëâ Automation Options"
          description: >-
            The options on the right-hand side determine whether the cover is allowed to open or to close.
            <br /><br />
            Typically, the opening and closing of the roller blinds is managed by a timer (see below).
            Activation of these initial two options (1 and 2) is necessary for the blinds to function.
            <br /><br />
            <ins>In addition to the time control</ins>, the height of the sun and a brightness sensor can also play
            a role in regulating the opening and closing of the blinds.
            To access options 3 or 4, activation is required. Up to this point, <ins>none</ins> of these settings
            pertain to the protection of the sun. This is activated in the last option.
            <br /><br />
            <strong>Important Note:</strong> Configuring the Cover Status Helper is <ins>mandatory</ins> for utilizing
            ventilation mode or for sun protection and sunshade control.
            <br /><br />
            This can can be enhanced with additional conditions (see below).
            However, it‚Äôs crucial that options are remain activated; otherwise, the specified conditions will not function.
            <br /><br />
            Please ensure that the relevant sensors are are also included.
            For instance, the brightness control will only operate if a brightness sensor is specified.

            </details>
            <br /><br />
            <details>
            <summary><code><strong>CLICK HERE:</strong> Some notes on multiple triggering</code></summary>


            Even if multiple opening, closing, shading, etc. is activated, this only works if a trigger is available.
            However, the numeric state triggers only trigger under certain circumstances.
            Please see notes here [Numeric state triggers](https://www.home-assistant.io/docs/automation/trigger/#numeric-state-trigger)

            <em>Crossing the threshold means that the trigger only fires if the state wasn't previously within the threshold. If the current state of your entity is `50` and you set the threshold to `below: 75`, the trigger would not fire if the state changed to e.g. `49` or `72` because the threshold was never crossed. The state would first have to change to e.g. `76` and then to e.g. `74` for the trigger to fire.</em>

            </details>
          default:
            [
              auto_up_enabled,
              auto_down_enabled,
              auto_brightness_enabled,
              auto_sun_enabled,
            ]
          selector:
            select:
              options:
                - label: "üîº - Enable generic automatic opening of the day in the morning"
                  value: "auto_up_enabled"
                - label: "üîª - Enable generic automatic daily closing at the end of the day"
                  value: "auto_down_enabled"
                - label: "üîÖ - Enable brightness control (in addition to daily opening and closing)"
                  value: "auto_brightness_enabled"
                - label: "‚òÄÔ∏è - Enable sun elevation control (in addition to daily opening and closing)"
                  value: "auto_sun_enabled"
                - label: "üí® - Enable ventilation mode and lockout protection (helper required)"
                  value: "auto_ventilate_enabled"
                - label: "ü•µ - Enable automatic sun protection / sunshade control (helper required)"
                  value: "auto_shading_enabled"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        individual_config:
          name: "‚öôÔ∏è Individual Configuration"
          description: >-
            Various different options for some fine adjustments

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            <ins>Prevent 'set_cover_position' and 'set_cover_tilt_position'</ins><br />
            There are devices that have problems when the two services 'set_cover_position' and 'set_cover_tilt_position' are executed directly one after the other.
            For example, there are Shelly devices that use the script [cover_position_tilt.yaml](https://gist.github.com/lukasvice/b364724d84c3ac4e160f7a7d8fa37066) here.
            Or Homematic blind actuators, which can better use their own service for this: [homematicip_local.set_cover_combined_position](https://github.com/SukramJ/custom_homematic?tab=readme-ov-file#homematicip_localset_cover_combined_position).
            This option can be used to disable the standard services and allows the control to be implemented individually via the addtional actions.

            </details>
          default: []
          selector:
            select:
              options:
                - label: "üö´ Prevent the cover from moving to a higher position when closing in the evening"
                  value: "prevent_higher_position_closing"
                - label: "üö´ Prevent the position from being lowered when closing in the evening if it is currently shaded" # If the cover is in the shading position, it should not be closed in the evening if the close position is lower than the shading position. The current shading position should therefore be kept."
                  value: "prevent_lowering_when_closing_if_shaded"
                - label: "üö´ Prevent the end of sun shading when the cover is already closed"
                  value: "prevent_shading_end_if_closed"
                - label: "üö´ Prevent the opening of the cover after shading ends (office use)"
                  value: prevent_opening_after_shading_end
                - label: "üö´ Prevent the opening of the cover after ventilation ends (office use)"
                  value: prevent_opening_after_ventilation_end
                - label: "üö´ Prevent the use of 'set_cover_position' and 'set_cover_tilt_position' and only use the additional actions"
                  value: "prevent_default_cover_actions"
                - label: "üö´ Prevent the cover from being opened several times a day"
                  value: "prevent_opening_multiple_times"
                - label: "üö´ Prevent the cover from being closed several times a day"
                  value: "prevent_closing_multiple_times"
                - label: "üö´ Prevent the cover from being shaded several times a day"
                  value: "prevent_shading_multiple_times"
              multiple: true
              sort: false
              custom_value: false
              mode: list

    helper_section:
      name: "Cover Status Helper"
      icon: mdi:form-textbox
      collapsed: true
      input:
        cover_status_options:
          name: "ü¶Æ Status detection of the cover"
          description: >
            It is essential that the cover has the <em>current_position</em> attribute.
            Regardless of which option is selected here, the position detection is based on this attribute.
            The <em>current_tilt_position</em> attribute is <ins>not</ins> taken into account.


            <strong>Important note:</strong><br />
            - I strongly recommend using the Cover Status Helper! The full range of functions is only available if this is configured.<br />
            - The helper is required for shading, ventilation and lockout protection!<br />


            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            - <ins>Check the current position</ins><br />
            The automation only moves the cover if it is positioned at one of the defined positions (ventilate position, shading position, open position or closed position). Otherwise, the cover has been moved manually.
            After a manual drive, it is unclear what is intended to be achieved, so the automation no longer takes action.
            To automate the drive of the cover again, it must be moved to one of the defined positions beforehand.
            The advantage of this is that you don't have to create a helper in Home Assistant.
            Only basic features are available with this setting.


            - <ins>Use an external Cover Status Helper</ins><br />
            If you want to be able to do manual overrides and have the automation do the next drive as usual,
            then a helper is necessary. Without a helper, the manual override would always be overwritten by the automation.
            This has the advantage that the cover does not necessarily have to be in a defined position.
            With this choice, advanced functions are possible and you can always rely on the automation.


            </details>
          default: cover_helper_disabled
          selector:
            select:
              options:
                - label: "#Ô∏è‚É£ Check the current position"
                  value: "cover_helper_disabled"
                - label: "ü¶Æ Also use an external Cover Status Helper (better)"
                  value: "cover_helper_enabled"

        cover_status_helper:
          name: "ü¶Æ Cover Status Helper"
          description: >-
            Helper used to store the last cover event. A separate helper must be created for each CCA automation.
            *Attention:* You will need to manually create a [input_text](https://my.home-assistant.io/redirect/helpers/) entity with a <ins>length of 254 chars</ins> for this.
          default: []
          selector:
            entity:
              domain: input_text

        drive_time:
          name: "‚è≤Ô∏è Cover Drive Time"
          description: >-
            Can be used to recognise manual control. Please round up a little and do not adjust too precisely. Is used to delay the trigger if too much or incorrect position data is sent back.
            <br /><br />
            Within this time, it is assumed that CCA has carried out the last action. Otherwise, CCA would react to its own commands and recognize them as manual intervention.
          default: 90
          selector:
            number:
              min: 0.0
              max: 180.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    position_section:
      name: "Cover Position Settings"
      icon: mdi:window-shutter-settings
      description: >-
        <br /><center>
          <details>
              <summary><code><strong>CLICK HERE:</strong> Important notes on configuring the position values</code></summary>
              <code>
              Please ensure that all position values are unique and do not conflict with each other.<br />
              Correct position values are essential (e.g. open_position must be greater than closed_position).<br />
              The shading and ventilation positions must also be unique, i.e. they must not match any other values.<br />
              For more information, please refer to the important notes at the top of the blueprint description or the second post in the CCA community thread.<br /><br />
              Attention: Bear in mind that, if you include the tolerance, the other positions are not too close to each other.<br />
              The following would cause problems and be incorrect:<br />
              Open Position = 100 / Ventilate Position = 99 / Tolerance >= 1<br />
            </code>
          </details>
        </center><br />

      collapsed: true
      input:
        open_position:
          name: "üîº Open Position"
          description: "What position should the cover be moved into when opening?"
          default: 100
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        close_position:
          name: "üîª Close Position"
          description: "What position should the cover be moved into when closing?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        ventilate_position:
          name: "üí® Ventilate Position"
          description: >-
            What position should the cover move to when the window is tilted?
            If closing is triggered and the contact sensor is 'on', the cover will move to this position instead of closing completely.
            <br /><br />Should not be 100. In this case please use 99. And please also note the information in the position tolerance.
          default: 30
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        shading_position:
          name: "ü•µ Sun Shading Position"
          description: "To which position should the cover be moved for shading?"
          default: 25
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        position_tolerance:
          name: "„Ä∞Ô∏è Position Tolerance"
          description: >-
            Tolerance to be applied when comparing the current position with the to be position.
            These are absolute values. Not relative to the previous position values.
          default: 0
          selector:
            number:
              min: 0.0
              max: 20.0
              unit_of_measurement: "%"

    tilt_position_section:
      name: "Cover Tilt Position Settings"
      icon: mdi:image-filter-tilt-shift
      collapsed: true
      input:
        cover_tilt_config:
          name: "üìê Tilt Position Feature"
          description: >-
            If the cover and the integration support it, the tilt position of the cover can be set. The standard attribute ‚Äòcurrent_tilt_position‚Äô is used for this.
            However, the ‚Äòcurrent_position‚Äô attribute is still used exclusively for the actual position detection in the blueprint.
          default: cover_tilt_disabled
          selector:
            select:
              options:
                - label: "‚úÖ Enable Tilt Position Control"
                  value: "cover_tilt_enabled"
                - label: "‚ùå Disable Tilt Position Control"
                  value: "cover_tilt_disabled"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        cover_tilt_reposition_config:
          name: "üìê Tilt Reposition Feature"
          description: >-
            If Tilt Position Feature is enabled you can choose if the blinds are closed before tilting to a new position.
            In some cases tilting the blinds in small steps can lead to false positions. This is because of the minimum time the motor needs to run.
            If the runtime between current tilt position and target tilt position is to small the motor will not stop at the right position.
            Thus the blinds will be preclosed to 0 and then run to the target position.
          default: cover_tilt_reposition_disabled
          selector:
            select:
              options:
                - label: "‚úÖ Enable Tilt Reposition Control"
                  value: "cover_tilt_reposition_enabled"
                - label: "‚ùå Disable Tilt Reposition Control"
                  value: "cover_tilt_reposition_disabled"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        open_tilt_position:
          name: "üîº Open Tilt Position"
          description: "To which tilt position should the cover be moved when opening?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        close_tilt_position:
          name: "üîª Close Tilt Position"
          description: "To which tilt position should the cover be moved when closing?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        ventilate_tilt_position:
          name: "üí® Ventilate Tilt Position"
          description: "To which tilt position should the cover be moved for ventilation?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_position_1:
          name: "ü•µ Sun Shading Tilt Position 1"
          description: "To which tilt position should the cover be moved for shading?"
          default: 20
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_1:
          name: "ü•µ Sun Shading Tilt Elevation 1"
          description: Sun elevationn for tilt position 1.
          default: 20
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0
        shading_tilt_position_2:
          name: "ü•µ Sun Shading Tilt Position 2"
          description: "To which tilt position should the cover be moved for shading?"
          default: 37
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_2:
          name: "ü•µ Sun Shading Tilt Elevation 2"
          description: Sun elevationn for tilt position 2.
          default: 30
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0
        shading_tilt_position_3:
          name: "ü•µ Sun Shading Tilt Position 3"
          description: "To which tilt position should the cover be moved for shading?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_3:
          name: "ü•µ Sun Shading Tilt Elevation 3"
          description: Sun elevationn for tilt position 3.
          default: 48
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0

    time_section:
      name: "Time Control Configuration"
      icon: mdi:clock-time-two-outline
      collapsed: true
      input:
        time_control:
          name: "‚è≤Ô∏è Selection of time control options"
          description: >-
            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>
            <br />
            <ins>Input fields for time control</ins><br />
            The times for opening and closing the cover are usually configured here in the blueprint.
            There are various input fields here for this purpose.
            Even if you only want to control the covers using brightness values or the sun elevation,
            it is important to specify times. The times are used to divide the day into "morning" (up) and "evening" (down).
            <br /><br />
            <ins>Schedule Helper</ins><br />
            However, you can also activate a scheduler helper mode at this point.
            This would allow you to configure a different time period for keeping the cover open for each day.
            Further information on this and the definition of the helper can be found below.
            <br /><br />
            <ins>Disable time control and all time triggers</ins><br />
            Finally, you can also deactivate the time control completely.
            This means that the roller shutters are not opened or closed via time triggers.
            The sun-elevation and brightness control then also runs completely independently.

            </details>

          default: time_control_input
          selector:
            select:
              options:
                - label: "‚úèÔ∏è Use the time input fields in this blueprint section"
                  value: "time_control_input"
                - label: "‚è≤Ô∏è Use an external schedule helper"
                  value: "time_control_schedule"
                - label: "üö´ Disable time control and all time triggers"
                  value: "time_control_disabled"
              sort: false
              multiple: false
              custom_value: false

        time_up_early:
          name: "üîº Time For Drive Up - Early On Workdays"
          description: >-
            The earliest time at which the cover may be opened. The cover will be opened if <ins>AFTER</ins> this time the defined brightness
            or sun-elevation value is high enough. (**NOTE**: A resident must also be awake if one is defined).
          default: "06:00:00"
          selector:
            time: {}

        time_up_early_non_workday:
          name: "üîº Time For Drive Up - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "07:00:00"
          selector:
            time: {}

        time_up_late:
          name: "üîº Time For Drive Up - Late On Workdays"
          description: >-
            The latest time at which the cover should be opened.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be opened.
            (**NOTE**: If a resident has been defined and the resident is still asleep, then the cover will NOT be opened.)
          default: "08:00:00"
          selector:
            time: {}

        time_up_late_non_workday:
          name: "üîº Time For Drive Up - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "08:00:00"
          selector:
            time: {}

        time_down_early:
          name: "üîª Time For Drive Down - Early On Workdays"
          description: >-
            The earliest time at which the cover may be closed.
            The cover will be closed if <ins>AFTER</ins> this time the defined brightness or sun-elevation value is low enough.
          default: "16:00:00"
          selector:
            time: {}

        time_down_early_non_workday:
          name: "üîª Time For Drive Down - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "16:00:00"
          selector:
            time: {}

        time_down_late:
          name: "üîª Time For Drive Down - Late On Workdays"
          description: >-
            The latest time at which the cover should be closed.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be closed.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

        time_down_late_non_workday:
          name: "üîª Time For Drive Down - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

        workday_sensor:
          name: "üíº Sensor For Workday Today"
          description: >-
            It may be desired to open a cover at a different time on work days than on non-work days.
            The corresponding binary sensor can be defined here. If not set, the cover will open every time at time_up_early.
            <br /><br />
            I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br />
            Example: `binary_sensor.workday_today`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        workday_sensor_tomorrow:
          name: "üíº Sensor For Workday Tomorrow (only for closing)"
          description: >-
            When <ins>closing</ins> the blinds, you have the option of checking the times for tomorrow rather than the current day.
            This has the advantage that you can <ins>close</ins> the blinds earlier if <ins>tomorrow</ins> is a working day.
            This makes sense if, for example, there is school tomorrow but today is actually still the weekend.
            But the child has to go to bed earlier.<br />
            If this field is not configured here, the normal working day sensor is used.
            <br /><br />
            I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br />
            Example: `binary_sensor.workday_tomorrow`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        time_schedule_helper:
          name: "‚è≤Ô∏è Cover driving time schedule helper"
          description: >-
            If enabled <em>"‚è≤Ô∏è Use an external schedule helper"</em> above, please select the schedule helper here.
            Of course, it is also important that the times in the helper are configured accordingly.
            Please create only one period in total. Example: Start at 08:00 and end at 22:00.
            The helper can be created [here](https://my.home-assistant.io/redirect/helpers/).
            <br /><br />`Optional`

            <details>
            <summary><code><strong>CLICK HERE:</strong> Important difference to the usual input fields</code></summary>
            <br />
            The behaviour when using the schedule Helper is different to the pure time input.

              - <ins>Without brightness or sun elevation control:</ins>
                As soon as the helper state is switched from <strong>OFF</strong> to <strong>ON</strong>, the cover is opened.
                The cover is closed when the helper state changes from <strong>ON</strong> to <strong>OFF</strong>.

              - <ins>With brightness or sun elevation control:</ins>
                The cover opens when the threshold is exceeded and the helper is <strong>ON</strong>.
                The cover closes when the level is below the threshold and the helper is <strong>ON</strong>, or when the schedule helper changes from <strong>ON</strong> to <strong>OFF</strong> (Latest time for closing the cover).

            Unfortunately, the HA core currently only has a 30-minute time grid for the time configuration.

            </details>
            <br />
            <details>
            <summary><code><strong>CLICK HERE:</strong> Important configuration instructions</code></summary>
            <br />
            It is not possible to find out more about the status of the schedule helper in Home Assistant.
            I never know whether we are at the beginning or end of the period.
            However, this is important to avoid bouncing when controlling the brightness, for example.
            In order to recognise whether we are still in the opening period or the closing period,
            it is necessary to enter a very rough time period in the time variables in the blueprint.
            <br /><br />
            <ins>Example:</ins>
            If the schedule helper goes to the "ON" status at 08:00 and to the "OFF" status at 18:00, it is sufficient to configure the times as follows:
            <br /><br />
            Time For Drive Up - Early: 06:00<br />
            Time For Drive Up - Late: 12:00<br /><br />
            Time For Drive Down - Early: 16:00<br />
            Time For Drive Down - Late: 22:00<br />
            <br />
            The times are not used for triggering, but only to divide the day into two halves!

            </details>

          default: []
          selector:
            entity:
              filter:
                - domain:
                    - schedule
              multiple: false

    brightness_section:
      name: "Brightness Configuration"
      description: >-
        <br />
        <center><code>Settings if the feature ‚ÄòüîÖ - Enable brightness control‚Äô has been activated above.</code></center><br />
      icon: mdi:brightness-5
      collapsed: true
      input:
        default_brightness_sensor:
          name: "üîÖ Default Brightness Sensor"
          description: "This default brightness sensor can be defined here, which is used for daily up and down."
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        brightness_time_duration:
          name: "üîÖ Brightness Time Duration"
          description: "Defines the time to given brightness sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        brightness_up:
          name: "üîÖ Brightness Value For Opening The Cover"
          description: "At what brightness value should the cover be opened?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        brightness_down:
          name: "üîÖ Brightness Value For Closing The Cover"
          description: "At what brightness value should the cover be closed? Must be lower then the brightness up value."
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

    sun_section:
      name: "Sun Elevation Settings"
      description: >-
        <br />
        <center><code>Settings if the feature ‚Äò‚òÄÔ∏è - Enable sun elevation control‚Äô has been activated above.</code></center><br />
      icon: mdi:weather-sunny
      collapsed: true
      input:
        default_sun_sensor:
          name: "‚òÄÔ∏è Sun Sensor"
          description: >-
            Which sensors provides attributes with current azimuth and elevation of sun.
            I strongly suggest to use sun.sun ([Sun integration](https://www.home-assistant.io/integrations/sun/)).
            Please make sure that the integration is activated and provides the attributes.
            This sensor is also used for sun protection / sunshade control.
            <br /><br />
            <ins>A few examples of threshold values:</ins>
            <ul>
            <li>+18¬∞ Astronomical Dusk</li>
            <li>+12¬∞ Nautical Dusk</li>
            <li>+6¬∞ Dusk</li>
            <li>0¬∞ Sunrise/Sunset</li>
            <li>-6¬∞ Civil Dawn</li>
            <li>-12¬∞ Nautical Dawn</li>
            <li>-18¬∞ Astronomical Dawn/Night</li>
            </ul>
            <br />`Optional` / `Shading`
          default: "sun.sun"
          selector:
            entity:
              filter:
                - domain:
                    - sun

        sun_time_duration:
          name: "‚òÄÔ∏è Sun Time Duration"
          description: "Defines the time to given sun sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        sun_elevation_up:
          name: "‚òÄÔ∏è Sun Elevation Value For Opening The Cover"
          description: "The cover will be <ins>opened</ins> if the sun elevation is over this value"
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        sun_elevation_down:
          name: "‚òÄÔ∏è Sun Elevation Value For Closing The Cover"
          description: "The cover will be <ins>closed</ins> if the sun elevation is under this value"
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

    contacts_section:
      name: "Contact Sensors for Ventilation"
      description: >-
        <br />
        <center><code>Settings if the feature ‚Äòüí® - Enable ventilation mode‚Äô has been activated above.</code></center><br />
        <center><code>All these settings are optional / A Cover Status Helper is required!</code></center><br />
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        contact_window_opened:
          name: "üö™ Contact Sensor For Open Window (Full Ventilation)"
          description: >-
            Contact sensor of a door or window handle for detecting <ins>total opening</ins>.
            If this sensor switches to on/true, the cover is <ins>fully opened</ins>.
            At the same time, a lockout protection is <ins>always</ins> activated.
            The cover is not closed and the sun shading is not activated when the contact is open.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor.
            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in both fields for the contact sensors. This does not work and leads to strange situations.

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

        contact_window_tilted:
          name: "üí® Contact Sensor For Tilted Window (Partial Ventilation)"
          description: >-
            The contact sensor is required for the <ins>partial</ins> ventilation mode.
            If the contact changes to on/true, the cover is moved to the <ins>ventilation</ins> position.
            The prerequisite is that the cover is already closed.
            After the status changes to off/false, the close position is activated again.
            The same applies in the shading-out situation.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor.
            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in both fields for the contact sensors. This does not work and leads to strange situations.

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

        lockout_tilted_options:
          name: "üí® Lockout protection for window tilted"
          description: >-
            For the tilted window (or door, of course), you can individually specify where a lockout protection should be used.
          default: []
          selector:
            select:
              options:
                - label: "üõ°Ô∏è Lockout protection when closing the cover"
                  value: "lockout_tilted_closing"
                - label: "üõ°Ô∏è Lockout protection when starting the sun shading"
                  value: "lockout_tilted_shading_start"
                - label: "üõ°Ô∏è Lockout protection when the sun shading is ended"
                  value: "lockout_tilted_shading_end"
              sort: false
              multiple: true
              custom_value: false

        auto_ventilate_options:
          name: "üí® Ventilation Configuration"
          description: >-
            Various different ventilation options.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


              - <ins>Use a delay in ventilation mode after closing the contact:</ins>
                <br />
                Normally, when the window contact is closed, there is no delay in the upcoming drives. If you do want this, you can activate it here.
                <br /><br />
                The "Fixed Drive Delay" and "Random Drive Delay" settings which are already used everywhere are then used.
                <br /><br />
              - <ins>Allow ventilation even if cover is already in a higher position:</ins>
                <br />
                Activate ventilation mode even if the current position of the cover is already higher than the ventilation position.
                <br /><br />
              - <ins>Using the ventilation position when the sun shade is ended:</ins>
                <br />
                The cover can also be moved to the ventilation position when the sun protection/sun shading is ended.
                Normally, the cover would be fully opened when the shading is ended.
                <br />
                To be honest, it makes no sense to switch to the ventilation position during the day if more air can flow in when the cover is open.

            </details>
          default: []
          selector:
            select:
              options:
                - label: "üí® Use a delay in ventilation mode after closing the contact"
                  value: "ventilation_delay_enabled"
                - label: "üí® Allow ventilation even if cover is already in a higher position"
                  value: "ventilation_if_lower_enabled"
                - label: "üí® Using the ventilation position when the sun shading is ended (instead of opening it completely)"
                  value: "ventilation_after_shading_end"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        contact_delay_trigger:
          name: "üïõ Contact Trigger Delay"
          description: "How many seconds must the status of the contact sensors be valid for the automation to trigger?"
          default: 2
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        contact_delay_status:
          name: "üïõ Contact Sensor Status Delay"
          description: >-
            How long should the automation wait until a trigger of a contact sensor becomes valid?
            This may be necessary if the status of a three-state sensor has an intermediate value for a short time.
          default: 3
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    shading_section:
      name: "Sun Shading / Sun Protection"
      description: >-
        <br />
        <center><code>Settings if the feature ‚Äòü•µ - Enable automatic sun protection / sunshade control‚Äô has been activated above.</code></center><br />
        <center><code>All these settings are optional / A Cover Status Helper is required! / The attributes of default sun sensor (configured above) is used.</code></center><br />
      icon: mdi:shield-sun-outline
      collapsed: true
      input:
        shading_brightness_sensor:
          name: "ü•µ Brightness Sensor For Sun Shading"
          description: "This sensor is only used for shading."
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_sun_brightness_start:
          name: "ü•µ Sun Shading Brightness Start Value"
          description: "The minimum brightness value from which shading should start. (Must be above the value of brightness end!)"
          default: 35000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_sun_brightness_end:
          name: "ü•µ Sun Shading Brightness End Value"
          description: "The brightness value from which shading is no longer necessary. (Must be below the value of brightness start!)."
          default: 25000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_azimuth_start:
          name: "ü•µ Sun Shading Azimuth Start Value"
          description: "What is the minimum azimuth at which the sun hits the window? (Shading will start)"
          default: 95
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_azimuth_end:
          name: "ü•µ Sun Shading Azimuth End Value"
          description: "What is the maximum azimuth at which the sun hits the window? (Shading will stop)"
          default: 265
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_elevation_min:
          name: "ü•µ Sun Shading Elevation Minimum Value"
          description: "Starting from which elevation of the sun should the window be shaded? (Here it makes sense to consider surrounding buildings, trees, etc.)."
          default: 25
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_elevation_max:
          name: "ü•µ Sun Shading Elevation Maximum Value"
          description: "What is the maximal elevation for elevation? (In most cases, 90 degrees is probably the most reasonable value. However, this can also be different due to surrounding buildings, etc.)."
          default: 90
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_temperatur_sensor1:
          name: "ü•µ Sun Shading Temperature Sensor 1 (eg. indoor)"
          description: "This is the main temperature sensor. (Here, for example, the current indoor temperature can be used as a condition)."
          selector:
            entity:
              filter:
                - domain:
                    - sensor
          default: []

        shading_min_temperatur1:
          name: "ü•µ Sun Shading Temperature Sensor 1 Minimum Value"
          description: "Minimum temperature for sensor 1 above which shading should occur."
          default: 18
          selector:
            number:
              min: 0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperature_hysteresis1:
          name: "ü•µ Sun Shading Temperature Sensor 1 Hysteresis Value"
          description: "Shading will end only when temperature drops below (minimum - hysteresis value) to prevent frequent open/close cycles."
          default: 0.2
          selector:
            number:
              min: 0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperatur_sensor2:
          name: "ü•µ Sun Shading Temperature Sensor 2 (eg. outdoor)"
          description: "This is a secondary temperature sensor. (Here, for example, the current outdoor temperature can be used as a condition). This sensor has another function. Please read the notes in the <ins>Sun Shading Forecast Temperature Value</ins> entry below."
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_min_temperatur2:
          name: "ü•µ Sun Shading Temperature Sensor 2 Minimum Value"
          description: "Minimum temperature for sensor 2 above which shading should occur."
          default: 18
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperature_hysteresis2:
          name: "ü•µ Sun Shading Temperature Sensor 2 Hysteresis Value"
          description: "Shading will end only when temperature drops below (minimum - hysteresis value) to prevent frequent open/close cycles."
          default: 0.2
          selector:
            number:
              min: 0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_forecast_sensor:
          name: "ü•µ Sun Shading (Forecast) Weather Sensor"
          description: >-
            This weather sensor (ideally based on a weather integration) is used for further temperature comparisons based on the forecast.
            This sensor is also used to compare weather conditions. Leave empty if the forecast is not to be used in any case.
            <p>
            Select either a weather entity (e.g., weather.your_weather_service)
            or a sensor that provides the forecasted daily maximum temperature.
            </p>
            <p>
            **Weather Entity:** If you select a weather entity, the maximum temperature
            will be automatically determined from its forecast attributes. This is necessary
            if your installed weather integration does not provide its own sensors for the forecast.
            </p>
            <p>
            **Sensor Entity:** If you already have your own sensor for the daily maximum
            temperature (forecast) (e.g., a template sensor), you can specify it directly here.
            This can improve performance and avoid unnecessary queries, as the value
            is read directly from the sensor. Such a sensor is provided, for example, by
            the Pirate Weather integration (sensor.pirateweather_daytime_high_apparent_temperature_0d).
            </p>
            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            The idea is that it can happen, especially in spring, that the value of the <em>Forecast Temperature Value</em> exceeded by
            strong solar radiation and the shading would be started.
            However, in spring you may not want shading, but the solar radiation as a welcome, free heating is desired.
            So you can define via the forecast sensor that shading is only started at an expected daily maximum temperature.

            You can also specify an existing sensor if it already provides the forecast for the maximum daily temperature. In this case set "Sun Shading Forecast Type" to "Do not use a weather forecast, but the current weather attributes".

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - weather
                    - sensor

        shading_forecast_type:
          name: "ü•µ Sun Shading Forecast Type"
          description: >-
            Please choose whether you want to use the daily forecast or the hourly forecast.
            <br />
            The first array member of the weather forecast is always used. This means the current day or the current hour.
            The weather sensor must support weather.get_forecasts which has been introduced with HA 2023.9.
            <br /><br />
            You also have the option of <ins>not using</ins> the weather <ins>forecast</ins> service here.
            The current attributes of the weather sensor are then used.
            <br />
            This is the successor to the old option: <em>Prevent the use of the 'get_forecasts' service</em>
          default: daily
          selector:
            select:
              options:
                - label: "Use the daily weather forecast service"
                  value: "daily"
                - label: "Use the hourly weather forecast service"
                  value: "hourly"
                - label: "Do not use a weather forecast, but the current weather attributes"
                  value: "weather_attributes"

        shading_forecast_temp:
          name: "ü•µ Sun Shading Forecast Temperature Value"
          description: >-
            This is the minimum temperature at which shading should be activated.
            When the forecasted temperature rises above this threshold, the shading mechanism will engage.
            There is a special feature when comparing the shading forecast temperature. Please continue reading!
            <br /><br />
            <details>
            <summary><code><strong>CLICK HERE:</strong> Special Feature</code></summary>

            To enhance the reliability of the shading response, the system includes a comparison mechanism.
            The forecasted shading temperature is evaluated against two temperature sensors to ensure optimal performance.
            <br /><br />
            <strong>Comparison Mechanism:</strong> The forecast value is evaluated in relation to:
            <br />- <ins>Shading Forecast Temperature Value (this input field)</ins>
            <br />- <ins>Shading Temperature Sensor 2 (e.g. outdoor)</ins>
            <br /><br />
            For shading to be triggered, it suffices for either of the two sensor values to exceed the
            configured shading forecast temperature value.
            There is no default temperature value here since February 2025.
            To <ins>not</ins> compare the forecast temperature, leave this field empty.
            <br /><br />
            <strong>Important Notes:</strong>
            Weather forecasts are not always accurate.
            Therefore, incorporating multiple temperature sensors allows for a more dependable reading before activating the shading system.

            </details>
          default: []
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_weather_conditions:
          name: "ü•µ Sun Shading Weather Conditions"
          description: >-
            Check the following weather conditions when activating the shading.
            **NOTE**: Forecast sensor needs to be defined
          default:
            - sunny
            - partlycloudy
            - cloudy
            - clear
          selector:
            select:
              multiple: true
              options:
                - "clear-night"
                - "clear"
                - "cloudy"
                - "fog"
                - "hail"
                - "lightning"
                - "lightning-rainy"
                - "partlycloudy"
                - "pouring"
                - "rainy"
                - "snowy"
                - "snowy-rainy"
                - "sunny"
                - "windy"
                - "windy-variant"
                - "exceptional"

        shading_waitingtime_start:
          name: "ü•µ Waiting Time For Sun Shading Start"
          description: >-
            To avoid overloading the motor, a waiting time can be defined here for the start of shading.
            The shade will then only start if <ins>all</ins> mandatory conditions are fulfilled for the entire waiting time.
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

        shading_start_behavior:
          name: "ü•µ Sun Shading Start Behavior"
          description: >-
            Behavior if the shading conditions were not permanently met over the period.
            <p>
            Option 1: Reset the detected shading start and wait for another trigger
            The system discards the current shading start detection and waits for a new valid trigger condition.
            </p><p>
            Option 2: Checks every few seconds, only during the day, as defined in 'Waiting Time for Sun Shading Start'
            The system continues to check periodically‚Äîevery few seconds during daytime‚Äîbased on the interval specified in the 'Waiting Time for Sun Shading Start' setting.
            However, this only applies if the shading conditions have changed negatively between the initial trigger (pending) and the next check (execution).
            </p>
          default: "trigger_periodic"
          selector:
            select:
              options:
                - label: "Reset the detected shading start and wait for another trigger"
                  value: "trigger_reset"
                - label: "Checks every few seconds, only during the day, as defined in 'Waiting Time for Sun Shading Start'"
                  value: "trigger_periodic"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        shading_waitingtime_end:
          name: "ü•µ Waiting Time For Sun Shading End"
          description: "To avoid excessive load on the motor, a waiting time can be defined here before the shading is ended. Shading ends if <ins>one</ins> of the conditions is <ins>not</ins> fulfilled for the entire waiting time."
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

        is_shading_end_immediate_by_sun_position:
          name: "ü•µ End Sun Shading Immediately When Out Of Range"
          description: >-
            If enabled, shading will end immediately (20 seconds later) when sun position moves outside the defined azimuth or elevation range.
            If disabled, the configured waiting time will be used before ending the shading.
          default: false
          selector:
            boolean: {}

        shading_end_behavior:
          name: "ü•µ Sun Shading End Behavior"
          description: >-
            Configure how the cover should behave when sun shading ends.
            Choose "Move to close position" for awnings to retract when shading ends.
          default: "open_position"
          selector:
            select:
              options:
                - label: "üîº Move to open position (default for blinds / roller shutters)"
                  value: "open_position"
                - label: "üîª Move to close position (for awnings)"
                  value: "close_position"
              multiple: false
              sort: false
              custom_value: false
              mode: list

    resident_section:
      name: "Resident Settings"
      description: >-
        <br />
        <center><code>
        (1) The purpose of resident mode is to the close the cover (without checking the defined times) when the resident sensor switches to ‚Äòon/true‚Äô. For example, when a resident goes to sleep.
        <br />
        (2) The cover will stay closed as long as the sensor remains in this state.
        <br />
        (3) When the resident sensor switches to ‚Äòoff/false‚Äô, the cover is automatically opened in the morning.
        <br />
        (4) In addition, the usual automatic opening of the cover is prevented as long as the sensor is set to ‚Äòon/true‚Äô or the resident.
        <br /><br />
        All these settings are optional.
        </code></center><br />
      icon: mdi:human-male-female
      collapsed: true
      input:
        resident_sensor:
          name: "üõå Resident Sensor"
          description: "You can use this to define a resident (input_boolean or binary_sensor) for the room"
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        resident_config:
          name: "üõå Resident Configuration"
          description: "Additional configuration options"
          default: []
          selector:
            select:
              options:
                - label: "üîº Open the cover immediately when the sensor goes to 'off/false'?"
                  value: "resident_opening_enabled"
                - label: "üîª Close the cover immediately when the sensor goes to 'on/true'?"
                  value: "resident_closing_enabled"
                - label: "ü•µ Allow sun protection when resident is still present"
                  value: "resident_allow_shading"
                - label: "üîº Allow opening the cover when resident is still present"
                  value: "resident_allow_opening"
                - label: "üí® Allow ventilation when resident is still present"
                  value: "resident_allow_ventilation"
              multiple: true
              sort: false
              custom_value: false
              mode: list

    override_section:
      name: "Manual Override"
      description: >-
        <br />
        <center><code>A Cover Status Helper is required!</code></center><br />
      icon: mdi:debug-step-over
      collapsed: true
      input:
        ignore_after_manual_config:
          name: "üñêÔ∏è Ignoring/override after manual position changes"
          description: >-
            Ignore or override the following actions after manual position changes.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            Ultimately, this means that the cover will not be opened, closed, etc.
            if a manual interaction has previously been made, e.g. using a wall switch.


            The reason behind this is that the human being wins with his decision and his
            conscious decision is weighted higher than the upcoming action of the automation.


            As soon as a cover has been moved manually, the status is recorded in the Cover Status Helper.
            This usually means that a person has deliberately decided against a status.

              - If option is not activated: The covers are moved even if a manual correction has been made.
              - If option is activated: The action to open, close, etc. is not performed because a conscious decision was made to do otherwise due to a manual intervention.


            A Cover Status Helper is required!

            </details>

          default: []
          selector:
            select:
              options:
                - label: "üîº Ignore/override next automatic opening after manual position changes"
                  value: "ignore_opening_after_manual"
                - label: "üîª Ignore/override next automatic closing after manual position changes"
                  value: "ignore_closing_after_manual"
                - label: "üí® Ignore/override next automatic ventilation after manual position changes"
                  value: "ignore_ventilation_after_manual"
                - label: "ü•µ Ignore/override next automatic sun shading after manual position changes"
                  value: "ignore_shading_after_manual"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        reset_override_config:
          name: "üóëÔ∏è Reset manual override"
          description: >-
            If the detection of the manual position change was activated above, you may need a way to reset this status.
            Otherwise, the next cover movements will be permanently ignored or overridden.
            Or you have not activated an individual action, e.g. when closing the covers, which resets the status.
          default: reset_disabled
          selector:
            select:
              options:
                - label: "No timed reset for manual override"
                  value: "reset_disabled"
                - label: "Reset at a specified time (see below)"
                  value: "reset_fixed_time"
                - label: "Reset after a timeout in minutes (see below)"
                  value: "reset_timeout"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        reset_override_time:
          name: "üóëÔ∏è Time to reset manual override"
          description: "At what time do you want the manual detection to be reset?"
          default: "00:01:00"
          selector:
            time: {}

        reset_override_timeout:
          name: "üóëÔ∏è Number of minutes until reset manual override"
          description: "After how many minutes should it be reset?"
          default: 5
          selector:
            number:
              min: 0
              max: 1440
              unit_of_measurement: minutes

    delay_section:
      description: >-
        <br />
        <center><code>Take into account that, for example, waiting times are added when brightness changes or shading is started. It is therefore better to use smaller values here. It is only a matter of separating the different covers in terms of time.</code></center><br />
      name: "Delay Settings"
      icon: mdi:timer-outline
      collapsed: true
      input:
        drive_delay_fix:
          name: "üïõ Fixed Drive Delay"
          description: >-
            Fixed drive delay to avoid radio interferences.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        drive_delay_random:
          name: "üïõ Random Drive Delay"
          description: >-
            Additional random delay.
            <br /><br />`Optional`
          default: 5
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        tilt_delay:
          name: "üïõ Tilt Delay"
          description: >-
            Delay between <em>set_cover_position</em> and <em>set_cover_tilt_position</em>.
            Only necessary when using the tilt functions.
            This separates the two commands in terms of time.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    condition_section:
      name: "Additional Conditions"
      description: >-
        <br />
        <center><code>All these settings are optional</code></center><br />
      icon: mdi:help-rhombus-outline
      collapsed: true
      input:
        auto_global_condition:
          name: "‚ùì Additional Condition for the entire automation"
          description: >-
            This condition allows you to control the execution of the <ins>entire</ins> automation dynamically and outside of the blueprint configuration.
            With this option you could enable a party mode.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
            <br /><br />
            Forcing Open/Close/Shading/Ventilation is therefore only possible if this condition remains empty or becomes valid.
          default: []
          selector:
            condition: {}

        auto_up_condition:
          name: "üîº Additional Condition For Opening The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>opening</ins> of the cover.
            You can use this, for example, if the covers normally don't open, but you really want to do it on vacation.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_down_condition:
          name: "üîª Additional Condition For Closing The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>closing</ins> of the cover.
            You can use this, for example, at Christmas time or if you want the covers to behave differently while on vacation.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_ventilate_condition:
          name: "üí® Additional Condition For Activating Ventilation"
          description: >-
            This condition can be used to dynamically control the <ins>start of the ventilation</ins> of the cover.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_ventilate_end_condition:
          name: "üí® Additional Condition For Disabling Ventilation"
          description: >-
            This condition can be used to dynamically control the <ins>end of the ventilation</ins> of the cover.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_shading_start_condition:
          name: "ü•µ Additional Condition When Activating Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-IN-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
            <br />
            Another example: Here you could also set that the shading is only triggered in the summer season.
          default: []
          selector:
            condition: {}

        auto_shading_tilt_condition:
          name: "ü•µ Additional Condition For Sun Shading Tilt"
          description: >-
            This condition can be used to dynamically control the <ins>shading_tilt-IN-automation</ins>
            of the cover. This can be useful if you want to temporarily disable automation
            (e.g. because of control by other automations). <br /> Another example:
            Here you could also set that the tilting is only triggered in the summer season.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_shading_end_condition:
          name: "ü•µ Additional Condition When Deactivating  Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-OUT-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

    force_section:
      name: "Force Features"
      description: >-
        <br />
        This can be used for the following purposes under certain circumstances: Antifreeze, RainProtection or WindProtection.
        <br /><br />
        Note:
          - However, after forcing a state, you must ensure that you move to the correct target position yourself. You are responsible for getting CCA back on track.
          - This cannot be performed in CCA and must therefore be done via a separate automation. Presumably in the same automation that sets the "Force"-boolean. It is sufficient, by the way, if a configured position is targeted. CCA then recognises the status.
          - Force is a final state that cannot be cancelled or resetted by CCA.
          - The default automations (open, close, and further) will never be able to override a force. The force feature must therefore be cancelled manually beforehand.
        <br /><br />

        <center><code>All these settings are optional</code></center><br />
      icon: mdi:arm-flex
      collapsed: true
      input:
        auto_up_force:
          name: "üîº Force Immediate Opening via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is opened immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_down_force:
          name: "üîª Force Immediate Closing via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is closed immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_ventilate_force:
          name: "üí® Force Immediate Ventilation via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is immediately set to ventilation mode and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_shading_start_force:
          name: "ü•µ Force Activation Sun Shading via Entity"
          description: >-
            If the status of this entity changes to on or true, the shading is immediately activated and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

    actions_section:
      name: "Additional Actions"
      description: >-
        <br />
        <center><code>All these settings are optional</code></center><br />
      icon: mdi:run
      collapsed: true
      input:
        auto_up_action_before:
          name: "üîº Additional Actions Before Opening The Cover"
          description: "Additional actions to run <ins>before</ins> opening the cover"
          default: []
          selector:
            action: {}

        auto_up_action:
          name: "üîº Additional Actions After Opening The Cover"
          description: "Additional actions to run <ins>after</ins> opening the cover"
          default: []
          selector:
            action: {}

        auto_down_action_before:
          name: "üîª Additional Actions Before Closing The Cover"
          description: "Additional actions to run <ins>before</ins> closing the cover"
          default: []
          selector:
            action: {}

        auto_down_action:
          name: "üîª Additional Actions After Closing The Cover"
          description: "Additional actions to run <ins>after</ins> closing the cover"
          default: []
          selector:
            action: {}

        auto_ventilate_action_before:
          name: "üí® Additional Actions Before Ventilating The Cover"
          description: "Additional actions to run <ins>before</ins> ventilating the cover"
          default: []
          selector:
            action: {}

        auto_ventilate_action:
          name: "üí® Additional Actions After Ventilating The Cover"
          description: "Additional actions to run <ins>after</ins> ventilating the cover"
          default: []
          selector:
            action: {}

        auto_shading_start_action_before:
          name: "ü•µ Additional Actions Before Activating Sun Shading"
          description: "Additional actions to run <ins>before</ins> activating sun shading"
          default: []
          selector:
            action: {}

        auto_shading_start_action:
          name: "ü•µ Additional Actions After Activating Sun Shading"
          description: "Additional actions to run <ins>after</ins> activating sun shading"
          default: []
          selector:
            action: {}

        auto_shading_end_action_before:
          name: "ü•µ Additional Actions Before Disabling Sun Shading"
          description: "Additional actions to run <ins>before</ins> disabling sun shading"
          default: []
          selector:
            action: {}

        auto_shading_end_action:
          name: "ü•µ Additional Actions After Disabling Sun Shading"
          description: "Additional actions to run <ins>after</ins> disabling sun shading"
          default: []
          selector:
            action: {}

        auto_manual_action:
          name: "üñêÔ∏è Additional Actions After Manual Change"
          description: "Additional actions after a manual change to the covers"
          default: []
          selector:
            action: {}

        auto_override_reset_action:
          name: "üóëÔ∏è Additional Actions After Override Reset"
          description: "Additional actions to be taken after resetting the manual override"
          default: []
          selector:
            action: {}

    configcheck_section:
      name: "Configuration Check"
      icon: mdi:invoice-text-check-outline
      collapsed: true
      input:
        check_config:
          name: "‚úîÔ∏è Check Configuration"
          description: >-
            With this boolean, you can enable or disable the basic plausibility check for the configuration.
            The check only takes place if the automation is executed manually.
          default: false
          selector:
            boolean: {}

        check_config_debuglevel:
          name: "‚úîÔ∏è Check Configuration - Debug level"
          description: >-
            Choose the debug level for Syslog messages in case of configuration issues
            <br />
            Please make sure that it suits your Home Assistant logger default level.
          default: "info"
          selector:
            select:
              multiple: false
              mode: dropdown
              options:
                - "critical"
                - "debug"
                - "error"
                - "info"
                - "warning"

################################################################################
# TRIGGER VARIABLES
################################################################################

trigger_variables:
  blind: !input blind

  # Positions
  open_position: !input open_position
  close_position: !input close_position
  ventilate_position: !input ventilate_position
  shading_position: !input shading_position
  position_tolerance: !input position_tolerance

  # Tilt
  open_tilt_position: !input open_tilt_position
  close_tilt_position: !input close_tilt_position
  ventilate_tilt_position: !input ventilate_tilt_position
  shading_tilt_elevation_1: !input shading_tilt_elevation_1
  shading_tilt_elevation_2: !input shading_tilt_elevation_2
  shading_tilt_elevation_3: !input shading_tilt_elevation_3
  shading_tilt_position_1: !input shading_tilt_position_1
  shading_tilt_position_2: !input shading_tilt_position_2
  shading_tilt_position_3: !input shading_tilt_position_3

  # Modes
  auto_options: !input auto_options

  # Times
  time_up_early: !input time_up_early
  time_up_early_non_workday: !input time_up_early_non_workday
  time_up_late: !input time_up_late
  time_up_late_non_workday: !input time_up_late_non_workday
  time_down_early: !input time_down_early
  time_down_early_non_workday: !input time_down_early_non_workday
  time_down_late: !input time_down_late
  time_down_late_non_workday: !input time_down_late_non_workday
  workday_sensor_today: !input workday_sensor
  workday_sensor_tomorrow: !input workday_sensor_tomorrow

  # Brightness
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down

  # Sun
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down

  # Sensors
  resident_sensor: !input resident_sensor
  contact_window_tilted: !input contact_window_tilted
  contact_window_opened: !input contact_window_opened
  lockout_tilted_options: !input lockout_tilted_options
  lockout_tilted_when_closing: "{{ 'lockout_tilted_closing' in lockout_tilted_options }}"
  lockout_tilted_when_shading_starts: "{{ 'lockout_tilted_shading_start' in lockout_tilted_options }}"
  lockout_tilted_when_shading_ends: "{{ 'lockout_tilted_shading_end' in lockout_tilted_options }}"

  # Time controls
  time_control: !input time_control
  time_schedule_helper: !input time_schedule_helper

  # Shading
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_temperature_hysteresis1: !input shading_temperature_hysteresis1
  shading_temperature_hysteresis2: !input shading_temperature_hysteresis2
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_forecast_type: !input shading_forecast_type
  shading_forecast_temp: !input shading_forecast_temp
  shading_weather_conditions: !input shading_weather_conditions

  # Internal code helper
  is_shading_enabled: "{{ 'auto_shading_enabled' in auto_options }}"
  cover_tilt_config: !input cover_tilt_config
  is_cover_tilt_enabled: "{{ 'cover_tilt_enabled' in cover_tilt_config }}"
  is_up_enabled: "{{ 'auto_up_enabled' in auto_options }}"
  is_down_enabled: "{{ 'auto_down_enabled' in auto_options }}"
  is_brightness_enabled: "{{ 'auto_brightness_enabled' in auto_options }}"
  is_sun_elevation_enabled: "{{ 'auto_sun_enabled' in auto_options }}"
  is_ventilation_enabled: "{{ 'auto_ventilate_enabled' in auto_options }}"
  is_time_field_enabled: "{{ 'time_control_input' in time_control }}"
  is_schedule_helper_enabled: "{{ 'time_control_schedule' in time_control and time_schedule_helper != [] }}"
  is_time_control_disabled: "{{ 'time_control_disabled' in time_control }}"

  reset_override_config: !input reset_override_config
  reset_override_time: !input reset_override_time
  reset_override_timeout: !input reset_override_timeout
  is_reset_disabled: "{{ 'reset_disabled' in reset_override_config }}"
  is_reset_fixed_time: "{{ 'reset_fixed_time' in reset_override_config }}"
  is_reset_timeout: "{{ 'reset_timeout' in reset_override_config }}"

  cover_status_options: !input cover_status_options
  cover_status_helper: !input cover_status_helper

################################################################################
# VARIABLES
################################################################################

variables:
  version: "2025.06.13"

  blind_entities: "{{ expand(blind) | map(attribute='entity_id') | list }}"
  current_position: "{{ state_attr(blind, 'current_position') | int(default=101) }}"
  current_tilt_position: "{{ state_attr(blind,'current_tilt_position') | int(default=101) }}"
  current_sun_azimuth: "{{ state_attr(default_sun_sensor, 'azimuth') }}"
  current_sun_elevation: "{{ state_attr(default_sun_sensor, 'elevation') }}"
  is_today_off: "{{ is_state(workday_sensor_today, 'off') }}"
  is_tomorrow_off: "{{ is_state(workday_sensor_tomorrow, 'off') }}"
  is_tomorrow_on: "{{ is_state(workday_sensor_tomorrow, 'on') }}"

  # Delays
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time

  time_up_early_today: "{{ time_up_early_non_workday if is_today_off else time_up_early }}"
  time_up_late_today: "{{ time_up_late_non_workday if is_today_off else time_up_late }}"
  time_down_early_today: >-
    {{
      time_down_early_non_workday if is_tomorrow_off else
      time_down_early if is_tomorrow_on else
      time_down_early_non_workday if is_today_off else
      time_down_early
    }}
  time_down_late_today: >-
    {{
      time_down_late_non_workday if is_tomorrow_off else
      time_down_late if is_tomorrow_on else
      time_down_late_non_workday if is_today_off else
      time_down_late
    }}

  # Force
  auto_up_force: !input auto_up_force
  auto_down_force: !input auto_down_force
  auto_ventilate_force: !input auto_ventilate_force
  auto_shading_start_force: !input auto_shading_start_force
  auto_up_force_disabled: "{{ auto_up_force == [] or (auto_up_force != [] and states(auto_up_force) in ['false', 'off']) }}"
  auto_down_force_disabled: "{{ auto_down_force == [] or (auto_down_force != [] and states(auto_down_force) in ['false', 'off']) }}"
  auto_ventilate_force_disabled: "{{ auto_ventilate_force == [] or (auto_ventilate_force != [] and states(auto_ventilate_force) in ['false', 'off']) }}"
  auto_shading_start_force_disabled: "{{ auto_shading_start_force == [] or (auto_shading_start_force != [] and states(auto_shading_start_force) in ['false', 'off']) }}"

  # Tilt
  is_cover_tilt_enabled_and_possible: "{{ is_cover_tilt_enabled and state_attr(blind, 'current_tilt_position') != none }}"
  cover_tilt_reposition_config: !input cover_tilt_reposition_config
  is_cover_tilt_reposition_enabled: "{{ 'cover_tilt_reposition_enabled' in cover_tilt_reposition_config }}"

  # Shading
  shading_tilt_position: >-
    {% set elevation = current_sun_elevation | int(default=0) %}
    {% if elevation >= shading_tilt_elevation_3 | int %}
      {{ shading_tilt_position_3 | int }}
    {% elif elevation >= shading_tilt_elevation_2 | int %}
      {{ shading_tilt_position_2 | int }}
    {% elif elevation >= shading_tilt_elevation_1 | int %}
      {{ shading_tilt_position_1 | int }}
    {% else %}
      {{ 0 | int }}
    {% endif %}

  shading_waitingtime_start: !input shading_waitingtime_start
  shading_waitingtime_end: !input shading_waitingtime_end
  is_shading_end_immediate_by_sun_position: !input is_shading_end_immediate_by_sun_position
  shading_start_behavior: !input shading_start_behavior
  shading_end_behavior: !input shading_end_behavior
  start_shading_trigger_reset: "{{ 'trigger_reset' in shading_start_behavior }}"
  start_shading_trigger_periodic: "{{ 'trigger_periodic' in shading_start_behavior }}"

  is_status_helper_enabled: >-
    {{
      'cover_helper_enabled' in cover_status_options and
      cover_status_helper != [] and
      states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none', []] and
      states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)")
    }}

  helper_state_json: >
    {% if is_status_helper_enabled %}
      {{ states(cover_status_helper) | from_json }}
    {% else %}
      {{
        {
          'open': {'a': 0, 't': 0},
          'close': {'a': 0, 't': 0},
          'shading': {'a': 0, 't': 0, 'p': 0, 'q': 0},
          'vpart': {'a': 0, 't': 0},
          'vfull': {'a': 0, 't': 0},
          'manual': {'a': 0, 't': 0},
          'v': 5,
          't': as_timestamp(now()) | round(0)
        } | to_json | from_json
      }}
    {% endif %}

  # Cover status assignments
  is_helper_open: "{{ is_status_helper_enabled and (helper_state_json | regex_search('open')) and (helper_state_json.open.a | default(false) | bool) }}"
  is_helper_closed: "{{ is_status_helper_enabled and (helper_state_json | regex_search('close')) and (helper_state_json.close.a | default(false) | bool) }}"
  is_helper_shaded: >-
    {{
      'shading' in helper_state_json and
      helper_state_json.shading.a | default(false) | bool and
      not (helper_state_json.shading.p | default(false) | bool and
          helper_state_json.shading.q | default(false) | bool)
    }}
  is_helper_shading_start: "{{ is_status_helper_enabled and (helper_state_json | regex_search('shading')) and (helper_state_json.shading.p | default(false) | bool) }}"
  is_helper_shading_end: "{{ is_status_helper_enabled and (helper_state_json | regex_search('shading')) and (helper_state_json.shading.q | default(false) | bool) }}"
  is_helper_vent_partial: "{{ is_status_helper_enabled and (helper_state_json | regex_search('vpart')) and (helper_state_json.vpart.a | default(false) | bool) }}"
  is_helper_vent_full: "{{ is_status_helper_enabled and (helper_state_json | regex_search('vfull')) and (helper_state_json.vfull.a | default(false) | bool) }}"
  is_helper_manual: "{{ is_status_helper_enabled and (helper_state_json | regex_search('manual')) and (helper_state_json.manual.a | default(false) | bool) }}"

  ts_helper_open: "{{ helper_state_json.open.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('open'))) else 0 }}"
  ts_helper_closed: "{{ helper_state_json.close.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('close'))) else 0 }}"
  ts_helper_shaded: "{{ helper_state_json.shading.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('shading'))) else 0 }}"
  ts_helper_vent_partial: "{{ helper_state_json.vpart.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('vpart'))) else 0 }}"
  ts_helper_vent_full: "{{ helper_state_json.vfull.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('vfull'))) else 0 }}"
  ts_helper_manual: "{{ helper_state_json.manual.t | default(0) if (is_status_helper_enabled and (helper_state_json | regex_search('manual'))) else 0 }}"

  in_open_position: >-
    {% set min = open_position - position_tolerance %}
    {% set max = open_position + position_tolerance %}
    {{
      (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible)
        or (is_cover_tilt_enabled_and_possible and current_tilt_position == open_tilt_position)
      )
    }}

  in_close_position: >-
    {% set min = close_position - position_tolerance %}
    {% set max = close_position + position_tolerance %}
    {{
      (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible)
        or (is_cover_tilt_enabled_and_possible and current_tilt_position == close_tilt_position)
      )
    }}

  in_shading_position: >-
    {% set min = shading_position - position_tolerance %}
    {% set max = shading_position + position_tolerance %}
    {{
      is_shading_enabled
      and (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible)
        or (current_tilt_position == shading_tilt_position)
      )
    }}

  in_ventilate_position: >-
    {% set min = ventilate_position - position_tolerance %}
    {% set max = ventilate_position + position_tolerance %}
    {{
      is_ventilation_enabled
      and (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible)
        or (current_tilt_position ==  ventilate_tilt_position)
      )
    }}

  individual_config: !input individual_config
  prevent_higher_position_closing: "{{ 'prevent_higher_position_closing' in individual_config }}"
  prevent_lowering_when_closing_if_shaded: "{{ 'prevent_lowering_when_closing_if_shaded' in individual_config }}"
  prevent_forecast_service: "{{ 'weather_attributes' in shading_forecast_type }}"
  prevent_shading_end_if_closed: "{{ 'prevent_shading_end_if_closed' in individual_config }}"
  prevent_opening_after_shading_end: "{{ 'prevent_opening_after_shading_end' in individual_config }}"
  prevent_opening_after_ventilation_end: "{{ 'prevent_opening_after_ventilation_end' in individual_config }}"
  prevent_default_cover_actions: "{{ 'prevent_default_cover_actions' in individual_config }}"
  prevent_shading_multiple_times: "{{ 'prevent_shading_multiple_times' in individual_config }}"
  prevent_opening_multiple_times: "{{ 'prevent_opening_multiple_times' in individual_config }}"
  prevent_closing_multiple_times: "{{ 'prevent_closing_multiple_times' in individual_config }}"

  resident_config: !input resident_config
  resident_opening_enabled: "{{ 'resident_opening_enabled' in resident_config }}"
  resident_closing_enabled: "{{ 'resident_closing_enabled' in resident_config }}"
  resident_allow_shading: "{{ 'resident_allow_shading' in resident_config }}"
  resident_allow_opening: "{{ 'resident_allow_opening' in resident_config }}"
  resident_allow_ventilation: "{{ 'resident_allow_ventilation' in resident_config }}"

  ignore_after_manual_config: !input ignore_after_manual_config
  override_opening_after_manual: "{{ 'ignore_opening_after_manual' in ignore_after_manual_config }}"
  override_closing_after_manual: "{{ 'ignore_closing_after_manual' in ignore_after_manual_config }}"
  override_ventilation_after_manual: "{{ 'ignore_ventilation_after_manual' in ignore_after_manual_config }}"
  override_shading_after_manual: "{{ 'ignore_shading_after_manual' in ignore_after_manual_config }}"

  auto_ventilate_options: !input auto_ventilate_options
  ventilation_delay_enabled: "{{ 'ventilation_delay_enabled' in auto_ventilate_options }}"
  ventilation_if_lower_enabled: "{{ 'ventilation_if_lower_enabled' in auto_ventilate_options }}"
  ventilation_after_shading_end: "{{ 'ventilation_after_shading_end' in auto_ventilate_options }}"

  # Config check
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel
  check_status_helper_length: "{{ state_attr(cover_status_helper, 'max') if is_status_helper_enabled else None }}"

mode: single
max_exceeded: silent

################################################################################
# TRIGGERS
################################################################################

triggers:

  ########################################
  # Trigger for opening cover
  ########################################

  - platform: template
    value_template: >-
      {% set is_today_off = is_state(workday_sensor_today, 'off') %}
      {% set time_compare = time_up_early_non_workday if is_today_off else time_up_early %}
      {{ now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_open_1"

  - platform: template # comparing the times to avoid double triggering if early+late are identical
    value_template: >-
      {% set is_today_off = is_state(workday_sensor_today, 'off') %}
      {% set early = time_up_early_non_workday if is_today_off else time_up_early %}
      {% set late = time_up_late_non_workday if is_today_off else time_up_late %}
      {{ early != late and now() >= today_at(late) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_open_2"

  - platform: template
    value_template: "{{ is_state(time_schedule_helper, ['true', 'on']) }}"
    enabled: "{{ is_schedule_helper_enabled and time_schedule_helper != [] }}"
    id: "t_open_3"

  - platform: template
    value_template: "{{ states(default_brightness_sensor) | float(default=brightness_up) > brightness_up }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_open_4"

  - platform: template
    value_template: "{{ state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_up) > sun_elevation_up }}"
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_open_5"

  - platform: state
    entity_id: !input resident_sensor
    from: "on"
    to: "off"
    id: "t_open_6"

  - platform: state
    entity_id: !input auto_up_force
    from: "off"
    to: "on"
    id: "t_force_open"

  ########################################
  # Trigger for closing cover
  ########################################

  - platform: template
    value_template: >-
      {% set is_tomorrow_off = is_state(workday_sensor_tomorrow, 'off') %}
      {% set is_tomorrow_on = is_state(workday_sensor_tomorrow, 'on') %}
      {% set is_today_off = is_state(workday_sensor_today, 'off') %}
      {% set time_compare =
        time_down_early_non_workday if is_tomorrow_off else
        time_down_early if is_tomorrow_on else
        time_down_early_non_workday if is_today_off else
        time_down_early %}
      {{ now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_close_1"

  - platform: template # Avoid double triggering with 'early != late' if early and late times are identical
    value_template: >-
      {% set is_tomorrow_off = is_state(workday_sensor_tomorrow, 'off') %}
      {% set is_tomorrow_on = is_state(workday_sensor_tomorrow, 'on') %}
      {% set is_today_off = is_state(workday_sensor_today, 'off') %}
      {% set time_compare =
        time_down_late_non_workday if is_tomorrow_off else
        time_down_late if is_tomorrow_on else
        time_down_late_non_workday if is_today_off else
        time_down_late %}
      {{ (time_down_early_non_workday != time_compare and time_down_early != time_compare) and now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_close_2"

  - platform: template
    value_template: "{{ states(time_schedule_helper) in ['false', 'off'] }}"
    enabled: "{{ is_schedule_helper_enabled and time_schedule_helper != [] }}"
    id: "t_close_3"

  - platform: template
    value_template: "{{ states(default_brightness_sensor) | float(default=brightness_down) < brightness_down }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_close_4"

  - platform: template
    value_template: "{{ state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_down) < sun_elevation_down }}"
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_close_5"

  - platform: state
    entity_id: !input resident_sensor
    from: "off"
    to: "on"
    id: "t_close_6"

  - platform: state
    entity_id: !input auto_down_force
    from: "off"
    to: "on"
    id: "t_force_close"

  #################################################
  # Trigger for ventilation
  #################################################

  - platform: template
    value_template: "{{ states(contact_window_tilted) in ['true', 'on'] }}"
    enabled: "{{ is_ventilation_enabled and contact_window_tilted != [] }}"
    id: "t_contact_tilted_on"
    for:
      seconds: !input contact_delay_trigger

  - platform: template
    value_template: "{{ states(contact_window_tilted) in ['false', 'off'] }}"
    enabled: "{{ is_ventilation_enabled and contact_window_tilted != [] }}"
    id: "t_contact_tilted_off"
    for:
      seconds: !input contact_delay_trigger

  - platform: template
    value_template: "{{ states(contact_window_opened) in ['true', 'on'] }}"
    enabled: "{{ is_ventilation_enabled and contact_window_opened != [] }}"
    id: "t_contact_opened_on"
    for:
      seconds: !input contact_delay_trigger

  - platform: template
    value_template: "{{ states(contact_window_opened) in ['false', 'off'] }}"
    enabled: "{{ is_ventilation_enabled and contact_window_opened != [] }}"
    id: "t_contact_opened_off"
    for:
      seconds: !input contact_delay_trigger

  - platform: state
    entity_id: !input auto_ventilate_force
    from: "off"
    to: "on"
    id: "t_force_vent"

  ########################################
  # Triggers for shading start
  ########################################
  - platform: template
    value_template: >-
      {{
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start) > shading_azimuth_start and
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) < shading_azimuth_end and
        state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) > shading_elevation_min and
        state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) < shading_elevation_max
      }}
    enabled: "{{ is_shading_enabled and default_sun_sensor != [] }}"
    id: "t_shading_start_pending_1"

  - platform: template
    value_template: "{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > shading_sun_brightness_start }}"
    enabled: "{{ is_shading_enabled and shading_brightness_sensor != [] }}"
    id: "t_shading_start_pending_2"

  - platform: template
    value_template: "{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > shading_min_temperatur1 }}"
    enabled: "{{ is_shading_enabled and shading_temperatur_sensor1 != [] }}"
    id: "t_shading_start_pending_3"

  - platform: template
    value_template: "{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > shading_min_temperatur2 }}"
    enabled: "{{ is_shading_enabled and shading_temperatur_sensor2 != [] }}"
    id: "t_shading_start_pending_4"

  - platform: template
    value_template: "{{ states(shading_forecast_sensor) in shading_weather_conditions }}"
    enabled: "{{ is_shading_enabled and shading_forecast_sensor != [] }}"
    id: "t_shading_start_pending_5"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none', []] and
        states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        states(cover_status_helper)|from_json|regex_search('shading') and
        (states(cover_status_helper)|from_json).shading.p is defined and
        (states(cover_status_helper)|from_json).shading.p > 0 and
        now() >= ( (states(cover_status_helper)|from_json).shading.p) | as_datetime | as_local
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] }}"
    id: "t_shading_start_execution"

  - platform: state
    entity_id: !input auto_shading_start_force
    from: "off"
    to: "on"
    id: "t_force_shading_start"

  ########################################
  # Triggers for shading tilt
  ########################################

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_1
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: t_shading_tilt_1

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_2 and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_1
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: t_shading_tilt_2

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_3 and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_2
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: t_shading_tilt_3

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_3
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: t_shading_tilt_4

  ########################################
  # Triggers for shading end
  ########################################

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"p"\s*:\s*0') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"q"\s*:\s*0') and
        states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) < (shading_min_temperatur1 - shading_temperature_hysteresis1)
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_temperatur_sensor1 != [] }}"
    id: "t_shading_end_pending_1"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"p"\s*:\s*0') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"q"\s*:\s*0') and
        states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) < (shading_min_temperatur2 - shading_temperature_hysteresis2)
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_temperatur_sensor2 != [] }}"
    id: "t_shading_end_pending_2"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"p"\s*:\s*0') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"q"\s*:\s*0') and
        states(shading_brightness_sensor) | float(default=shading_sun_brightness_end) < shading_sun_brightness_end
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_brightness_sensor != [] }}"
    id: "t_shading_end_pending_3"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"p"\s*:\s*0') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"q"\s*:\s*0') and
        states(shading_forecast_sensor) not in shading_weather_conditions
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_weather_conditions != [] and shading_forecast_sensor != [] }}"
    id: "t_shading_end_pending_4"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none'] and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"p"\s*:\s*0') and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"q"\s*:\s*0') and
        (
          (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) > shading_azimuth_end) or
          (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) > shading_elevation_max) or
          (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) < shading_elevation_min)
        )
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and default_sun_sensor != [] }}"
    id: "t_shading_end_pending_5"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none', []] and
        states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        states(cover_status_helper)|from_json|regex_search('shading') and
        (states(cover_status_helper)|from_json).shading.q is defined and
        (states(cover_status_helper)|from_json).shading.q > 0 and
        now() >= ( (states(cover_status_helper)|from_json).shading.q) | as_datetime | as_local
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] }}"
    id: "t_shading_end_execution"

  - platform: template
    value_template: "{{ now() >= today_at('23:55:00') }}"
    id: "t_shading_reset"
    enabled: "{{ is_shading_enabled }}"

  ########################################
  # Trigger for manual cover controls
  ########################################

  - platform: state
    entity_id: !input blind
    attribute: current_position
    id: "t_manual_1"
    for: "00:01:00"

  - platform: template
    value_template: "{{ now() >= today_at(reset_override_time) }}"
    enabled: "{{ is_reset_fixed_time }}"
    id: "t_manual_2"
    for: "00:00:02"

  - platform: template
    value_template: >-
      {{
        states(cover_status_helper) not in ['', 'unknown', 'unavailable', 'none', []] and
        states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        states(cover_status_helper)|from_json|regex_search('manual') and
        (states(cover_status_helper)|from_json).manual.t is defined and
        (states(cover_status_helper)|from_json).manual.a is defined and
        (states(cover_status_helper)|from_json).manual.a | bool is true and
         now() >= ( (states(cover_status_helper)|from_json).manual.t + 60 * reset_override_timeout) | as_datetime | as_local
       }}
    enabled: "{{ is_reset_timeout and cover_status_helper != [] }}"
    id: "t_manual_3"
    for: "00:00:02"

  - platform: state
    entity_id: !input blind
    attribute: current_tilt_position
    id: "t_manual_4"
    for: "00:01:00"

################################################################################
# GLOBAL CONDITIONS
################################################################################

conditions:
  - condition: !input auto_global_condition
  - or:
      - "{{ trigger.to_state is not defined }}" # for "platform: time"-Trigger
      - "{{ trigger.to_state is defined and trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}" # The following values are not valid to trigger

################################################################################
# ACTIONS
################################################################################

actions:

  # YAML Anchors ###############################################################
  - variables:
      cover_move_action: &cover_move_action
        sequence:
          - repeat:
              for_each: "{{ blind_entities | list }}"
              sequence:
                - choose:
                    - conditions:
                        - "{{ not prevent_default_cover_actions }}"
                        - "{{ target_position | default(101)  == 0 }}"
                      sequence:
                        - alias: "Close Cover"
                          service: cover.close_cover
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"
                    - conditions:
                        - "{{ not prevent_default_cover_actions }}"
                        - "{{ target_position | default(101) == 100 }}"
                      sequence:
                        - alias: "Open Cover"
                          service: cover.open_cover
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"
                    - conditions:
                        - "{{ not prevent_default_cover_actions }}"
                        - "{{ target_position | default(101) not in [0, 100] }}"
                      sequence:
                        - alias: "Moving the cover to target position"
                          service: cover.set_cover_position
                          data:
                            position: "{{ target_position | default(101) }}"
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"
                - delay:
                    seconds: "{{ (range(1, 3) | random | int) }}"

      tilt_move_action: &tilt_move_action
        sequence:
          - if:
              - "{{ not prevent_default_cover_actions }}"
              - "{{ is_cover_tilt_enabled_and_possible }}"
              - "{{ expand(blind_entities) | selectattr('attributes.current_tilt_position', 'defined') | list | count > 0 }}"
            then:
              - repeat:
                  for_each: "{{ blind_entities | list }}"
                  sequence:
                    - if:
                        - "{{ tilt_first | default(false) }}"
                      then:
                        - alias: "Reset Tilt"
                          service: cover.set_cover_tilt_position
                          data:
                            tilt_position: 0
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"
                        - delay:
                            seconds: !input tilt_delay
                    - alias: "Moving the cover to tilt position"
                      service: cover.set_cover_tilt_position
                      data:
                        tilt_position: "{{ target_tilt_position | default(101) }}"
                      target:
                        entity_id: "{{ repeat.item if repeat is defined else '' }}"
                    - delay:
                        seconds: "{{ (range(1, 3) | random | int) }}"

      helper_update: &helper_update
        if:
          - "{{ is_status_helper_enabled }}"
        then:
          - alias: "Update cover status helper"
            service: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: |-
                {% set dict_var = helper_state_json %}
                {% set dict_new = dict(dict_var, **(update_values | default({})) ) %}
                {{ dict_new | to_json }}

  # Querying the weather forecast  #############################################
  - if:
      - "{{ is_shading_enabled }}"
      - "{{ not prevent_forecast_service }}"
      - "{{ (shading_forecast_sensor != [] ) }}"
      - "{{ states(shading_forecast_sensor) not in ['unavailable', 'unknown', 'query failed']  }}"
      - "{{ trigger.id is defined }}"
      - "{{ trigger.id | regex_match('^(t_shading_start|t_open_1|t_open_3)') }}" # Important: All triggers for shading start necessary!
      - "{{ shading_forecast_sensor.startswith('weather.') }}"
    then:
      - action: weather.get_forecasts
        target:
          entity_id: !input shading_forecast_sensor
        data:
          type: !input shading_forecast_type
        response_variable: weather_forecast

  # Initialise empty helper with JSON default values ###########################
  - if:
      - "{{ 'cover_helper_enabled' in cover_status_options }}"
      - "{{ cover_status_helper != [] }}"
      - or:
          - "{{ states(cover_status_helper) in ['', 'unknown', 'unavailable', 'none'] }}"
          - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") }}'
    then:
      - action: input_text.set_value # I cannot use update_values here, because is is is_status_helper_enabled before
        data:
          entity_id: !input cover_status_helper
          value: "{{ helper_state_json | to_json }}"

  # Upgrade JSON-helper to current version #####################################
  - if:
      - "{{ is_status_helper_enabled }}"
      - "{{ helper_state_json.v != 5 }}"
    then:
      - variables:
          update_values:
            open: { a: "{{ is_helper_open|int }}", t: "{{ ts_helper_open }}" }
            close: { a: "{{ is_helper_closed|int }}", t: "{{ ts_helper_closed }}" }
            shading: { a: "{{ is_helper_shaded|int }}", t: "{{ ts_helper_shaded }}", p: 0, q: 0 } # Set shading to true, but do not overwrite shading time
            vpart: { a: "{{ is_helper_vent_partial|int }}", t: "{{ ts_helper_vent_partial }}" }
            vfull: { a: "{{ is_helper_vent_full|int }}", t: "{{ ts_helper_vent_full }}" }
            manual: { a: "{{ is_helper_manual|int }}", t: "{{ ts_helper_manual }}" }
            v: 5
            t: "{{ helper_state_json.t | round(0) }}"
      - *helper_update

  - choose:

      ############################################################
      # ANCHOR (0): OPEN
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Open, Shading
      ############################################################

      - alias: "Check for opening"
        conditions:
          - "{{ is_up_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_open)') }}"
          - condition: !input auto_up_condition
          - and:
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
              - "{{ auto_shading_start_force_disabled }}"
          - "{{ not (is_status_helper_enabled and is_helper_manual and override_opening_after_manual) }}" # Override check
          - or: # Only once a day?
              - "{{ not is_status_helper_enabled }}"
              - "{{ not prevent_opening_multiple_times }}"
              - "{{ is_status_helper_enabled and prevent_opening_multiple_times and (now().day != ts_helper_open|timestamp_custom('%-d')|int) }}"
          - or: # Check whether the resident trigger is allowed
              - "{{ trigger.id != 't_open_6' }}" # Continue if other trigger
              - "{{ trigger.id == 't_open_6' and resident_opening_enabled }}" # Only continue if permitted
          - or: # Resident status must always be checked
              - "{{ resident_sensor == [] }}"
              - "{{ states(resident_sensor) in ['false', 'off'] }}"
              - and:
                  - "{{ resident_allow_opening }}"
                  - "{{ states(resident_sensor) in ['true', 'on'] }}"
          - or: # Now we have to check different opening scenarios
              - and: # Control via times disabled
                  - "{{ is_time_control_disabled }}"
              - and: # Opening - Up late reached
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_up_late_today) }}"
                  - "{{ now() <= today_at(time_down_late_today) - timedelta(seconds = 5) }}"
              - and: # Opening - Scheduler changes to on w/o brightness and sun
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  - "{{ not is_brightness_enabled }}" # Only if stand-alone w/o brightness and sun. The cover is then opened on the ON trigger.
                  - "{{ not is_sun_elevation_enabled }}"
                  - "{{ is_state(time_schedule_helper, 'on') }}"
                  - "{{ trigger.id in ['t_open_3', 't_open_6'] }}" # Scheduler -> true / Resident -> false # TODO Why is the resident trigger here?
              - and: # Opening - Up early reached or schedule helper is on and brightness/sun above minimum
                  - or:
                      - and:
                          - "{{ is_time_control_disabled }}"
                      - and:
                          - "{{ is_time_field_enabled }}"
                          - "{{ now() >= today_at(time_up_early_today) }}"
                          - "{{ now() <= today_at(time_up_late_today) + timedelta(seconds = 5) }}"
                      - and:
                          - "{{ is_schedule_helper_enabled }}"
                          - "{{ time_schedule_helper != [] }}"
                          - "{{ is_state(time_schedule_helper, 'on') }}" # If sun/brightness control is also enabled, the cover opened during the scheduler-ON phase.
                          - "{{ now() >= today_at([time_up_early, time_up_early_non_workday] | min) - timedelta(seconds = 5) }}"
                          - "{{ now() <= today_at([time_up_late, time_up_late_non_workday] | max) + timedelta(seconds = 5) }}"
                  - or:
                      - or:
                          - "{{ is_brightness_enabled and default_brightness_sensor == [] }}"
                          - "{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor) | float(default=brightness_up) > brightness_up) }}"
                      - or:
                          - "{{ is_sun_elevation_enabled and default_sun_sensor == [] }}"
                          - "{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation | float(default=sun_elevation_up) > sun_elevation_up) }}"

        sequence:
          - delay:
              seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

          - choose:
              ###################################
              # Cover should be shaded
              ###################################
              - alias: "Shading detected. Move to shading position"
                conditions:
                  - "{{ is_status_helper_enabled }}"
                  - "{{ is_helper_shaded }}"
                  - "{{ not in_shading_position }}" # Even if this is hardly possible, there may be situations that require it. Purely as a precautionary measure in case the target state and actual state do not match.
                sequence:
                  - choose: []
                    default: !input auto_shading_start_action_before
                  - variables:
                      target_position: !input shading_position
                      target_tilt_position: "{{ shading_tilt_position | int }}"
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 1, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 } # Set shading to true, but do not overwrite shading time
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_shading_start_action

              ###################################
              # Cover should be opened
              ###################################
              - alias: "Normal opening of the cover"
                conditions:
                  - "{{ not in_shading_position }}" # In this part, there is no plan for an open roller blind to switch from Shading to Open. I cannot check the helper here because Open+Shading could be set to true there.
                  - or:
                      - "{{ is_status_helper_enabled and not is_helper_open }}" # including ventilation, window open-status and more possibilities
                      - "{{ not in_open_position }}"
                sequence:
                  - choose: []
                    default: !input auto_up_action_before
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: "{{ open_tilt_position | int }}"
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_up_action

          # - stop: "Stop automation: OPEN"

      ############################################################
      # ANCHOR (1): CLOSE
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Close, Ventilation
      ############################################################

      - alias: "Check for closing cover"
        conditions:
          - "{{ is_down_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_close)') }}"
          - condition: !input auto_down_condition
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
              - "{{ auto_shading_start_force_disabled }}"
          - or: # Check the helper status or the target status
              - "{{ is_status_helper_enabled and not is_helper_closed }}"
              - "{{ not in_close_position }}"
              # - "{{ in_open_position }}"
          - "{{ not (is_status_helper_enabled and is_helper_manual and override_closing_after_manual) }}" # Override check
          - or: # Only once a day?
              - "{{ not is_status_helper_enabled }}"
              - "{{ not prevent_closing_multiple_times }}"
              - "{{ is_status_helper_enabled and prevent_closing_multiple_times and (ts_helper_closed < today_at(time_down_early_today) | as_timestamp) }}"
          - or:
              - and: # Control via times disabled
                  - "{{ is_time_control_disabled }}"
              - and: # Closing - Down late reached
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_down_late_today) }}"
              - and: # Closing - Scheduler changes to off
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  # Commented out due to #170.
                  # Always shut down when the scheduler becomes inactive. This is effectively the ‚Äúat the latest at‚Äù time.
                  # Otherwise it could happen that the blind does not close if it is still too bright.
                  # - "{{ not is_brightness_enabled }}" # Only if stand-alone w/o brightness and sun. The cover is then opened on the ON trigger.
                  # - "{{ not is_sun_elevation_enabled }}"
                  - "{{ is_state(time_schedule_helper, 'off') }}"
                  - "{{ trigger.id == 't_close_3' }}"
              - and: # Closing - Down early reached and brightness/sun below minimum
                  - or:
                      - and: # Control via times disabled
                          - "{{ is_time_control_disabled }}"
                      - and:
                          - "{{ is_time_field_enabled }}"
                          - "{{ now() >= today_at(time_down_early_today) }}"
                          - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
                      - and:
                          - "{{ is_schedule_helper_enabled }}"
                          - "{{ time_schedule_helper != [] }}"
                          - "{{ is_state(time_schedule_helper, 'on') }}" # If sun/brightness control is also enabled, the cover opened during the scheduler-ON phase.
                          - "{{ now() >= today_at([time_down_early, time_down_early_non_workday] | min) - timedelta(seconds = 5) }}"
                          - "{{ now() <= today_at([time_down_late, time_down_late_non_workday] | max) + timedelta(seconds = 5) }}"
                  - or:
                      - or:
                          - "{{ is_brightness_enabled and default_brightness_sensor == [] }}"
                          - "{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor) | float(default=brightness_down) < brightness_down) }}"
                      - or:
                          - "{{ is_sun_elevation_enabled and default_sun_sensor == [] }}"
                          - "{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation | float(default=sun_elevation_down) < sun_elevation_down) }}"
              - and: # Closing - due to resident goes sleeping
                  - "{{ trigger.id == 't_close_6' }}"
                  - "{{ resident_sensor != [] }}"
                  - "{{ states(resident_sensor) in ['true', 'on'] }}"
                  - "{{ resident_closing_enabled }}"

        sequence:
          - choose:
              #################################
              # Lockout protection when closing
              #################################
              - alias: "Lockout protection when closing"
                conditions:
                  - "{{ is_ventilation_enabled }}"
                  - "{{ is_status_helper_enabled }}"
                  - or:
                      - and:
                          - "{{ contact_window_opened != [] }}"
                          - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                      - and:
                          - "{{ lockout_tilted_when_closing }}"
                          - "{{ contact_window_tilted != [] }}"
                          - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update

              ############################################################################
              # Window tilted. No lockout. Move to ventilation position instead of closing
              ############################################################################
              - alias: "Window tilted. No lockout. Move to ventilation position instead of closing"
                conditions:
                  - "{{ is_ventilation_enabled }}"
                  - "{{ is_status_helper_enabled }}"
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                  - "{{ not lockout_tilted_when_closing }}"
                  - or:
                      - "{{ contact_window_opened == [] }}"
                      - "{{ states(contact_window_opened) in ['false', 'off'] }}"

                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - delay:
                      seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_ventilate_action

              ###################################
              # Cover is already (almost) closed
              ###################################
              - alias: "Only status change if cover is already 'near' the close position" # No driving here!
                conditions:
                  - or:
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ is_status_helper_enabled }}"
                          - "{{ prevent_lowering_when_closing_if_shaded }}"
                          - "{{ is_helper_shaded }}"
                          - "{{ close_position > shading_position }}"
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ prevent_lowering_when_closing_if_shaded }}"
                          - "{{ in_shading_position }}" # Always, no further checks for 'is_status_helper_enabled'
                          - "{{ close_position > shading_position }}"
                      - and: # Stop if close-position is higher than the current position
                          - "{{ prevent_higher_position_closing }}"
                          - "{{ (current_position <= close_position) }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        # manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update

            ###################################
            # Normal closing of the cover
            ###################################
            default:
              - choose: []
                default: !input auto_down_action_before
              - alias: "Normal closing of the cover"
                delay:
                  seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
              - variables:
                  target_position: !input close_position
                  target_tilt_position: !input close_tilt_position
                  update_values:
                    open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                    close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                    shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                    vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                    vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                    manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                    t: "{{ as_timestamp(now()) | round(0) }}"
              - *cover_move_action
              - *tilt_move_action
              - *helper_update
              - choose: []
                default: !input auto_down_action

          # - stop: "Stop automation: CLOSE"

      ############################################################
      # ANCHOR (2): SHADING START
      #   Source: Open
      #   Target: Shading, Lockout
      ############################################################

      - alias: "Check for shading start"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_start|t_open_1|t_open_3)') }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_shading_start_condition
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
          - or: # Check the helper status or the target status
              - "{{ not is_helper_shaded }}"
              - "{{ not (is_helper_vent_partial or is_helper_vent_full) }}"
          - or: # Try to avoid starting the shading several times TODO / FIXME
              - and:
                  - "{{ not is_cover_tilt_enabled_and_possible }}"
                  - "{{ not in_shading_position }}"
              - and:
                  - "{{ is_cover_tilt_enabled_and_possible }}"
                  - "{{ current_position >= shading_position }}"
          - "{{ not (is_helper_manual and override_shading_after_manual) }}" # Override check
          - or: # Only once a day?
              - "{{ not prevent_shading_multiple_times }}"
              - "{{ prevent_shading_multiple_times and (now().day != ts_helper_shaded|timestamp_custom('%-d') | int) }}"
              - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}" # Execution must not be stopped if there is a shading pending in the helper beforehand.

        sequence:
          - if: # Conditions sorted by trigger sequence
              - "{{ current_sun_azimuth > shading_azimuth_start and current_sun_azimuth < shading_azimuth_end }}" # t_shading_start_pending_1
              - "{{ current_sun_elevation > shading_elevation_min and current_sun_elevation < shading_elevation_max }}" # t_shading_start_pending_1
              - or: # t_shading_start_pending_2
                  - "{{ shading_brightness_sensor == [] }}"
                  - "{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > shading_sun_brightness_start }}"
              - or: # t_shading_start_pending_3
                  - "{{ shading_temperatur_sensor1 == [] }}"
                  - "{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > shading_min_temperatur1 }}"
              - or: # t_shading_start_pending_4
                  - "{{ shading_temperatur_sensor2 == [] }}"
                  - "{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > shading_min_temperatur2 }}"
              - or: # t_shading_start_pending_5
                  - "{{ shading_forecast_sensor == [] }}"
                  - "{{ shading_forecast_temp == [] }}"
                  - and:
                      - "{{ shading_forecast_sensor.startswith('sensor.') }}"
                      - "{{ states(shading_forecast_sensor) | float(default=shading_forecast_temp - 1) > shading_forecast_temp }}"
                  - and:
                      - "{{ shading_forecast_sensor.startswith('weather.') }}"
                      - "{{ prevent_forecast_service }}"
                      - "{{ state_attr(shading_forecast_sensor, 'temperature') | float(default=shading_forecast_temp - 1) > shading_forecast_temp }}"
                  - and:
                      - "{{ shading_forecast_sensor.startswith('weather.') }}"
                      - "{{ not prevent_forecast_service }}"
                      - "{{ weather_forecast is defined }}"
                      - "{{ weather_forecast[shading_forecast_sensor].forecast[0].temperature | float(default=shading_forecast_temp - 1) > shading_forecast_temp }}"
                  - "{{ (shading_temperatur_sensor2 != [] ) and (states(shading_temperatur_sensor2) | float(default=shading_forecast_temp) > shading_forecast_temp) }}"
              - or: # t_shading_start_pending_5
                  - "{{ shading_forecast_sensor == [] }}"
                  - "{{ shading_weather_conditions == [] }}"
                  - "{{ shading_forecast_sensor.startswith('sensor.') }}"
                  - and:
                      - "{{ shading_forecast_sensor.startswith('weather.') }}"
                      - "{{ prevent_forecast_service }}"
                      - "{{ states(shading_forecast_sensor) in shading_weather_conditions }}"
                  - and:
                      - "{{ shading_forecast_sensor.startswith('weather.') }}"
                      - "{{ not prevent_forecast_service }}"
                      - "{{ weather_forecast is defined }}"
                      - "{{ weather_forecast[shading_forecast_sensor].forecast[0].condition in shading_weather_conditions }}"
            then:
              - choose:
                  #####################################################################
                  # Shading start detected. Save next execution time and pending status
                  #####################################################################
                  - alias: "Shading detected. Save next execution time and pending status"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_pending)') }}"
                      - "{{ not is_helper_shading_start }}" # Not if a pending is already active
                    sequence:
                      - variables:
                          update_values:
                            shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: "{{ (as_timestamp(now()) | round(0) + (shading_waitingtime_start | int)) | round(0) }}", q: 0 }
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *helper_update

                  ##################################################
                  # Consider lockout protection when shading starts
                  ##################################################
                  - alias: "Consider lockout protection when shading starts"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ is_helper_shading_start }}" # Only when it comes back from pending status
                      - "{{ is_ventilation_enabled }}"
                      - or:
                          - and:
                              - "{{ contact_window_opened != [] }}"
                              - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                          - and:
                              - "{{ lockout_tilted_when_shading_starts }}"
                              - "{{ contact_window_tilted != [] }}"
                              - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                    sequence:
                      - variables:
                          update_values:
                            open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                            close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                            shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                            vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                            vfull: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                            manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *helper_update

                  ###################################
                  # Start Shading
                  ###################################
                  - alias: "Start Shading"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ is_helper_shading_start }}" # Only when it comes back from pending status
                      - or:
                          - and:
                              - "{{ not is_cover_tilt_enabled_and_possible }}"
                              - "{{ current_position > shading_position }}"
                          - and:
                              - "{{ is_cover_tilt_enabled_and_possible }}"
                              - "{{ current_position >= shading_position }}"
                      - or: # Here the shading is executed during the day and therefore the time comparison must be made here.
                          - and:
                              - "{{ is_time_control_disabled }}"
                          - and:
                              - "{{ is_time_field_enabled }}"
                              - "{{ now() >= today_at(time_up_early_today) }}"
                              - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
                          - and:
                              - "{{ is_schedule_helper_enabled }}"
                              - "{{ time_schedule_helper != [] }}"
                              - "{{ is_state(time_schedule_helper, 'on') }}"
                      - or:
                          - "{{ resident_sensor == [] }}"
                          - "{{ states(resident_sensor) in ['false', 'off'] }}"
                          - and: # Issue 131
                              - "{{ resident_allow_shading }}"
                              - "{{ states(resident_sensor) in ['true', 'on'] }}"
                    sequence:
                      - delay:
                          seconds: "{{ range(drive_delay_fix | int(0), drive_delay_fix | int(0) + drive_delay_random | int(0) +1) | random }}"
                      - choose: []
                        default: !input auto_shading_start_action_before
                      - variables:
                          target_position: !input shading_position
                          target_tilt_position: "{{ shading_tilt_position | int }}"
                          update_values:
                            open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                            close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                            shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                            vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                            vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                            manual: { a: 0, t: "{{ helper_state_json.manual.t }}" } # TODO: Do I really want to overwrite the status here?
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *cover_move_action
                      - *tilt_move_action
                      - *helper_update
                      - choose: []
                        default: !input auto_shading_start_action

                  ####################################
                  # Save shading state for the future
                  ####################################
                  - alias: "Save shading state for the future"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ is_helper_shading_start }}" # Only when it comes back from pending status
                      - "{{ is_helper_closed }}" # At this point, the times for shading are not taken into account so that the correct value is available when the cover is opened.
                    sequence:
                      - variables:
                          update_values:
                            shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *helper_update

              # - stop: "Stop automation: SHADING START"

            else: # Shading conditions were no longer met or not met again.
              - choose:

                  #####################################################################
                  # Shading conditions were not met consistently and it should be checked again periodically in a few seconds
                  #####################################################################
                  - alias: "Shading conditions were not met consistently and it should be checked again periodically in a few seconds"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ is_helper_shading_start }}"
                      - "{{ start_shading_trigger_periodic }}"
                      - or: # Periodic checks only within a limited time frame. Not all day
                          - and:
                              - "{{ is_time_control_disabled }}" # Not recommended on its own, otherwise it will trigger for 24 hours.
                              - "{{ is_helper_open }}" # Not nice, but necessary if you don't use time control.
                          - and:
                              - "{{ is_time_field_enabled }}"
                              - "{{ now() >= today_at(time_up_early_today) }}"
                              - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
                          - and:
                              - "{{ is_schedule_helper_enabled }}"
                              - "{{ time_schedule_helper != [] }}"
                              - "{{ is_state(time_schedule_helper, 'on') }}"
                    sequence:
                      - variables:
                          update_values:
                            shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: "{{ (as_timestamp(now()) | round(0) + (shading_waitingtime_start | int)) | round(0) }}", q: 0 }
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *helper_update

                  ######################################
                  # Shading conditions were not consistently met and the next new trigger should be waited for
                  ######################################
                  - alias: "Shading conditions were not consistently met and the next new trigger should be waited for"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ is_helper_shading_start }}"
                      - "{{ start_shading_trigger_reset }}"
                    sequence:
                      - variables:
                          update_values:
                            shading: { a: 0, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                            t: "{{ as_timestamp(now()) | round(0) }}"
                      - *helper_update

      ############################################################
      # ANCHOR (3): SHADING Tilt
      ############################################################

      - alias: "Check for shading tilt"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_tilt)') }}"
          - "{{ is_status_helper_enabled }}"
          - and:
              - "{{ is_helper_shaded }}"
              - "{{ not is_helper_shading_start }}"
          - "{{ is_cover_tilt_enabled_and_possible }}"
          - condition: !input auto_shading_tilt_condition
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
          - "{{ not (is_helper_vent_partial or is_helper_vent_full) }}"
          - "{{ not (is_helper_manual and override_shading_after_manual) }}" # Override check
        sequence:
          - variables:
              target_tilt_position: "{{ shading_tilt_position | int }}"
              tilt_first: true # tilt the cover to close position before
              update_values:
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *tilt_move_action
          - *helper_update

      ############################################################
      # ANCHOR (4): SHADING END
      #   Source: Shading
      #   Target: Open, Lockout, Ventilation
      ############################################################

      - alias: "Check for shading end"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_end)') }}"
          - "{{ is_status_helper_enabled }}"
          - "{{ is_helper_shaded }}"
          - condition: !input auto_shading_end_condition
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
              - "{{ auto_shading_start_force_disabled }}"
          - or:
              - and:
                  - "{{ is_time_control_disabled }}"
              - and:
                  - "{{ is_time_field_enabled }}"
                  - "{{ now() >= today_at(time_up_early_today) }}"
                  - "{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}"
              - and:
                  - "{{ is_schedule_helper_enabled }}"
                  - "{{ time_schedule_helper != [] }}"
                  - "{{ is_state(time_schedule_helper, 'on') }}"
          - "{{ not (is_helper_manual and override_shading_after_manual) }}" # Override check
          - or:
              - "{{ is_helper_shaded }}"
              - "{{ in_shading_position }}" # Be careful if the tolerance value is too high!
          - or: # Optional: Continue if cover is not already closed
              - "{{ not prevent_shading_end_if_closed }}"
              - "{{ prevent_shading_end_if_closed and not in_close_position}}"
          - or: # Issue #116
              - "{{ resident_sensor == [] }}"
              - "{{ states(resident_sensor) in ['false', 'off'] }}"

        sequence:
          - choose:
              #####################################################################
              # Shading end detected. Save next execution time and pending status
              #####################################################################
              - alias: "Shading end detected. Save next execution time and pending status"
                conditions:
                  - "{{ trigger.id | regex_match('^(t_shading_end_pending)') }}"
                  - "{{ not is_helper_shading_end }}"
                sequence:
                  - variables:
                      local_waitingtime_end: >
                        {% set local_waitingtime_end = shading_waitingtime_end | default(0) | int %}
                        {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool and trigger.id == 't_shading_end_pending_5' %}
                        {# Almost immediately end shading when sun position out of range. Earlier triggers do not work. #}
                        {% set local_waitingtime_end = 20 %}
                        {% endif %}
                        {{ local_waitingtime_end }}
                      update_values:
                        shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: "{{ (as_timestamp(now()) | round(0) + (local_waitingtime_end | int)) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update

              ######################################
              # Only tilt open after shading ends
              ######################################
              - alias: "Only tilt open after shading ends"
                conditions:
                  - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                  - "{{ is_helper_shading_end }}"
                  - "{{ is_cover_tilt_enabled_and_possible }}"
                  - "{{ prevent_opening_after_shading_end}}"
                sequence:

                  - variables:
                      target_tilt_position: 50 # Moving the cover to open tilt position
                      update_values:
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *tilt_move_action
                  - *helper_update

              ######################################
              # Lockout protection when shading ends
              ######################################
              - alias: "Lockout protection when shading ends"
                conditions:
                  - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                  - "{{ is_helper_shading_end }}"
                  - "{{ is_ventilation_enabled }}"
                  - "{{ (current_position < ventilate_position) }}"
                  - or:
                      - and:
                          - "{{ contact_window_opened != [] }}"
                          - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                      - and:
                          - "{{ contact_window_tilted != [] }}"
                          - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                          - "{{ lockout_tilted_when_shading_ends }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update

              ################################
              # Ventilation after shading ends
              ################################
              - alias: "Ventilation after shading ends"
                conditions:
                  - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                  - "{{ is_helper_shading_end }}"
                  - "{{ is_ventilation_enabled }}"
                  - "{{ ventilation_after_shading_end }}"
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                  - "{{ not lockout_tilted_when_closing }}"
                  - or:
                      - "{{ contact_window_opened == [] }}"
                      - "{{ states(contact_window_opened) in ['false', 'off'] }}"
                  - or:
                      - "{{ (current_position < ventilate_position) }}"
                      - "{{ ventilation_if_lower_enabled and (current_position >= ventilate_position) }}"
                sequence:
                  - delay: # TODO: I can no longer recognize the original trigger here. That might be a bad idea here.
                      seconds: >
                        {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool %}
                          {{ range(0, 2) | random }}
                        {% else %}
                          {{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}
                        {% endif %}

                  - choose: []
                    default: !input auto_ventilate_action_before
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_ventilate_action

              ###############################################
              # Move cover after shading end
              ###############################################
              - alias: "Move cover after shading end"
                conditions:
                  - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                  - "{{ is_helper_shading_end }}"
                sequence:
                  - delay: # TODO: I can no longer recognize the original trigger here. That might be a bad idea here.
                      seconds: >
                        {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool %}
                          {{ range(0, 2) | random }}
                        {% else %}
                          {{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}
                        {% endif %}

                  - choose: []
                    default: !input auto_shading_end_action_before
                  - variables:
                      target_status: "{{ 'close' if shading_end_behavior == 'close_position' else 'open' }}"
                      target_position: "{{ close_position if shading_end_behavior == 'close_position' else open_position }}"
                      target_tilt_position:  "{{ close_tilt_position if shading_end_behavior == 'close_position' else open_tilt_position }}"
                      update_values:
                        open: { a: "{{ 1 if shading_end_behavior == 'open_position' else 0 }}", t: "{{ as_timestamp(now()) | round(0) if shading_end_behavior == 'open_position' else helper_state_json.open.t }}" }
                        close: { a: "{{ 1 if shading_end_behavior == 'close_position' else 0 }}", t: "{{ as_timestamp(now()) | round(0) if shading_end_behavior == 'close_position' else helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - if:
                      - "{{ not prevent_opening_after_shading_end}}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                  - choose: []
                    default: !input auto_shading_end_action

          # - stop: "Stop automation: SHADING END"

      ############################################################
      # ANCHOR (5): CONTACT OPEN
      #   Source: Shading, Close
      #   Target: Ventilation
      ############################################################

      - alias: "Contact sensor opened"
        conditions:
          - "{{ is_ventilation_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id in ['t_contact_tilted_on', 't_contact_opened_on'] }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_ventilate_condition
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_shading_start_force_disabled }}"
          - or:
              - "{{ resident_sensor == [] }}"
              - "{{ states(resident_sensor) in ['false', 'off'] }}"
              - and:
                  - "{{ resident_allow_ventilation }}"
                  - "{{ states(resident_sensor) in ['true', 'on'] }}"
        sequence:
          - delay:
              seconds: !input contact_delay_status # Wait for possible further handle changes of the contact sensors.
          - choose:
              ###################################
              # Window handle to open. Open cover
              ###################################
              - alias: "Window handle to open. Open cover"
                conditions:
                  - "{{ contact_window_opened != [] }}"
                  - "{{ states(contact_window_opened) in  ['true', 'on'] }}"
                  - "{{ trigger.id == 't_contact_opened_on' }}"
                  - "{{ not in_open_position }}"
                sequence:
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: !input open_tilt_position
                      update_values:
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update

              ############################################################################
              # Window handle to tilt. Move the cover to the partial ventilation position
              ############################################################################
              - alias: "Window handle to tilt. Move the cover to the partial ventilation position."
                conditions:
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                  - "{{ trigger.id == 't_contact_tilted_on' }}"
                  - or:
                      - "{{ (current_position < ventilate_position) }}"
                      - and:
                          - "{{ is_cover_tilt_enabled_and_possible }}"
                          - "{{ (current_position <= ventilate_position) }}"
                          - "{{ (current_tilt_position <= ventilate_tilt_position) }}"
                      - "{{ ventilation_if_lower_enabled and (current_position >= ventilate_position) }}"
                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      update_values:
                        vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_ventilate_action

          # - stop: "Stop automation: CONTACT OPEN"

      ############################################################
      # ANCHOR (6): CONTACT CLOSED
      #   Source: Ventilation, Lockout
      #   Target: Open, Close, Shading
      ############################################################

      - alias: "Contact sensor closed"
        conditions:
          - "{{ is_ventilation_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ is_status_helper_enabled }}"
          - condition: !input auto_ventilate_end_condition
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"
          - and:
              - "{{ auto_up_force_disabled }}"
              - "{{ auto_down_force_disabled }}"
              - "{{ auto_ventilate_force_disabled }}"
              - "{{ auto_shading_start_force_disabled }}"
          - "{{ not (is_helper_manual and override_ventilation_after_manual) }}" # Override check
          - or:
              - and:
                  - "{{ trigger.id == 't_contact_tilted_off' }}"
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['false', 'off'] }}"
                  - or:
                      - "{{ is_helper_vent_partial }}" # Status check
                      - "{{ in_ventilate_position }}" # Position check
              - and:
                  # Workaround for #181
                  # If the contact_window_tilted-sensor is used and 'lockout_tilted_when_closing' is enabled, when closing,
                  # 'vfull' is set in the helper.
                  # This must remain the case because the position of the cover remains at 100.
                  # But the return from this must be taken into account somehow.
                  - "{{ trigger.id == 't_contact_tilted_off' }}"
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['false', 'off'] }}"
                  - "{{ lockout_tilted_when_closing }}"
                  - "{{ is_helper_vent_full }}"
              - and:
                  - "{{ trigger.id == 't_contact_opened_off' }}"
                  - "{{ contact_window_opened != [] }}"
                  - "{{ states(contact_window_opened) in ['false', 'off'] }}"
                  - "{{ is_helper_vent_full }}"

        sequence:
          - if:
              - "{{ ventilation_delay_enabled }}"
            then:
              - delay:
                  seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
            else:
              - delay:
                  seconds: !input contact_delay_status # Wait for possible further handle changes of the contact sensors.

          - choose:
              #####################################################
              # Contact sensor closed. Activate partial ventilation
              #####################################################
              - alias: "Contact sensor closed. Activate partial ventilation"
                conditions:
                  - "{{ is_helper_vent_full }}" # Was fully ventilated before :-)
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      update_values:
                        vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_ventilate_action

              ##########################################
              # Contact sensor closed. Activate shading
              ##########################################
              - alias: "Contact sensor closed. Activate shading"
                conditions:
                  - "{{ is_helper_shaded }}"
                sequence:
                  - choose: []
                    default: !input auto_shading_start_action_before
                  - variables:
                      target_position: !input shading_position
                      target_tilt_position: "{{ shading_tilt_position | int }}"
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_shading_start_action

              ########################################
              # Contact sensor closed. Open the cover
              ########################################
              - alias: "Contact sensor closed. Open the cover"
                conditions:
                  - "{{ is_helper_open }}"
                  - "{{ not is_helper_shaded }}"
                sequence:
                  - choose: []
                    default: !input auto_up_action_before
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: !input open_tilt_position
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ elper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - if:
                      - "{{ not prevent_opening_after_ventilation_end }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                  - choose: []
                    default: !input auto_up_action

              ########################################
              # Contact sensor closed. Close the cover
              ########################################
              - alias: "Contact sensor closed. Close the cover"
                conditions:
                  - "{{ is_helper_closed }}"
                sequence:
                  - choose: []
                    default: !input auto_down_action_before
                  - variables:
                      target_position: !input close_position
                      target_tilt_position: !input close_tilt_position
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_down_action

          # - stop: "Stop automation: CONTACT CLOSED"

      ############################################################
      # ANCHOR (7): FORCE OPEN
      ############################################################

      - alias: "Forced opening of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_open' }}"
        sequence:
          - choose: []
            default: !input auto_up_action_before
          - variables:
              target_position: !input open_position
              target_tilt_position: !input open_tilt_position
              update_values:
                open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_up_action
          # - stop: "Stop automation: FORCE OPEN"

      ############################################################
      # ANCHOR (8): FORCE CLOSE
      ############################################################

      - alias: "Forced closing of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_close' }}"
        sequence:
          - choose: []
            default: !input auto_down_action_before
          - variables:
              target_position: !input close_position
              target_tilt_position: !input close_tilt_position
              update_values:
                open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_down_action
          # - stop: "Stop automation: FORCE CLOSE"

      ############################################################
      # ANCHOR (9): FORCE VENTILATION
      ############################################################

      - alias: "Forced ventilation of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_vent' }}"
          - "{{ is_status_helper_enabled }}"
        sequence:
          - choose: []
            default: !input auto_ventilate_action_before
          - variables:
              target_position: !input ventilate_position
              target_tilt_position: !input ventilate_tilt_position
              update_values:
                open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_ventilate_action
          # - stop: "Stop automation: FORCE VENTILATION"

      ############################################################
      # ANCHOR (10): FORCE SHADING START
      ############################################################

      - alias: "Forced activating of the sun shading"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_shading_start' }}"
          - "{{ is_status_helper_enabled }}"
        sequence:
          - choose: []
            default: !input auto_shading_start_action_before
          - variables:
              target_position: !input shading_position
              target_tilt_position: "{{ shading_tilt_position |int }}"
              update_values:
                open: { a: 0, t: "{{ helper_state_json.open.t }}" } # ‚ÄòOpen‚Äô is not additionally set to True, because we don't know where it should actually go after forcing.
                close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                manual: { a: 0, t: "{{ helper_state_json.manual.t }}" }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_shading_start_action
          # - stop: "Stop automation: FORCE SHADING START"

      ############################################################
      # ANCHOR (11): MANUAL
      ############################################################

      - alias: "Checking for manual position changes"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ this.attributes.current | int(99) == 0 }}" # Avoid multiple triggering. Problem: A recognised position change can interrupt ongoing delays (contact changes).
          - "{{ 'cover_helper_enabled' in cover_status_options }}" # Do not use 'is_status_helper_enabled' (with the embedded regex here), because it could be set after variable declaration
          - "{{ cover_status_helper != [] }}"
          - "{{ as_timestamp(now()) > helper_state_json.t + drive_time + 60 }}" # Drive time + trigger waiting time
          - "{{ trigger.id in ['t_manual_1', 't_manual_4'] }}"
          - or:
              - "{{ is_number(trigger.to_state.attributes.current_position) and is_number(trigger.from_state.attributes.current_position) }}" # Avoid status change from -unavailable- (common with Homematic)
              - "{{ is_number(trigger.to_state.attributes.current_tilt_position) and is_number(trigger.from_state.attributes.current_tilt_position) }}" # Avoid status change from -unavailable- (common with Homematic)
          - or:
              - "{{ trigger.to_state.attributes.current_position != trigger.from_state.attributes.current_position }}" # Probably not necessary, otherwise the trigger would not have been activated.
              - "{{ trigger.to_state.attributes.current_tilt_position != trigger.from_state.attributes.current_tilt_position }}" # Probably not necessary, otherwise the trigger would not have been activated.
          - "{{ trigger.from_state.state not in ['unavailable', 'unknown', 'none', 'query failed'] }}"
          - "{{ trigger.to_state.state not in ['unavailable', 'unknown','none', 'query failed'] }}"

        sequence:
          - choose:
              - conditions: # Manually tilted
                  - "{{ trigger.id == 't_manual_4' }}"
                sequence:
                  - variables:
                      update_values:
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

              - conditions: # Manually opened
                  - "{{ is_up_enabled }}"
                  - or:
                      - "{{ in_open_position }}"
                      - "{{ (current_position >= open_position) }}"
                      - "{{ (current_position == 100) }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

              - conditions: # Manually ventilated
                  - "{{ is_ventilation_enabled }}"
                  - "{{ in_ventilate_position }}"
                  - "{{ not in_open_position }}" # If ventilate_position and open_position are too close together, the ventilation-status should not be assigned.
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

              - conditions: # Manually shaded
                  - "{{ is_shading_enabled }}"
                  - "{{ in_shading_position }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

              - conditions: # Manually closed
                  - "{{ is_down_enabled }}"
                  - "{{ not in_shading_position }}"
                  - or:
                      - "{{ in_close_position }}"
                      - "{{ (current_position <= close_position) }}"
                      - "{{ (current_position == 0) }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

              - conditions: # Defined positions cannot be assigned
                  - not:
                      - "{{ is_up_enabled and in_open_position }}"
                      - "{{ is_down_enabled and in_close_position }}"
                      - "{{ is_ventilation_enabled and in_ventilate_position }}"
                      - "{{ is_shading_enabled and in_shading_position }}"
                sequence:
                  - variables:
                      update_values:
                        open: { a: 0, t: "{{ helper_state_json.open.t }}" }
                        close: { a: 0, t: "{{ helper_state_json.close.t }}" }
                        shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                        vpart: { a: 0, t: "{{ helper_state_json.vpart.t }}" }
                        vfull: { a: 0, t: "{{ helper_state_json.vfull.t }}" }
                        manual: { a: 1, t: "{{ as_timestamp(now()) | round(0) }}" }
                        t: "{{ as_timestamp(now()) | round(0) }}"
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action

      ############################################################
      # ANCHOR (12): RESET MANUAL DETECTION
      ############################################################

      - alias: "Reset manual detection"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ not is_reset_disabled }}"
          - "{{ trigger.id in ['t_manual_2', 't_manual_3'] }}"
        sequence:
          - variables:
              update_values:
                manual: { a: 0, t: "{{ as_timestamp(now()) | round(0) }}" }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *helper_update
          - choose: []
            default: !input auto_override_reset_action

      ############################################################
      # ANCHOR (13): RESET SHADING STATUS AT MIDNIGHT
      ############################################################

      - alias: "Reset shading status that is no longer required - but still saved"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_shading_reset' }}"
          - "{{ is_status_helper_enabled }}"
          - "{{ is_helper_shaded }}"
        sequence:
          - delay:
              seconds: "{{ (range(0, 60) | random | int) }}"
          - variables:
              update_values:
                shading: { a: 0, t: "{{ helper_state_json.shading.t }}", p: 0, q: 0 }
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *helper_update

    ############################################################
    # DEFAULT BRANCH - CONFIG CHECK
    ############################################################

    default:
      - if:
        - "{{ check_config }}"
        then:
          - repeat:
              for_each:
                # Time slot checks
                - condition: "{{ not is_time_control_disabled and (today_at(time_up_early) >= today_at(time_up_late)) }}"
                  message: "time_up_early should be earlier than time_up_late"
                - condition: "{{ not is_time_control_disabled and (today_at(time_up_early_non_workday) >= today_at(time_up_late_non_workday)) }}"
                  message: "time_up_early_non_workday should be earlier than time_up_late_non_workday"
                - condition: "{{ not is_time_control_disabled and (today_at(time_down_early) >= today_at(time_down_late)) }}"
                  message: "time_down_early should be earlier than time_down_late"
                - condition: "{{ not is_time_control_disabled and (today_at(time_down_early_non_workday) >= today_at(time_down_late_non_workday)) }}"
                  message: "time_down_early_non_workday should be earlier than time_down_late_non_workday"

                # Shading checks
                - condition: "{{ shading_azimuth_start >= shading_azimuth_end }}"
                  message: "shading_azimuth_start should be lower than shading_azimuth_end"
                - condition: "{{ shading_elevation_min >= shading_elevation_max }}"
                  message: "shading_elevation_min should be lower than shading_elevation_max"
                - condition: "{{ shading_sun_brightness_start <= shading_sun_brightness_end }}"
                  message: "shading_sun_brightness_start should be higher than shading_sun_brightness_end"

                # Position checks
                - condition: "{{ not is_cover_tilt_enabled_and_possible and (open_position - position_tolerance) <= (close_position + position_tolerance) }}"
                  message: "open_position should be higher than close_position"
                - condition: "{{ not is_cover_tilt_enabled_and_possible and (open_position - position_tolerance) <= (ventilate_position + position_tolerance) }}"
                  message: "open_position should be higher than ventilate_position"
                - condition: "{{ not is_cover_tilt_enabled_and_possible and (close_position + position_tolerance) >= (ventilate_position - position_tolerance) }}"
                  message: "close_position should be lower than ventilate_position"
                - condition: "{{ not is_cover_tilt_enabled_and_possible and (shading_position - position_tolerance) <= (close_position + position_tolerance) }}"
                  message: "shading_position should be higher than close_position"
                - condition: "{{ not is_cover_tilt_enabled_and_possible and (shading_position + position_tolerance) >= (open_position - position_tolerance) }}"
                  message: "shading_position should be lower than open_position"
                - condition: "{{ [in_open_position, in_close_position, in_shading_position, in_ventilate_position].count(True) > 1 }}"
                  message: "Please revise the position values and take the tolerance values into account. The values must not overlap"

                # Sensor and attribute checks
                - condition: "{{ (resident_sensor != [] ) and (not states(resident_sensor) in ['false', 'off','true', 'on']) }}"
                  message: "resident_sensor is only allowed to be on/off/true/false"
                - condition: "{{ state_attr(blind, 'current_position') is none }}"
                  message: "Cover is missing attribute current_position"
                - condition: "{{ state_attr(default_sun_sensor, 'elevation') is none }}"
                  message: "Sun sensor is missing attribute elevation"
                - condition: "{{ state_attr(default_sun_sensor, 'azimuth') is none }}"
                  message: "Sun sensor is missing attribute azimuth"
                - condition: "{{ is_brightness_enabled and (default_brightness_sensor == [] or not is_number(states(default_brightness_sensor))) }}"
                  message: "Brightness sensor not defined or state is not numeric"

                # Helper checks
                - condition: "{{ 'cover_helper_enabled' in cover_status_options and state_attr(cover_status_helper, 'max') < 254 }}"
                  message: "Wrong length of the cover status helper"
                - condition: "{{ (is_shading_enabled or is_ventilation_enabled) and not is_status_helper_enabled }}"
                  message: "Shading, ventilation and lockout protection require a cover status helper to be configured"
                - condition: "{{ is_schedule_helper_enabled and time_schedule_helper == [] }}"
                  message: "Schedule mode selected but no schedule helper specified"

              sequence:
                - if:
                    - "{{ repeat.item.condition }}"
                  then:
                    - action: system_log.write
                      data:
                        level: "{{ check_config_debuglevel }}"
                        message: "CCA Config issue: {{ repeat.item.message }} - {{ this.entity_id }}"
                        logger: "blueprints.hvorragend.cca"

      # - stop: "Stopping the automation - DEFAULT"
