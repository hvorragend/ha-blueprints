blueprint:
  name: "Cover Control Automation (CCA)"
  description: |
    # ‚≠ê Cover Control Automation (CCA) ‚≠ê
    Cover Control Automation is a comprehensive Home Assistant blueprint which automatically manages your window coverings (such as roller shutters and blinds) based on time, the position of the sun, and weather conditions. It adapts intelligently to your preferences, largely eliminating the need for manual adjustments.

    **Version**: 2026.01.alpha

    ### üîó Resources & Support
    üì¢ **Latest Changes**: [Changelog](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/CHANGELOG.md) | ‚ú® **Highlights**: [Key Features](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/README.md#-key-features)
    üöÄ **Setup**: [Quick Start Guide](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/README.md#-quick-start-5-steps) | [Prerequisites](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/README.md#-essential-prerequisites)
    üìö **Docs**: ‚ùì [FAQ](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md) | ‚òÄÔ∏è [Dynamic Sun Elevation](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/DYNAMIC_SUN_ELEVATION.md) | ‚è∞ [Time Control Visualization](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/TIME_CONTROL_VISUALIZATION.md)
    üîß **Validator**: Validate YAML for errors, typos, and deprecated parameters with the [CCA Configuration Validator](https://hvorragend.github.io/ha-blueprints/validator/)
    ‚ú® **Online Tools**:  üîç [CCA Trace Analyzer](https://hvorragend.github.io/ha-blueprints/trace-analyzer/) | üìà [CCA Trace Compare](https://hvorragend.github.io/ha-blueprints/trace-compare/)
    üí¨ **Get Help**: [Forum Thread](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539) | [GitHub Issues](https://github.com/hvorragend/ha-blueprints/issues) | [Source Code](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml)
    ‚ù§Ô∏è **Enjoying my work?** [Buy me a Coffee](https://buymeacoffee.com/herr.vorragend) or tip via [PayPal](https://www.paypal.com/donate/?hosted_button_id=NQE5MFJXAA8BQ). Thank you! üôå
    <sub>License: Open-source. Attribution and original repo link required for modifications. "Take Control" copies are unsupported.</sub>

  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: "2024.10.0"
  input:
    blind:
      name: "üè† Cover"
      description: >-
        Which blind or roller shutter should be automated?

        <details>
        <summary><code><strong>CLICK HERE:</strong> Information about a cover group</code></summary>


        In principle, you can use a group here.
        But please note that there are problems with position detection for a group of covers!
        For example, one cover may be at position 100% and the other cover at position 0%.
        This results in a wrong group-value of 50%.


        My clear recommendation is to create **one automation for each cover**.

        </details>

      selector:
        entity:
          filter:
            - domain:
                - cover

    feature_section:
      name: "Automation Options"
      icon: mdi:window-shutter-cog
      collapsed: true
      input:
        auto_options:
          name: "üëâ What should CCA control?"
          description: >-
            **Basic Controls (When to move):**

            Options 1-4 control WHEN your cover opens/closes based on time, brightness or sun elevation


            **Advanced Features (How to react):**

            Options 5-6 add special behaviors like ventilation and sun protection


            **‚ö†Ô∏è Common Misunderstanding:**

            - **Sun Elevation** (‚òÄÔ∏è) = Controls WHEN cover opens/closes based on sunrise/sunset

            - **Sun Protection** (ü•µ) = Controls HOW MUCH cover closes when sun hits the window

            These are two completely different features!


            <details>
            <summary><code><strong>üìñ CLICK HERE:</strong> Detailed explanation with example</code></summary>


            - **Sun Elevation Control** = Opens cover when sun rises, closes when sun sets (like a sunrise alarm)

            - **Sun Protection/Shading** = Partially closes cover during midday to block heat (like sunglasses)


            Think of it this way:

            - Sun Elevation = "Follow the sun's daily cycle"

            - Sun Protection = "React to direct sunlight hitting the window"


            **Example of a summer day:**

            - **6:00** ‚Äî Sun Elevation triggers opening (sun rose above your threshold)

            - **7:00** ‚Äî Time-based opening would have happened (but cover is already open)

            - **12:00** ‚Äî Sun Protection activates (sun now shines directly on window ‚Üí partial close)

            - **18:00** ‚Äî Sun Protection deactivates (sun moved away ‚Üí cover opens again)

            - **21:00** ‚Äî Sun Elevation triggers closing (sun dropped below your threshold)

            </details>


            <details>
            <summary><code><strong>‚ÑπÔ∏è CLICK HERE:</strong> Important notes on configuration</code></summary>


            Configuring the Cover Status Helper is <ins>mandatory</ins> for utilizing
            ventilation mode or for sun protection and sunshade control.


            This can be enhanced with additional conditions (see below).
            However, it's crucial that options remain activated; otherwise, the specified conditions will not function.


            Please ensure that the relevant sensors are also included.
            For instance, the brightness control will only operate if a brightness sensor is specified.

            </details>


            <details>
            <summary><code><strong>‚öôÔ∏è CLICK HERE:</strong> Notes on multiple triggering</code></summary>


            Even if multiple opening, closing, shading, etc. is activated, this only works if a trigger is available.
            However, the numeric state triggers only trigger under certain circumstances.
            Please see notes here [Numeric state triggers](https://www.home-assistant.io/docs/automation/trigger/#numeric-state-trigger)


            <em>Crossing the threshold means that the trigger only fires if the state wasn't previously within the threshold.
            If the current state of your entity is `50` and you set the threshold to `below: 75`, the trigger would not fire
            if the state changed to e.g. `49` or `72` because the threshold was never crossed. The state would first have to
            change to e.g. `76` and then to e.g. `74` for the trigger to fire.</em>

            </details>

          default:
            [
              auto_up_enabled,
              auto_down_enabled,
              auto_sun_enabled,
            ]
          selector:
            select:
              options:
                - label: "üîº Morning Opening ‚Äî Automatically open based on configured time"
                  value: "auto_up_enabled"
                - label: "üîª Evening Closing ‚Äî Automatically close based on configured time"
                  value: "auto_down_enabled"
                - label: "üîÖ Add Brightness Condition ‚Äî Open/close earlier when brightness sensor reaches threshold"
                  value: "auto_brightness_enabled"
                - label: "‚òÄÔ∏è Add Sun Elevation Condition ‚Äî Open/close earlier based on sun height (not sun protection!)"
                  value: "auto_sun_enabled"
                - label: "üí® Ventilation Mode ‚Äî React to open/tilted windows, prevent lockout (requires helper)"
                  value: "auto_ventilate_enabled"
                - label: "ü•µ Sun Protection / Shading ‚Äî Partially close when sun shines on window (requires helper)"
                  value: "auto_shading_enabled"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        individual_config:
          name: "‚öôÔ∏è Behavior Customization"
          description: >-
            **Fine-tune automation behavior for your specific hardware and preferences.**


            This section lets you customize how CCA behaves in different scenarios:

            - **Position Management**: Control cover movements between states (e.g., avoid raising when closing for the evening)

            - **Feature Control**: Disable automatic transitions (e.g., stay shaded after sun disappears, don't open after ventilation ends)

            - **Daily Frequency Limits**: Prevent repeated actions (e.g., open only once per day)

            - **Hardware Compatibility**: Work around device-specific quirks with position/tilt commands


            <details>
            <summary><code><strong>CLICK HERE:</strong> Hardware-Specific Details</code></summary>


            <ins>Why use custom actions instead of default services?</ins><br />

            Some devices (e.g., Shelly, Homematic) have issues when 'set_cover_position' and 'set_cover_tilt_position' are executed sequentially.


            **Solutions:**

            - Shelly: Use script [cover_position_tilt.yaml](https://gist.github.com/lukasvice/b364724d84c3ac4e160f7a7d8fa37066)

            - Homematic: Use custom service [homematicip_local.set_cover_combined_position](https://github.com/SukramJ/custom_homematic?tab=readme-ov-file#homematicip_localset_cover_combined_position)

            - Other devices: Implement via "Additional Actions" in the Service Calls section

            </details>

          default: []
          selector:
            select:
              options:
                - label: "‚ÜïÔ∏è Don't raise cover when closing for the evening"
                  value: "prevent_higher_position_closing"
                - label: "‚¨áÔ∏è Keep shading position during evening close (don't lower further)"
                  value: "prevent_lowering_when_closing_if_shaded"
                - label: "‚òÄÔ∏è Don't end shading if cover is already closed"
                  value: "prevent_shading_end_if_closed"
                - label: "‚òÄÔ∏è Stay shaded: Don't open cover when sun shading ends"
                  value: prevent_opening_after_shading_end
                - label: "ü™ü Keep closed: Don't open cover when ventilation ends"
                  value: prevent_opening_after_ventilation_end
                - label: "üîß Use custom actions only (disable default set_cover_position/set_cover_tilt_position)"
                  value: "prevent_default_cover_actions"
                - label: "‚è±Ô∏è Open cover only once per day"
                  value: "prevent_opening_multiple_times"
                - label: "‚è±Ô∏è Close cover only once per day"
                  value: "prevent_closing_multiple_times"
                - label: "‚è±Ô∏è Shade cover only once per day"
                  value: "prevent_shading_multiple_times"
              multiple: true
              sort: false
              custom_value: false
              mode: list

    helper_section:

      name: "Cover Status Helper"
      icon: mdi:form-textbox
      collapsed: true
      input:
        cover_status_helper:
          name: "ü¶Æ Cover Status Helper"
          description: >-
            Helper used to store the last cover event. A separate helper must be created for each CCA automation.
            *Attention:* You will need to manually create a [input_text](https://my.home-assistant.io/redirect/helpers/) entity with a <ins>length of 254 chars</ins> for this.
          default: []
          selector:
            entity:
              domain: input_text

        drive_time:
          name: "‚è≤Ô∏è Cover Drive Time"
          description: >-
            Can be used to recognise manual control. Please round up a little and do not adjust too precisely. Is used to delay the trigger if too much or incorrect position data is sent back.
            <br /><br />
            Within this time, it is assumed that CCA has carried out the last action. Otherwise, CCA would react to its own commands and recognize them as manual intervention.
          default: 90
          selector:
            number:
              min: 0.0
              max: 180.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    position_section:
      name: "Cover Position Settings"
      icon: mdi:window-shutter-settings
      description: >-
        <center>
        <br />
        <strong>Important notes on configuring the position values</strong>
        <br />
        <strong>Position Logic:</strong><br />
        - For Blinds/Shutters: open_position (100%) > shading_position (25%) > close_position (0%)<br />
        - For Awnings: open_position (0%) < shading_position (75%) < close_position (100%)<br />
        Please ensure that all position values are unique and do not conflict with each other.
        <br /><br />
        </center>
      collapsed: true
      input:
        position_source:
          name: "üìç Position Source Type"
          description: >-
            How does your cover provide position information?
            <details>
            <summary><code><strong>CLICK HERE: When to use each option</strong></code></summary>

              - **current_position attribute** (Standard): Most covers use this. If CCA detects positions correctly, keep this setting.
              - **position attribute**: Select this if your cover entity has a 'position' attribute but no 'current_position' attribute. Check in Developer Tools ‚Üí States if unsure.
              - **Custom sensor**:   Use this if: Your cover doesn't report positions at all / You have an external sensor tracking the cover position / Manual position changes aren't detected with the other options

            </details>
          default: "current_position_attr"
          selector:
            select:
              options:
                - label: "Use current_position attribute (standard)"
                  value: "current_position_attr"
                - label: "Use position attribute"
                  value: "position_attr"
                - label: "Use custom position sensor"
                  value: "custom_sensor"
              mode: dropdown
        custom_position_sensor:
          name: "üìç Custom Position Sensor"
          description: "Select sensor that provides position (0-100%). Only used if 'Custom sensor' selected above"
          default: []
          selector:
            entity:
              domain: sensor

        cover_type:
          name: "üéØ Cover Type"
          description: >-
            Select the type of cover you want to control.
            <br /><br />
            <strong>Blind/Roller Shutter:</strong> Position 0% = closed (down), 100% = open (up). Shading uses lower positions.
            <br /><br />
            <strong>Awning/Sunshade:</strong> Position 0% = retracted (closed), 100% = extended (open). Shading uses higher positions.
            <br /><br />
            ‚ö†Ô∏è <strong>Note:</strong> Ventilation and tilt features are not available for awnings.
            <br /><br />
            <details>
            <summary><code><strong>CLICK HERE:</strong> Position value examples</code></summary>

            <strong>For Blinds/Shutters:</strong><br />
            - Open Position: 100% (fully up)<br />
            - Shading Position: 25% (partially down for sun protection)<br />
            - Ventilate Position: 30% (slightly down for air flow)<br />
            - Close Position: 0% (fully down)<br />
            <br />
            <strong>For Awnings:</strong><br />
            - Open Position: 0% (retracted/closed)<br />
            - Shading Position: 75% (extended for sun protection)<br />
            - Close Position: 100% (fully extended)<br />
            <br />
            <em>Note: Ventilate Position is not used for awnings.</em>

            </details>
          default: "blind"
          selector:
            select:
              options:
                - label: "ü™ü Blind / Roller Shutter (Standard)"
                  value: "blind"
                - label: "‚òÇÔ∏è Awning / Sunshade (Inverted)"
                  value: "awning"
              mode: dropdown

        open_position:
          name: "üîº Open Position"
          description: "What position should the cover be moved into when opening?"
          default: 100
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        close_position:
          name: "üîª Close Position"
          description: "What position should the cover be moved into when closing?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        ventilate_position:
          name: "üí® Ventilate Position"
          description: >-
            What position should the cover move to when the window is tilted?
            If closing is triggered and the contact sensor is 'on', the cover will move to this position instead of closing completely.
            <br /><br />Should not be 100. In this case please use 99. And please also note the information in the position tolerance.
          default: 30
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        shading_position:
          name: "ü•µ Sun Shading Position"
          description: "To which position should the cover be moved for shading?"
          default: 25
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: "%"

        position_tolerance:
          name: "„Ä∞Ô∏è Position Tolerance"
          description: >-
            Tolerance to be applied when comparing the current position with the to be position.
            These are absolute values. Not relative to the previous position values.
          default: 0
          selector:
            number:
              min: 0.0
              max: 20.0
              unit_of_measurement: "%"

    tilt_position_section:
      name: "Cover Tilt Position Settings"
      icon: mdi:image-filter-tilt-shift
      collapsed: true
      input:
        cover_tilt_wait_mode:
          name: "üîÑ Tilt Wait Mode"
          description: >-
            Choose how CCA waits before sending tilt commands:

            **Fixed Delay (Standard)**: Uses the configured tilt delay value.
            Works well for most devices.

            **Wait Until Idle (Z-Wave)**: Waits until cover reports 'open' or 'closed'
            state before sending tilt. Prevents tilt commands from being ignored on
            devices that block tilt during motor movement (e.g., Shelly Qubino Wave Shutter).

            If your tilt positions are unreliable, try switching to 'Wait Until Idle' mode.
          default: "fixed_delay"
          selector:
            select:
              options:
                - label: "‚è±Ô∏è Fixed Delay (Standard)"
                  value: "fixed_delay"
                - label: "‚è∏Ô∏è Wait Until Idle (Z-Wave devices)"
                  value: "wait_idle"
              mode: dropdown

        cover_tilt_wait_timeout:
          name: "üîÑ Tilt Wait Timeout"
          description: >-
            Maximum time to wait for cover to become idle before sending tilt command.
            Only used when 'Wait Until Idle' mode is selected.
          default: 30
          selector:
            number:
              min: 5
              max: 60
              unit_of_measurement: seconds
              step: 1
              mode: slider

        tilt_delay:
          name: "üïõ Default Tilt Delay"
          description: >-
            Delay between <em>set_cover_position</em> and <em>set_cover_tilt_position</em>.
            Only necessary when using the tilt functions.
            This separates the two commands in terms of time.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        cover_tilt_config:
          name: "üìê Tilt Position Feature"
          description: >-
            ‚ö†Ô∏è <strong>Note:</strong> Tilt control is only available for blinds/shutters, not for awnings.
            <br /><br />
            If the cover and the integration support it, the tilt position of the cover can be set. The standard attribute ‚Äòcurrent_tilt_position‚Äô is used for this.
          default: cover_tilt_disabled
          selector:
            select:
              options:
                - label: "‚úÖ Enable Tilt Position Control"
                  value: "cover_tilt_enabled"
                - label: "‚ùå Disable Tilt Position Control"
                  value: "cover_tilt_disabled"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        cover_tilt_reposition_config:
          name: "üìê Tilt Reposition Feature"
          description: >-
            If Tilt Reposition Feature is enabled you can choose if the blinds are closed before tilting to a new position.
            In some cases tilting the blinds in small steps can lead to false positions. This is because of the minimum time the motor needs to run.
            If the runtime between current tilt position and target tilt position is to small the motor will not stop at the right position.
            Thus the blinds will be preclosed to 0 and then run to the target position.
          default: cover_tilt_reposition_disabled
          selector:
            select:
              options:
                - label: "‚úÖ Enable Tilt Reposition Control"
                  value: "cover_tilt_reposition_enabled"
                - label: "‚ùå Disable Tilt Reposition Control"
                  value: "cover_tilt_reposition_disabled"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        open_tilt_position:
          name: "üîº Open Tilt Position"
          description: "To which tilt position should the cover be moved when opening?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        close_tilt_position:
          name: "üîª Close Tilt Position"
          description: "To which tilt position should the cover be moved when closing?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        ventilate_tilt_position:
          name: "üí® Ventilate Tilt Position"
          description: "To which tilt position should the cover be moved for ventilation?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_position_0:
          name: "ü•µ Sun Shading Tilt Position"
          description: "Minimum tilt position for shading. The cover will be tilted to this position if the sun elevation is below the value of elevation 1."
          default: 0
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_position_1:
          name: "ü•µ Sun Shading Tilt Position 1"
          description: "To which tilt position should the cover be moved for shading when the sun is above elevation 1?"
          default: 20
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_1:
          name: "ü•µ Sun Shading Tilt Elevation 1"
          description: "Sun elevation for tilt position 1."
          default: 20
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0
        shading_tilt_position_2:
          name: "ü•µ Sun Shading Tilt Position 2"
          description: "To which tilt position should the cover be moved for shading when the sun is above elevation 2?"
          default: 37
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_2:
          name: "ü•µ Sun Shading Tilt Elevation 2"
          description: "Sun elevation for tilt position 2."
          default: 30
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0
        shading_tilt_position_3:
          name: "ü•µ Sun Shading Tilt Position 3"
          description: "To which tilt position should the cover be moved for shading when the sun is above elevation 3?"
          default: 50
          selector:
            number:
              min: 0
              max: 100
              unit_of_measurement: "%"
        shading_tilt_elevation_3:
          name: "ü•µ Sun Shading Tilt Elevation 3"
          description: "Sun elevation for tilt position 3."
          default: 48
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: ¬∞
              mode: slider
              step: 1.0

    time_section:
      name: "Time Control Configuration"
      icon: mdi:clock-time-two-outline
      collapsed: true
      description: >-
        <center>
        <br />
        <strong>Time Control Modes:</strong><br />
        - Input Fields: Use time inputs directly in this section (recommended)<br />
        - Schedule Helper: Use external schedule entity for flexible weekday configuration<br />
        - Disabled: No time-based triggers, only brightness/sun/manual control<br />
        <br />
        For comprehensive explanations, examples, and timing diagrams, see:
        <a href="https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/TIME_CONTROL_VISUALIZATION.md">Time Control Guide</a><br />
        <br /><br />
        </center>
      input:
        time_control:
          name: "‚è≤Ô∏è Selection of time control options"
          description: >-
            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>
            <br />
            <ins>Input fields for time control</ins><br />
            The times for opening and closing the cover are configured here in the blueprint.
            There are various input fields here for this purpose.
            Even if you only want to control the covers using brightness values or the sun elevation,
            it is important to specify times. The times are used to divide the day into "morning" (up) and "evening" (down).
            <br /><br />
            <ins>Calendar Control</ins><br />
            You can use a Home Assistant calendar to define when covers should be open or closed.
            Create calendar events with titles "Open Cover" (for daytime) or "Close Cover" (for evening).
            The automation reacts immediately when events start or end.
            <br /><br />
            <ins>Disable time control and all time triggers</ins><br />
            Finally, you can also deactivate the time control completely.
            This means that the roller shutters are not opened or closed via time triggers.
            The sun-elevation and brightness control then also runs completely independently.

            </details>

          default: time_control_input
          selector:
            select:
              options:
                - label: "‚úèÔ∏è Use the time input fields in this blueprint section"
                  value: "time_control_input"
                - label: "üìÖ Use a Home Assistant calendar"
                  value: "time_control_calendar"
                - label: "üö´ Disable time control and all time triggers"
                  value: "time_control_disabled"
              sort: false
              multiple: false
              custom_value: false

        time_up_early:
          name: "üîº Time For Drive Up - Early On Workdays"
          description: >-
            The earliest time at which the cover may be opened. The cover will be opened if <ins>AFTER</ins> this time the defined brightness
            or sun-elevation value is high enough. (**NOTE**: A resident must also be awake if one is defined).
          default: "06:00:00"
          selector:
            time: {}

        time_up_early_non_workday:
          name: "üîº Time For Drive Up - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "07:00:00"
          selector:
            time: {}

        time_up_late:
          name: "üîº Time For Drive Up - Late On Workdays"
          description: >-
            The latest time at which the cover should be opened.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be opened.
            (**NOTE**: If a resident has been defined and the resident is still asleep, then the cover will NOT be opened.)
          default: "08:00:00"
          selector:
            time: {}

        time_up_late_non_workday:
          name: "üîº Time For Drive Up - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "08:00:00"
          selector:
            time: {}

        time_down_early:
          name: "üîª Time For Drive Down - Early On Workdays"
          description: >-
            The earliest time at which the cover may be closed.
            The cover will be closed if <ins>AFTER</ins> this time the defined brightness or sun-elevation value is low enough.
          default: "16:00:00"
          selector:
            time: {}

        time_down_early_non_workday:
          name: "üîª Time For Drive Down - Early On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
          default: "16:00:00"
          selector:
            time: {}

        time_down_late:
          name: "üîª Time For Drive Down - Late On Workdays"
          description: >-
            The latest time at which the cover should be closed.
            If the required brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this time, the cover will still be closed.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

        time_down_late_non_workday:
          name: "üîª Time For Drive Down - Late On Non-Workdays"
          description: >-
            As directly above, but for non-workdays.
            <br />
            Please do not enter 0:00, because that would be the next day!
          default: "22:00:00"
          selector:
            time: {}

        workday_sensor:
          name: "üíº Sensor For Workday Today"
          description: >-
            It may be desired to open a cover at a different time on work days than on non-work days.
            The corresponding binary sensor can be defined here. If not set, the cover will open every time at time_up_early.
            <br /><br />
            I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br />
            Example: `binary_sensor.workday_today`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        workday_sensor_tomorrow:
          name: "üíº Sensor For Workday Tomorrow (only for closing)"
          description: >-
            When <ins>closing</ins> the blinds, you have the option of checking the times for tomorrow rather than the current day.
            This has the advantage that you can <ins>close</ins> the blinds earlier if <ins>tomorrow</ins> is a working day.
            This makes sense if, for example, there is school tomorrow but today is actually still the weekend.
            But the child has to go to bed earlier.<br />
            If this field is not configured here, the normal working day sensor is used.
            <br /><br />
            I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br />
            Example: `binary_sensor.workday_tomorrow`
            <br /><br />`Optional`
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor

        calendar_entity:
          name: "üìÖ Calendar Entity"
          description: >-
            Select a Home Assistant calendar for time control.

            <details>
            <summary><code><strong>CLICK HERE:</strong> How to use calendar control</code></summary>


            **Event Titles (case-insensitive):**
              - **"Open Cover"** - Marks the daytime window (cover should be open)
              - **"Close Cover"** - Marks the evening window (cover should be closed)

            **How it works:**
              - When an "Open Cover" event starts, the automation treats it like morning time
              - When a "Close Cover" event starts, the automation treats it like evening time
              - Events can span multiple days
              - Multiple events per day are supported

            **Example schedule:**
              - Monday to Friday: "Open Cover" from 06:00-20:00
              - Saturday/Sunday: "Open Cover" from 08:00-22:00
              - Automatically handles weekday/weekend differences

            **Advantages over time input:**
              - No need for separate workday/non-workday times
              - Can define different times for each day
              - Can create exceptions (holidays, vacations)
              - Changes take effect immediately without automation reload

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain: calendar
              multiple: false

        calendar_open_title:
          name: "üìÇ Open Event Title"
          description: >-
            Title of calendar events that define the daytime window
            (case-insensitive match).
            Default: "Open Cover".
          default: "Open Cover"
          selector:
            text: {}

        calendar_close_title:
          name: "üìÅ Close Event Title"
          description: >-
            Title of calendar events that define the evening/close window
            (case-insensitive match).
            Default: "Close Cover".
          default: "Close Cover"
          selector:
            text: {}

    brightness_section:
      name: "Brightness Configuration"
      description: >-
        <br />
        <center><code>Settings if the feature ‚ÄòüîÖ - Add Brightness Condition‚Äô has been activated above.</code></center><br />
      icon: mdi:brightness-5
      collapsed: true
      input:
        default_brightness_sensor:
          name: "üîÖ Default Brightness Sensor"
          description: "This default brightness sensor can be defined here, which is used for daily up and down."
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        brightness_time_duration:
          name: "üîÖ Brightness Time Duration"
          description: "Defines the time to given brightness sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        brightness_up:
          name: "üîÖ Brightness Value For Opening The Cover"
          description: "At what brightness value should the cover be opened?"
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        brightness_down:
          name: "üîÖ Brightness Value For Closing The Cover"
          description: "At what brightness value should the cover be closed? Must be lower then the brightness up value."
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        brightness_hysteresis:
          name: "üîÖ Brightness Hysteresis Value"
          description: "Cover will open only when brightness exceeds (brightness_up + hysteresis), and close only when it drops below (brightness_down - hysteresis). Prevents frequent open/close cycles."
          default: 0
          selector:
            number:
              min: 0
              max: 10000
              step: 100
              mode: slider
              unit_of_measurement: "lx"

    sun_section:
      name: "Sun Elevation Settings"
      description: >-
        <br />
        <center><code>Settings if the feature ‚Äò‚òÄÔ∏è - Add Sun Elevation Condition‚Äô has been activated above.</code></center><br />
      icon: mdi:weather-sunny
      collapsed: true
      input:
        default_sun_sensor:
          name: "‚òÄÔ∏è Sun Sensor"
          description: >-
            Which sensors provides attributes with current azimuth and elevation of sun.
            I strongly suggest to use sun.sun ([Sun integration](https://www.home-assistant.io/integrations/sun/)).
            Please make sure that the integration is activated and provides the attributes.
            This sensor is also used for sun protection / sunshade control.
            <br /><br />
            <ins>A few examples of threshold values:</ins>
            <ul>
            <li>+18¬∞ Astronomical Dusk</li>
            <li>+12¬∞ Nautical Dusk</li>
            <li>+6¬∞ Dusk</li>
            <li>0¬∞ Sunrise/Sunset (Default)</li>
            <li>-6¬∞ Civil Dawn</li>
            <li>-12¬∞ Nautical Dawn</li>
            <li>-18¬∞ Astronomical Dawn/Night</li>
            </ul>
            <br />`Optional` / `Shading`
          default: "sun.sun"
          selector:
            entity:
              filter:
                - domain:
                    - sun

        sun_time_duration:
          name: "‚òÄÔ∏è Sun Time Duration"
          description: "Defines the time to given sun sensor must be stay above/below the thresholds."
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds

        sun_elevation_mode:
          name: "‚òÄÔ∏è Sun Elevation Mode"
          description: >-
            **Select how sun elevation thresholds are determined:**
            <br /><br />
            **üîí Fixed Mode** (Default)
            <br />
            Uses only the fixed values configured below (Sun Elevation Value For Opening/Closing).
            Sensors are ignored even if configured.
            <br /><br />
            **üìä Dynamic Mode**
            <br />
            Uses only the sensor values (Sun Elevation Up/Down Sensor).
            Fixed values are ignored. Sensors must be configured and provide valid numeric values.
            <br /><br />
            **üîÑ Hybrid Mode**
            <br />
            Combines both: Sensor value + Fixed value as offset.
            Example: Sensor=2.0¬∞ + Fixed=1.5¬∞ = Threshold of 3.5¬∞.
            Allows seasonal adaptation with manual fine-tuning offset.
            <br /><br />
            `Optional` / `Default: Fixed`
          default: "fixed"
          selector:
            select:
              options:
                - label: "üîí Fixed - Use only fixed values"
                  value: "fixed"
                - label: "üìä Dynamic - Use only sensor values"
                  value: "dynamic"
                - label: "üîÑ Hybrid - Sensor + fixed value as offset"
                  value: "hybrid"
              sort: false
              multiple: false
              custom_value: false

        sun_elevation_up:
          name: "‚òÄÔ∏è Sun Elevation Value For Opening The Cover"
          description: >-
            **Fixed Mode**: Direct threshold value for opening.
            <br />
            **Dynamic Mode**: Ignored (sensor value is used).
            <br />
            **Hybrid Mode**: Added as offset to sensor value.
            <br /><br />
            The cover will be <ins>opened</ins> if the sun elevation is over the calculated threshold.
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        sun_elevation_down:
          name: "‚òÄÔ∏è Sun Elevation Value For Closing The Cover"
          description: >-
            **Fixed Mode**: Direct threshold value for closing.
            <br />
            **Dynamic Mode**: Ignored (sensor value is used).
            <br />
            **Hybrid Mode**: Added as offset to sensor value.
            <br /><br />
            The cover will be <ins>closed</ins> if the sun elevation is under the calculated threshold.
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        sun_elevation_up_sensor:
          name: "‚òÄÔ∏è Sun Elevation Up Sensor (Dynamic/Hybrid - Optional)"
          description: >-
            Optional sensor that provides a **dynamic elevation threshold** for opening based on season.
            This sensor value is compared with the **sun elevation from the sun integration** (`sun.sun` attribute `elevation`).
            <br /><br />
            **Behavior depends on Sun Elevation Mode:**
            <br />
            ‚Ä¢ **Fixed Mode**: Sensor is ignored even if configured
            <br />
            ‚Ä¢ **Dynamic Mode**: Sensor value is used directly as threshold (required)
            <br />
            ‚Ä¢ **Hybrid Mode**: Sensor value + Fixed value as combined threshold
            <br /><br />
            **How it works**: The cover opens when the **current sun elevation is higher** than the calculated threshold.
            The sensor provides the threshold (in degrees) ‚Äî dynamic instead of fixed in the blueprint.
            <br /><br />
            **Example (Dynamic Mode)**: Sensor value = 2.5¬∞ ‚Üí Cover opens when `sun.sun` elevation rises above 2.5¬∞.
            In summer (sensor = 5.0¬∞) the cover opens later than in winter (sensor = -2.0¬∞), matching seasonal sunrise times.
            <br /><br />
            **Example (Hybrid Mode)**: Sensor value = 2.0¬∞, Fixed value = 1.5¬∞ ‚Üí Threshold = 3.5¬∞.
            Allows seasonal adaptation with manual fine-tuning.
            <br /><br />
            **Multiple covers**: For different behavior per cover (e.g., east vs. west facing), create multiple template sensors with different thresholds.
            <br /><br />
            **Recommended options**:<br />
            ‚Ä¢ **Template sensor** with seasonal interpolation for automatic year-round adaptation ([Guide](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/DYNAMIC_SUN_ELEVATION.md))<br />
            ‚Ä¢ **Input Number helper** for manual GUI-based configuration via dashboard
            <br /><br />
            `Optional` / `Required for Dynamic Mode`
          default: []
          selector:
            entity:
              filter:
                - domain: [sensor, input_number]

        sun_elevation_down_sensor:
          name: "‚òÄÔ∏è Sun Elevation Down Sensor (Dynamic/Hybrid - Optional)"
          description: >-
            Optional sensor that provides a **dynamic elevation threshold** for closing based on season.
            This sensor value is compared with the **sun elevation from the sun integration** (`sun.sun` attribute `elevation`).
            <br /><br />
            **Behavior depends on Sun Elevation Mode:**
            <br />
            ‚Ä¢ **Fixed Mode**: Sensor is ignored even if configured
            <br />
            ‚Ä¢ **Dynamic Mode**: Sensor value is used directly as threshold (required)
            <br />
            ‚Ä¢ **Hybrid Mode**: Sensor value + Fixed value as combined threshold
            <br /><br />
            **How it works**: The cover closes when the **current sun elevation is lower** than the calculated threshold.
            The sensor provides the threshold (in degrees) ‚Äî dynamic instead of fixed in the blueprint.
            <br /><br />
            **Example (Dynamic Mode)**: Sensor value = 0.5¬∞ ‚Üí Cover closes when `sun.sun` elevation sets below 0.5¬∞.
            In summer (sensor = 2.0¬∞) the cover closes later than in winter (sensor = -4.0¬∞), matching seasonal sunset times.
            <br /><br />
            **Example (Hybrid Mode)**: Sensor value = 0.0¬∞, Fixed value = -1.0¬∞ ‚Üí Threshold = -1.0¬∞.
            Allows seasonal adaptation with manual fine-tuning.
            <br /><br />
            **Multiple covers**: For different behavior per cover (e.g., east vs. west facing), create multiple template sensors with different thresholds.
            <br /><br />
            **Recommended options**:<br />
            ‚Ä¢ **Template sensor** with seasonal interpolation for automatic year-round adaptation ([Guide](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/DYNAMIC_SUN_ELEVATION.md))<br />
            ‚Ä¢ **Input Number helper** for manual GUI-based configuration via dashboard
            <br /><br />
            `Optional` / `Required for Dynamic Mode`
          default: []
          selector:
            entity:
              filter:
                - domain: [sensor, input_number]

    contacts_section:
      name: "Contact Sensors for Ventilation"
      description: >-
        <br />
        <center><code>Settings if the feature ‚Äòüí® - Enable ventilation mode‚Äô has been activated above.</code></center><br />
        <center><code>All these settings are optional / A Cover Status Helper is required!</code></center><br />
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        contact_window_opened:
          name: "üö™ Contact Sensor For Open Window (Full Ventilation)"
          description: >-
            Contact sensor of a door or window handle for detecting <ins>total opening</ins>.
            If this sensor switches to on/true, the cover is <ins>fully opened</ins>.
            At the same time, a lockout protection is <ins>always</ins> activated.
            The cover is not closed and the sun shading is not activated when the contact is open.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor.
            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in both fields for the contact sensors. This does not work and leads to strange situations.

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

        contact_window_tilted:
          name: "üí® Contact Sensor For Tilted Window (Partial Ventilation)"
          description: >-
            The contact sensor is required for the <ins>partial</ins> ventilation mode.
            If the contact changes to on/true, the cover is moved to the <ins>ventilation</ins> position.
            The prerequisite is that the cover is already closed.
            After the status changes to off/false, the close position is activated again.
            The same applies in the shading-out situation.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor.
            If a three-way sensor is available, it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593) in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in both fields for the contact sensors. This does not work and leads to strange situations.

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - binary_sensor
                    - input_boolean

        lockout_tilted_options:
          name: "üí® Lockout protection for window tilted"
          description: >-
            For the tilted window (or door, of course), you can individually specify where a lockout protection should be used.
          default: []
          selector:
            select:
              options:
                - label: "üõ°Ô∏è Lockout protection when closing the cover"
                  value: "lockout_tilted_closing"
                - label: "üõ°Ô∏è Lockout protection when starting the sun shading"
                  value: "lockout_tilted_shading_start"
                - label: "üõ°Ô∏è Lockout protection when the sun shading is ended"
                  value: "lockout_tilted_shading_end"
              sort: false
              multiple: true
              custom_value: false

        auto_ventilate_options:
          name: "üí® Ventilation Configuration"
          description: >-
            Various different ventilation options.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


              - <ins>Enables a calculated delay after the window is closed:</ins>
                <br />
                Normally, when the window contact is closed, there is no delay in the upcoming drives. If you do want this, you can activate it here.
                <br /><br />
                The "Fixed Drive Delay" and "Random Drive Delay" settings which are already used everywhere are then used.
                <br /><br />
              - <ins>Allow ventilation even if cover is already in a higher position:</ins>
                <br />
                Activate ventilation mode even if the current position of the cover is already higher than the ventilation position.
                <br /><br />
              - <ins>Using the ventilation position when the sun shade is ended:</ins>
                <br />
                The cover can also be moved to the ventilation position when the sun protection/sun shading is ended.
                Normally, the cover would be fully opened when the shading is ended.
                <br />
                To be honest, it makes no sense to switch to the ventilation position during the day if more air can flow in when the cover is open.

            </details>
          default: []
          selector:
            select:
              options:
                - label: "üí® Enables a calculated delay after the window is closed"
                  value: "ventilation_delay_enabled"
                - label: "üí® Allow ventilation even if cover is already in a higher position"
                  value: "ventilation_if_lower_enabled"
                - label: "üí® Using the ventilation position when the sun shading is ended (instead of opening it completely)"
                  value: "ventilation_after_shading_end"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        contact_delay_trigger:
          name: "üïõ Contact Trigger Delay"
          description: >-
            How many seconds must the status of the contact sensors be valid for the automation to trigger?

            ‚ö†Ô∏è **Race Condition Protection:**
            If you have multiple contact sensors (e.g., window sensor + lock sensor) that can change
            simultaneously, increase this value to prevent race conditions.

            **Symptoms of race conditions:**
            - Cover closes despite lockout sensor being active
            - Check Home Assistant logs for "max_exceeded: warning" messages
            - If you see these warnings frequently, increase this delay
          default: 2
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        contact_delay_status:
          name: "üïõ Contact Sensor Status Delay"
          description: >-
            How long should the automation wait until a trigger of a contact sensor becomes valid?
            This may be necessary if the status of a three-state sensor has an intermediate value for a short time.
          default: 3
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    shading_section:
      name: "Sun Shading / Sun Protection"
      description: >-
        <br />
        <center><code>Settings if the feature 'ü•µ - Enable automatic sun protection / sunshade control' has been activated above.</code></center><br />
        <center><code>All these settings are optional / A Cover Status Helper is required! / The attributes of default sun sensor (configured above) is used.</code></center><br />
      icon: mdi:shield-sun-outline
      collapsed: true
      input:

        shading_conditions_start_and:
          name: "üåû Shading START - Required Conditions (AND)"
          description: >-
            **Conditions that MUST ALL be met to START shading**

            <details>
            <summary><code><strong>CLICK HERE:</strong> How START conditions work</code></summary>


            **Required (AND) conditions for START:**

            - ALL selected conditions must be valid

            - If ANY fails, shading will NOT start

            - Use for critical conditions


            **Example - Conservative approach:**

            - Select ALL: Azimuth, Elevation, Brightness, Temperature

            - Result: Shading only when everything is perfect


            **Example - Flexible approach:**

            - Select: Azimuth, Elevation (sun position)

            - Leave others for OR list

            - Result: Sun must be in range, plus other criteria

            </details>
          default:
            - cond_azimuth
            - cond_elevation
            - cond_brightness
            - cond_temp1
            - cond_temp2
            - cond_forecast_temp
            - cond_forecast_weather
          selector:
            select:
              multiple: true
              mode: dropdown
              options:
                - label: "üìê Sun Azimuth (within configured range)"
                  value: "cond_azimuth"
                - label: "üìà Sun Elevation (within configured range)"
                  value: "cond_elevation"
                - label: "üîÜ Brightness (above start threshold)"
                  value: "cond_brightness"
                - label: "1Ô∏è‚É£ Temperature Sensor 1 (above threshold)"
                  value: "cond_temp1"
                - label: "2Ô∏è‚É£ Temperature Sensor 2 (above threshold)"
                  value: "cond_temp2"
                - label: "üìä Forecast Temperature (above threshold)"
                  value: "cond_forecast_temp"
                - label: "üå¶Ô∏è Forecast Weather Conditions (matching configured conditions)"
                  value: "cond_forecast_weather"

        shading_conditions_start_or:
          name: "üåû Shading START - Optional Conditions (OR)"
          description: >-
            **Conditions where AT LEAST ONE must be met to START shading**

            <details>
            <summary><code><strong>CLICK HERE:</strong> When to use OR conditions</code></summary>


            **Optional (OR) conditions for START:**

            - At least ONE must be valid

            - Useful for redundant sensors

            - Useful for alternative triggers


            **Example - Redundant temperature sensors:**

            - AND: Azimuth, Elevation, Brightness

            - OR: Temp1, Temp2

            - Result: Sun + Brightness + (Temp1 OR Temp2)

            - If Temp1 fails, Temp2 can still trigger


            **Combined logic:**

            - Final = (ALL AND conditions) AND (ONE OR condition)

            </details>
          default: []
          selector:
            select:
              multiple: true
              mode: dropdown
              options:
                - label: "üìê Sun Azimuth (within configured range)"
                  value: "cond_azimuth"
                - label: "üìà Sun Elevation (within configured range)"
                  value: "cond_elevation"
                - label: "üîÜ Brightness (above start threshold)"
                  value: "cond_brightness"
                - label: "1Ô∏è‚É£ Temperature Sensor 1 (above threshold)"
                  value: "cond_temp1"
                - label: "2Ô∏è‚É£ Temperature Sensor 2 (above threshold)"
                  value: "cond_temp2"
                - label: "üìä Forecast Temperature (above threshold)"
                  value: "cond_forecast_temp"
                - label: "üå¶Ô∏è Forecast Weather Conditions (matching configured conditions)"
                  value: "cond_forecast_weather"

        shading_conditions_end_and:
          name: "üå•Ô∏è Shading END - Required Conditions (AND)"
          description: >-
            **Conditions that MUST ALL become invalid to END shading**

            <details>
            <summary><code><strong>CLICK HERE:</strong> How END conditions work</code></summary>


            **Required (AND) conditions for END:**

            - ALL selected conditions must become invalid

            - Shading continues if ANY is still valid

            - Use for stable shading (avoid flickering)


            **Example - Quick response:**

            - AND: (empty)

            - OR: Azimuth, Elevation, Brightness

            - Result: End immediately when ANY condition fails


            **Example - Stable shading:**

            - AND: Brightness, Temp1

            - OR: (empty)

            - Result: Keep shading until BOTH brightness AND temp drop


            **Tip:** Usually END should be MORE permissive than START

            </details>
          default: []
          selector:
            select:
              multiple: true
              mode: dropdown
              options:
                - label: "üìê Sun Azimuth (outside configured range)"
                  value: "cond_azimuth"
                - label: "üìà Sun Elevation (outside configured range)"
                  value: "cond_elevation"
                - label: "üîÜ Brightness (below end threshold)"
                  value: "cond_brightness"
                - label: "1Ô∏è‚É£ Temperature Sensor 1 (below threshold)"
                  value: "cond_temp1"
                - label: "2Ô∏è‚É£ Temperature Sensor 2 (below threshold)"
                  value: "cond_temp2"
                - label: "üìä Forecast Temperature (above threshold)"
                  value: "cond_forecast_temp"
                - label: "üå¶Ô∏è Forecast Weather Conditions (matching configured conditions)"
                  value: "cond_forecast_weather"

        shading_conditions_end_or:
          name: "üå•Ô∏è Shading END - Optional Conditions (OR)"
          description: >-
            **Conditions where AT LEAST ONE must become invalid to END shading**

            <details>
            <summary><code><strong>CLICK HERE:</strong> Typical END configurations</code></summary>


            **Optional (OR) conditions for END:**

            - At least ONE must become invalid to end

            - Shading ends quickly when conditions change


            **Recommended: Quick sun position response**

            - AND: (empty)

            - OR: Azimuth, Elevation

            - Result: End immediately when sun moves out of range


            **Alternative: Keep shading longer**

            - AND: Azimuth, Elevation

            - OR: Brightness, Temperature

            - Result: End only when sun is wrong AND (dark OR cold)


            **Combined logic:**

            - Final = (ALL AND invalid) OR (ONE OR invalid)

            </details>
          default:
            - cond_azimuth
            - cond_elevation
            - cond_brightness
            - cond_temp1
            - cond_temp2
            - cond_forecast_temp
            - cond_forecast_weather
          selector:
            select:
              multiple: true
              mode: dropdown
              options:
                - label: "üìê Sun Azimuth (outside configured range)"
                  value: "cond_azimuth"
                - label: "üìà Sun Elevation (outside configured range)"
                  value: "cond_elevation"
                - label: "üîÜ Brightness (below end threshold)"
                  value: "cond_brightness"
                - label: "1Ô∏è‚É£ Temperature Sensor 1 (below threshold)"
                  value: "cond_temp1"
                - label: "2Ô∏è‚É£ Temperature Sensor 2 (below threshold)"
                  value: "cond_temp2"
                - label: "üìä Forecast Temperature (above threshold)"
                  value: "cond_forecast_temp"
                - label: "üå¶Ô∏è Forecast Weather Conditions (matching configured conditions)"
                  value: "cond_forecast_weather"

        shading_azimuth_start:
          name: "üìê Sun Shading - Azimuth Start Value"
          description: "What is the minimum azimuth at which the sun hits the window? (Shading will start)"
          default: 95
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_azimuth_end:
          name: "üìê Sun Shading - Azimuth End Value"
          description: "What is the maximum azimuth at which the sun hits the window? (Shading will stop)"
          default: 265
          selector:
            number:
              min: 0
              max: 365
              unit_of_measurement: "¬∞"

        shading_elevation_min:
          name: "üìà Sun Shading - Elevation Minimum Value"
          description: "Starting from which elevation of the sun should the window be shaded? (Here it makes sense to consider surrounding buildings, trees, etc.)."
          default: 25
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_elevation_max:
          name: "üìà Sun Shading - Elevation Maximum Value"
          description: "What is the maximal elevation for elevation? (In most cases, 90 degrees is probably the most reasonable value. However, this can also be different due to surrounding buildings, etc.)."
          default: 90
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: ¬∞
              step: 0.1
              mode: slider

        shading_brightness_sensor:
          name: "üîÜ Sun Shading - Brightness Sensor"
          description: "This sensor is only used for shading."
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_sun_brightness_start:
          name: "üîÜ Sun Shading - Brightness Start Value"
          description: "The minimum brightness value from which shading should start. (Must be above the value of brightness end!)"
          default: 35000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_sun_brightness_end:
          name: "üîÜ Sun Shading - Brightness End Value"
          description: "The brightness value from which shading is no longer necessary. (Must be below the value of brightness start!)."
          default: 25000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0

        shading_sun_brightness_hysteresis:
          name: "üîÜ Sun Shading - Brightness Hysteresis"
          description: "Hysteresis value to prevent flickering. The brightness must exceed (start + hysteresis) to activate shading and fall below (end - hysteresis) to deactivate it. See: [FAQ - How does hysteresis work?](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md#q-how-does-hysteresis-work)"
          default: 0
          selector:
            number:
              min: 0.0
              max: 10000.0
              unit_of_measurement: lx
              step: 100.0

        shading_temperatur_sensor1:
          name: "1Ô∏è‚É£ Sun Shading - Temperature Sensor 1 (eg. indoor)"
          description: >-
            This is the first temperature sensor used for sun shading logic.<br />
            For example, you can use the current **indoor temperature** as a condition to trigger shading.
          selector:
            entity:
              filter:
                - domain:
                    - sensor
          default: []

        shading_min_temperatur1:
          name: "1Ô∏è‚É£ Sun Shading - Temperature Sensor 1 Minimum Value"
          description: "Minimum temperature for sensor 1 above which shading should occur."
          default: 18
          selector:
            number:
              min: 0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperature_hysteresis1:
          name: "1Ô∏è‚É£ Sun Shading - Temperature Sensor 1 Hysteresis Value"
          description: "Shading will end only when temperature drops below (minimum - hysteresis value) to prevent frequent open/close cycles. See: [FAQ - How does hysteresis work?](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md#q-how-does-hysteresis-work)"
          default: 0.2
          selector:
            number:
              min: 0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperatur_sensor2:
          name: "2Ô∏è‚É£ Sun Shading - Temperature Sensor 2 (eg. outdoor)"
          description: >-
            This is an optional secondary temperature sensor, typically used for **outdoor temperature**.
            <br />
            It can serve as an additional condition for sun shading logic.
            <br /><br />
            This sensor also plays a role in the calculation of the <ins>Sun Shading - Forecast Temperature Value</ins>. Please refer to that section for more details.
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - sensor

        shading_min_temperatur2:
          name: "2Ô∏è‚É£ Sun Shading - Temperature Sensor 2 Minimum Value"
          description: "Minimum temperature for sensor 2 above which shading should occur."
          default: 18
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_temperature_hysteresis2:
          name: "2Ô∏è‚É£ Sun Shading - Temperature Sensor 2 Hysteresis Value"
          description: "Shading will end only when temperature drops below (minimum - hysteresis value) to prevent frequent open/close cycles. See: [FAQ - How does hysteresis work?](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md#q-how-does-hysteresis-work)"
          default: 0.2
          selector:
            number:
              min: 0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_forecast_sensor:
          name: "üìä Sun Shading - Forecast Weather Entity"
          description: >-
            Weather entity for forecast data (temperature & conditions).
            This is the primary and recommended method for forecast-based shading.

            <details>
              <summary><code><strong>CLICK HERE:</strong> How to configure</code></summary>

              Select a weather entity (e.g., weather.home, weather.openweathermap).

              The system will:

              - Query forecast temperature for comparison

              - Check weather conditions if configured

              - Use daily or hourly forecast based on your selection below

              **Most users should use this field.**

              The idea is that it can happen, especially in spring, that the value of the
              <em>Forecast Temperature Value</em> is exceeded by strong solar radiation and
              the shading would be started. However, in spring you may not want shading,
              but the solar radiation as a welcome, free heating is desired.
              So you can define via the forecast that shading is only started at an
              expected daily maximum temperature.

            </details>
          default: []
          selector:
            entity:
              filter:
                - domain: weather

        shading_forecast_type:
          name: "üìä Sun Shading - Forecast Source"
          description: >-
            Please select whether you want to use the **daily** or **hourly** weather forecast.
            This only works if a weather entity has been configured above.
            <br />
            The first entry in the forecast array will always be used ‚Äî this corresponds to the current day or current hour.
            <br /><br />
            Note: Your weather entity must support `weather.get_forecasts`, which was introduced in Home Assistant 2023.9.
            <br /><br />
            Alternatively, you can choose **not to use** the forecast service at all.
            In that case, the current weather attributes from the weather entity will be used instead.
            <br /><br />
            **Recommendation:** Using the **daily forecast** is generally preferred for sun shading purposes.
            <br /><br />
            **Ignored when using temperature sensor below.**
          default: daily
          selector:
            select:
              options:
                - label: "Use the daily weather forecast service"
                  value: "daily"
                - label: "Use the hourly weather forecast service"
                  value: "hourly"
                - label: "Do not use a weather forecast, but the current weather attributes"
                  value: "weather_attributes"

        shading_forecast_temp_sensor:
          name: "üìä Sun Shading - Direct Temperature Sensor (Alternative)"
          description: >-
            **Alternative method:** Use a sensor that directly provides forecasted max temperature.

            <details>
              <summary><code><strong>CLICK HERE:</strong> When to use this</code></summary>

              Use this if:

              - Your weather integration provides dedicated forecast sensors

              - You want better performance (no forecast service calls)

              - You have custom template sensors for forecast temperature

              Examples:

              - sensor.pirateweather_daytime_high_apparent_temperature_0d

              - sensor.met_no_forecast_temperature_max

              - sensor.openweathermap_forecast_temperature

              **Priority:** If configured, this takes priority over weather entity above.

              **Limitation:** Weather condition checks are not available with sensors.

            </details>

          default: []
          selector:
            entity:
              filter:
                - domain: sensor

        shading_forecast_temp:
          name: "üìä Sun Shading - Forecast Temperature Value"
          description: >-
              This setting defines the <strong>minimum temperature threshold</strong> based on the forecast at which shading should be activated.
              If the forecasted temperature exceeds this value, the shading system will respond accordingly.

              - Minimum temperature threshold for shading activation.

              - Works with both weather entity and temperature sensor.

              - Leave empty to disable temperature-based forecast shading.

              <details>
                <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>

                To enhance reliability, the system can compare this threshold against two sources:

                - The forecasted temperature (this comparison is always active)

                - Temperature Sensor 2 (e.g. outdoor) (can be enabled via the checkbox in the next configuration field)

              </details>
          default: []
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_forecast_temp_hysteresis:
          name: "üìä Sun Shading - Forecast Temperature Hysteresis"
          description: >-
              Prevents frequent on/off cycles near threshold.

              - Shading starts: forecast > (threshold + hysteresis)

              - Shading ends: forecast < (threshold - hysteresis)


              See: [FAQ - How does hysteresis work?](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md#q-how-does-hysteresis-work)
          default: 0
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: "¬∞C"

        shading_weather_conditions:
          name: "üå¶Ô∏è Sun Shading - Weather Conditions"
          description: >-
            Check the following weather conditions when activating the shading.
            Be cautious when making your selection, as weather forecasts may not always be accurate and could lead to incorrect shading decisions.
            And as mentioned above, weather conditions can only be checked if a weather entity has been configured under ‚ÄòForecast Weather Sensor‚Äô.
            <br /><br />
            **Only works with weather entity, not with temperature sensor.**
            <br />
            Be cautious: weather forecasts may not always be accurate.
          default: []
          selector:
            select:
              multiple: true
              options:
                - "clear-night"
                - "clear"
                - "cloudy"
                - "fog"
                - "hail"
                - "lightning"
                - "lightning-rainy"
                - "partlycloudy"
                - "pouring"
                - "rainy"
                - "snowy"
                - "snowy-rainy"
                - "sunny"
                - "windy"
                - "windy-variant"
                - "exceptional"

        shading_config:
          name: "ü•µ Sun Shading - Configuration"
          description: >-
            These options allow you to fine-tune how the system handles temperature-based shading.
            <p><em>Click on the titles to get further help.</em></p>
            <details>
            <summary><code><strong>Independent Shading via Temperature Comparison</strong></code></summary>

              Enables shading based solely on temperature ‚Äî <ins>independently of other conditions</ins> like brightness, sun position, or time.
              - By default, only the external <em>forecasted temperature</em> is compared with the configured threshold in <em>"Forecast Temperature Value"</em>.
              - You can also enable another comparison by selecting the other checkbox.

              If any value exceeds the threshold, shading will be activated ‚Äî even if all other shading conditions are false.

              This is especially useful in the early morning: the system can already determine whether shading will be needed later in the day. Instead of fully opening the blinds, it can move them directly into the shading position.

              Additionally, one hour before the earliest possible opening time, the system retrieves the latest weather forecast.

              This allows it to compare the updated forecasted temperature with the configured threshold and make an early shading decision based on the most current data.

            </details>
            <br />
            <details>
            <summary><code><strong>Additionally compare forecast temperature with Sensor 2</strong></code></summary>

              This activates an extended comparison, checking not only whether the external forecasted temperature is above the threshold configured in <em>"Forecast Temperature Value"</em>, but also whether the current reading from <em>"Temperature Sensor 2"</em> (e.g. outdoor) is above the threshold configured for it. The shading condition will be true if <em>one</em> of the following conditions is met:
              - The external forecasted temperature exceeds the configured threshold in <em>"Forecast Temperature Value"</em>, or<br />
              - the <em>"Temperature Sensor 2"</em> reports a higher temperature than in <em>"Forecast Temperature Value"</em>.

              This mechanism improves the responsiveness and reliability of the shading system by using real-time sensor input as an optional condition, especially when forecast data is uncertain.
              Note: This function has nothing to do with normal temperature comparison, but is used exclusively in the context of the forecast function.
            </details>
          default: []
          selector:
            select:
              options:
                - label: "Independent Shading via Temperature Comparison"
                  value: "shading_temp_comparison_independent"
                - label: "Additionally compare 'Forecast Temperature Value' with 'Temperature Sensor 2'"
                  value: "shading_compare_forecast_with_sensor2"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        shading_waitingtime_start:
          name: "ü•µ Sun Shading - Start Waiting Time"
          description: >-
            To avoid overloading the motor, a waiting time can be defined here for the start of shading.
            The shade will only start if <ins>all</ins> mandatory conditions are fulfilled for the entire waiting time.
            This waiting time is also used for the periodic condition checks within the retry loop.
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

        shading_start_max_duration:
          name: "ü•µ Sun Shading - Maximum duration for shading start retry loop"
          description: |
            Maximum time to keep retrying shading start conditions after initial trigger.
            The Start Waiting Time is used for the periodic condition checks during this retry loop.
            If conditions remain unstable for longer than this timeout, the retry loop is stopped.
            Shading will not start and waits for a new shading start trigger.

            **Use case:** Prevents automation from being stuck in "waiting for stable conditions"
            when weather is highly unstable (rapidly changing clouds).

            **0 = disabled** (no periodic retry, stops immediately - old "trigger_reset" behavior)
            **Recommended: 3600-7200 seconds (1-2 hours)**
          default: 7200
          selector:
            number:
              min: 0
              max: 14400
              step: 300
              unit_of_measurement: "seconds"

        shading_waitingtime_end:
          name: "ü•µ Sun Shading - End Waiting Time"
          description: >-
            To avoid excessive load on the motor, a waiting time can be defined here before the shading is ended.
            Shading ends if one of the conditions is not fulfilled for the entire waiting time.
            This waiting time is also used for the periodic condition checks within the retry loop.
          default: 300
          selector:
            number:
              min: 0
              max: 3600
              unit_of_measurement: seconds

        shading_end_max_duration:
          name: "ü•µ Sun Shading - Maximum duration for shading end retry loop"
          description: |
            Maximum time to keep retrying shading end conditions after initial trigger.
            The End Waiting Time is used for the periodic condition checks during this retry loop.
            If conditions remain unstable for longer than this timeout, the retry loop is stopped.
            Shading remains active and waits for a new shading end trigger.

            **Use case:** Prevents automation from being stuck in "waiting for stable conditions"
            when weather is highly unstable (rapidly changing clouds).

            **0 = disabled** (no periodic retry, behaves like old version)
            **Recommended: 3600-7200 seconds (1-2 hours)**
          default: 7200
          selector:
            number:
              min: 0
              max: 14400
              step: 300
              unit_of_measurement: "seconds"

        shading_end_immediate_by_sun_position:
          name: "ü•µ End Sun Shading - Immediately When Out Of Range"
          description: >-
            If enabled, shading will end immediately (only a few seconds later) when sun position moves outside the defined azimuth or elevation range.
            If disabled, the configured waiting time will be used before ending the shading.
          default: false
          selector:
            boolean: {}

    resident_section:
      name: "Resident Settings"
      description: >-
        <center>
        <br />
        (1) The purpose of resident mode is to the close the cover (without checking the defined times) when the resident sensor switches to ‚Äòon/true‚Äô. For example, when a resident goes to sleep.
        <br />
        (2) The cover will stay closed as long as the sensor remains in this state.
        <br />
        (3) When the resident sensor switches to ‚Äòoff/false‚Äô, the cover is automatically opened in the morning.
        <br />
        (4) In addition, the usual automatic opening of the cover is prevented as long as the sensor is set to ‚Äòon/true‚Äô or the resident.
        <br /><br />
        All these settings are optional.
        <br /><br />
        </center>
      icon: mdi:human-male-female
      collapsed: true
      input:
        resident_sensor:
          name: "üõå Resident Sensor"
          description: "You can use this to define a resident (input_boolean or binary_sensor) for the room"
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        resident_config:
          name: "üõå Resident Configuration"
          description: |
            Configure how the automation responds to resident sensor changes.

            - **Opening enabled**: Cover opens when resident wakes up, but only if time, brightness, and sun elevation conditions are met
            - **Closing enabled**: Cover closes when resident goes to sleep (immediate, ignores other conditions)
          default: []
          selector:
            select:
              options:
                - label: "üîº Enable automatic opening when resident wakes up (respects all opening conditions)"
                  value: "resident_opening_enabled"
                - label: "üîª Enable automatic closing when resident goes to sleep (immediate)"
                  value: "resident_closing_enabled"
                - label: "ü•µ Allow sun protection when resident is still present"
                  value: "resident_allow_shading"
                - label: "üîº Allow opening the cover when resident is still present"
                  value: "resident_allow_opening"
                - label: "üí® Allow ventilation when resident is still present"
                  value: "resident_allow_ventilation"
              multiple: true
              sort: false
              custom_value: false
              mode: list

    override_section:
      name: "Manual Override"
      description: >-
        <br />
        <center><code>A Cover Status Helper is required!</code></center><br />
      icon: mdi:debug-step-over
      collapsed: true
      input:
        ignore_after_manual_config:
          name: "üñêÔ∏è Ignoring/override after manual position changes"
          description: >-
            Ignore or override the following actions after manual position changes.

            <details>
            <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            Ultimately, this means that the cover will not be opened, closed, etc.
            if a manual interaction has previously been made, e.g. using a wall switch.


            The reason behind this is that the human being wins with his decision and his
            conscious decision is weighted higher than the upcoming action of the automation.


            As soon as a cover has been moved manually, the status is recorded in the Cover Status Helper.
            This usually means that a person has deliberately decided against a status.

              - If option is not activated: The covers are moved even if a manual correction has been made.
              - If option is activated: The action to open, close, etc. is not performed because a conscious decision was made to do otherwise due to a manual intervention.


            A Cover Status Helper is required!

            </details>

          default: []
          selector:
            select:
              options:
                - label: "üîº Ignore/override next automatic opening after manual position changes"
                  value: "ignore_opening_after_manual"
                - label: "üîª Ignore/override next automatic closing after manual position changes"
                  value: "ignore_closing_after_manual"
                - label: "üí® Ignore/override next automatic ventilation after manual position changes"
                  value: "ignore_ventilation_after_manual"
                - label: "ü•µ Ignore/override next automatic sun shading after manual position changes"
                  value: "ignore_shading_after_manual"
              multiple: true
              sort: false
              custom_value: false
              mode: list

        reset_override_config:
          name: "üóëÔ∏è Reset manual override"
          description: >-
            If the detection of the manual position change was activated above, you may need a way to reset this status.
            Otherwise, the next cover movements will be permanently ignored or overridden.
            Or you have not activated an individual action, e.g. when closing the covers, which resets the status.
          default: reset_disabled
          selector:
            select:
              options:
                - label: "No timed reset for manual override"
                  value: "reset_disabled"
                - label: "Reset at a specified time (see below)"
                  value: "reset_fixed_time"
                - label: "Reset after a timeout in minutes (see below)"
                  value: "reset_timeout"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        reset_override_time:
          name: "üóëÔ∏è Time to reset manual override"
          description: "At what time do you want the manual detection to be reset?"
          default: "00:01:00"
          selector:
            time: {}

        reset_override_timeout:
          name: "üóëÔ∏è Number of minutes until reset manual override"
          description: "After how many minutes should it be reset?"
          default: 5
          selector:
            number:
              min: 0
              max: 1440
              unit_of_measurement: minutes

    delay_section:
      description: >-
        <center>
        <br />
        Take into account that, for example, waiting times are added when brightness changes or shading is started.
        It is therefore better to use smaller values here. It is only a matter of separating the different covers in terms of time.
        <br /><br />
        </center>
      name: "Delay Settings"
      icon: mdi:timer-outline
      collapsed: true
      input:
        drive_delay_fix:
          name: "üïõ Fixed Drive Delay"
          description: >-
            Fixed drive delay to avoid radio interferences.
            <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

        drive_delay_random:
          name: "üïõ Random Drive Delay"
          description: >-
            Additional random delay.
            <br /><br />`Optional`
          default: 5
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider

    condition_section:
      name: "Additional Conditions"
      description: >-
        <br />
        <center><code>All these settings are optional</code></center><br />
      icon: mdi:help-rhombus-outline
      collapsed: true
      input:
        auto_global_condition:
          name: "‚ùì Additional Condition for the entire automation"
          description: >-
            This condition allows you to control the execution of the <ins>entire</ins> automation dynamically and outside of the blueprint configuration.
            With this option you could enable a party mode.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
            <br /><br />
            Forcing Open/Close/Shading/Ventilation is therefore only possible if this condition remains empty or becomes valid.
          default: []
          selector:
            condition: {}

        auto_up_condition:
          name: "üîº Additional Condition For Opening The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>opening</ins> of the cover.
            You can use this, for example, if the covers normally don't open, but you really want to do it on vacation.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_down_condition:
          name: "üîª Additional Condition For Closing The Cover"
          description: >-
            This condition can be used to dynamically control the <ins>closing</ins> of the cover.
            You can use this, for example, at Christmas time or if you want the covers to behave differently while on vacation.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_ventilate_condition:
          name: "üí® Additional Condition For Activating Ventilation"
          description: >-
            This condition can be used to dynamically control the <ins>start of the ventilation</ins> of the cover.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_ventilate_end_condition:
          name: "üí® Additional Condition For Disabling Ventilation"
          description: >-
            This condition can be used to dynamically control the <ins>end of the ventilation</ins> of the cover.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_shading_start_condition:
          name: "ü•µ Additional Condition When Activating Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-IN-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
            <br />
            Another example: Here you could also set that the shading is only triggered in the summer season.
          default: []
          selector:
            condition: {}

        auto_shading_tilt_condition:
          name: "ü•µ Additional Condition For Sun Shading Tilt"
          description: >-
            This condition can be used to dynamically control the <ins>shading_tilt-IN-automation</ins>
            of the cover. This can be useful if you want to temporarily disable automation
            (e.g. because of control by other automations). <br /> Another example:
            Here you could also set that the tilting is only triggered in the summer season.
            <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

        auto_shading_end_condition:
          name: "ü•µ Additional Condition When Deactivating  Sun Shading"
          description: >-
            This condition can be used to dynamically control the <ins>shading-OUT-automation</ins> of the cover.
            This can be useful if you want to temporarily disable automation (e.g. because of control by other automations).
            <br />
            If the result of this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}

    force_section:
      name: "Force Features"
      description: >-
        <center>
        <br />
        Emergency override controls for weather protection and special scenarios<br />

        Force functions allow you to immediately move covers to specific positions, overriding all other automation logic.
        Use cases include: rain protection, wind protection, frost prevention, or temporary manual control.
        </center>

        <details>
        <summary><code><strong>IMPORTANT: How Force Works</strong></code></summary>

          **Basic Behavior (Without Background State Tracking):**
          - When a force is activated, the cover moves immediately to the target position
          - All other automation logic is disabled while force is active
          - When the force is deactivated, CCA remains idle until the next trigger
          - You must manually reset the cover to the desired position or rely on other automations

          **Advanced: Automatic Return to Target (With Background State Tracking)**
          - Enable "Return to Target State After Force Disable" to automatically restore the cover
          - While a force is active, CCA continues tracking what position the cover *should* be in
          - When you deactivate the force, the cover automatically returns to that target position
          - Example: Force-close for rain protection ‚Üí Rain stops ‚Üí Cover automatically returns to open or shading position

          **Important Constraints:**
          - Only ONE force function can be active at a time
          - Force functions have the highest priority - no other automation can override them
          - To stop forcing, manually deactivate the force entity
          - Multiple simultaneous force activations will trigger a configuration warning

        </details>

        <center>
        <br /><code>All settings in this section are optional</code><br /><br />
        </center>
      icon: mdi:arm-flex
      collapsed: true
      input:
        auto_recover_after_force:
          name: "üîô Return to Target State After Force Disable"
          description: >-
            **üöÄ Seamless control with automatic recovery!**

            When enabled, the cover automatically returns to its intended position when a force function is disabled.

            <details>
            <summary><code><strong>HOW IT WORKS:</strong> Smart Background Tracking</code></summary>


            **Continuous Status Tracking:**

            - The helper constantly monitors what the cover *should* be doing (open, close, shading, ventilate)

            - Even when a force function is active, the background state is always up-to-date

            - When the force function is disabled, the cover knows exactly where to return


            **Perfect for:**

            - üåßÔ∏è Rain Protection (force-close, auto-recover to shading)

            - üí® Wind Protection (force-open, auto-recover to normal state)

            - ‚ùÑÔ∏è Frost Protection (force-open, auto-resume after sunrise)

            - üî• Emergency Scenarios (temporary manual control, then auto-recovery)

            - üè† Cleaning/Maintenance (force-open, then auto-return when done)


            </details>
          default: auto_recover_disabled
          selector:
            select:
              options:
                - label: "‚úÖ Enable Automatic Return to Target State"
                  value: "auto_recover_enabled"
                - label: "‚ùå Disable Automatic Return to Target State"
                  value: "auto_recover_disabled"
              multiple: false
              sort: false
              custom_value: false
              mode: list

        auto_up_force:
          name: "üîº Force Immediate Opening via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is opened immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_down_force:
          name: "üîª Force Immediate Closing via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is closed immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_ventilate_force:
          name: "üí® Force Immediate Ventilation via Entity"
          description: >-
            If the status of this entity changes to on or true, the cover is immediately set to ventilation mode and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

        auto_shading_start_force:
          name: "ü•µ Force Activation Sun Shading via Entity"
          description: >-
            If the status of this entity changes to on or true, the shading is immediately activated and without further checking.
          default: []
          selector:
            entity:
              domain:
                - input_boolean
                - binary_sensor
                - switch

    actions_section:
      name: "Additional Actions"
      description: >-
        <br />
        <center><code>All these settings are optional</code></center><br />
      icon: mdi:run
      collapsed: true
      input:
        auto_up_action_before:
          name: "üîº Additional Actions Before Opening The Cover"
          description: "Additional actions to run <ins>before</ins> opening the cover"
          default: []
          selector:
            action: {}

        auto_up_action:
          name: "üîº Additional Actions After Opening The Cover"
          description: "Additional actions to run <ins>after</ins> opening the cover"
          default: []
          selector:
            action: {}

        auto_down_action_before:
          name: "üîª Additional Actions Before Closing The Cover"
          description: "Additional actions to run <ins>before</ins> closing the cover"
          default: []
          selector:
            action: {}

        auto_down_action:
          name: "üîª Additional Actions After Closing The Cover"
          description: "Additional actions to run <ins>after</ins> closing the cover"
          default: []
          selector:
            action: {}

        auto_ventilate_action_before:
          name: "üí® Additional Actions Before Ventilating The Cover"
          description: "Additional actions to run <ins>before</ins> ventilating the cover"
          default: []
          selector:
            action: {}

        auto_ventilate_action:
          name: "üí® Additional Actions After Ventilating The Cover"
          description: "Additional actions to run <ins>after</ins> ventilating the cover"
          default: []
          selector:
            action: {}

        auto_shading_start_action_before:
          name: "ü•µ Additional Actions Before Activating Sun Shading"
          description: "Additional actions to run <ins>before</ins> activating sun shading"
          default: []
          selector:
            action: {}

        auto_shading_start_action:
          name: "ü•µ Additional Actions After Activating Sun Shading"
          description: "Additional actions to run <ins>after</ins> activating sun shading"
          default: []
          selector:
            action: {}

        auto_shading_end_action_before:
          name: "ü•µ Additional Actions Before Disabling Sun Shading"
          description: "Additional actions to run <ins>before</ins> disabling sun shading"
          default: []
          selector:
            action: {}

        auto_shading_end_action:
          name: "ü•µ Additional Actions After Disabling Sun Shading"
          description: "Additional actions to run <ins>after</ins> disabling sun shading"
          default: []
          selector:
            action: {}

        auto_manual_action:
          name: "üñêÔ∏è Additional Actions After Manual Change"
          description: "Additional actions after a manual change to the covers"
          default: []
          selector:
            action: {}

        auto_override_reset_action:
          name: "üóëÔ∏è Additional Actions After Override Reset"
          description: "Additional actions to be taken after resetting the manual override"
          default: []
          selector:
            action: {}

    configcheck_section:
      name: "Configuration Check"
      description: >-
        <br />
        <center>
        <strong>üîó Use the <a href="https://hvorragend.github.io/ha-blueprints/validator/" target="_blank">Online Configuration Validator</a></strong>
        <br />
        Validate your YAML configuration for errors, typos, and deprecated parameters before deploying.
        <br />
        ‚úÖ Instant feedback ‚Ä¢ üîç Typo detection ‚Ä¢ ‚ö†Ô∏è Migration guidance ‚Ä¢ üîí Privacy-friendly (client-side)
        <br /><br />
        </center>
      icon: mdi:invoice-text-check-outline
      collapsed: true
      input:
        check_config:
          name: "‚úîÔ∏è Check Configuration"
          description: >-
            With this boolean, you can enable or disable the basic plausibility check for the configuration.
            The check only takes place if the automation is executed manually.
            <br /><br />
            Use the <a href="https://hvorragend.github.io/ha-blueprints/validator/" target="_blank">online validator</a> for another validation.
          default: false
          selector:
            boolean: {}

        check_config_debuglevel:
          name: "‚úîÔ∏è Check Configuration - Debug level"
          description: >-
            Choose the debug level for Syslog messages in case of configuration issues
            <br />
            Please make sure that it suits your Home Assistant logger default level.
          default: "info"
          selector:
            select:
              multiple: false
              mode: dropdown
              options:
                - "critical"
                - "debug"
                - "error"
                - "info"
                - "warning"

################################################################################
# TRIGGER VARIABLES
################################################################################

trigger_variables:
  blind: !input blind
  cover_type: !input cover_type
  is_awning: "{{ cover_type == 'awning' }}"
  resident_sensor: !input resident_sensor

  # Position source configuration
  position_source: !input position_source
  custom_position_sensor: !input custom_position_sensor

  # Positions
  open_position: !input open_position
  close_position: !input close_position
  ventilate_position: !input ventilate_position
  shading_position: !input shading_position
  position_tolerance: !input position_tolerance

  # Tilt positions
  open_tilt_position: !input open_tilt_position
  close_tilt_position: !input close_tilt_position
  ventilate_tilt_position: !input ventilate_tilt_position
  shading_tilt_elevation_1: !input shading_tilt_elevation_1
  shading_tilt_elevation_2: !input shading_tilt_elevation_2
  shading_tilt_elevation_3: !input shading_tilt_elevation_3
  shading_tilt_position_0: !input shading_tilt_position_0
  shading_tilt_position_1: !input shading_tilt_position_1
  shading_tilt_position_2: !input shading_tilt_position_2
  shading_tilt_position_3: !input shading_tilt_position_3

  # Feature option selections
  auto_options: !input auto_options
  cover_tilt_config: !input cover_tilt_config
  cover_tilt_reposition_config: !input cover_tilt_reposition_config
  is_cover_tilt_enabled: "{{ not is_awning and 'cover_tilt_enabled' in cover_tilt_config }}"

  # Tilt wait mode configuration
  tilt_wait_mode: !input cover_tilt_wait_mode
  tilt_wait_timeout: !input cover_tilt_wait_timeout
  is_tilt_wait_idle_mode: "{{ tilt_wait_mode == 'wait_idle' }}"

  # Time configuration
  time_up_early: !input time_up_early
  time_up_early_non_workday: !input time_up_early_non_workday
  time_up_late: !input time_up_late
  time_up_late_non_workday: !input time_up_late_non_workday
  time_down_early: !input time_down_early
  time_down_early_non_workday: !input time_down_early_non_workday
  time_down_late: !input time_down_late
  time_down_late_non_workday: !input time_down_late_non_workday
  workday_sensor_today: !input workday_sensor
  workday_sensor_tomorrow: !input workday_sensor_tomorrow
  time_control: !input time_control

  # Calendar configuration
  calendar_entity: !input calendar_entity
  calendar_open_title: !input calendar_open_title
  calendar_close_title: !input calendar_close_title
  calendar_open_title_lc: "{{ (calendar_open_title | default('')) | lower | trim }}"
  calendar_close_title_lc: "{{ (calendar_close_title | default('')) | lower | trim }}"
  is_calendar_enabled: "{{ 'time_control_calendar' in time_control and calendar_entity != [] }}"

  # Brightness configuration
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down
  brightness_hysteresis: !input brightness_hysteresis

  # Sun configuration
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_mode: !input sun_elevation_mode
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down

  # Dynamic sun elevation sensors
  sun_elevation_up_sensor: !input sun_elevation_up_sensor
  sun_elevation_down_sensor: !input sun_elevation_down_sensor

  # Ventilation/Contact sensors
  contact_window_opened: !input contact_window_opened
  contact_window_tilted: !input contact_window_tilted
  lockout_tilted_options: !input lockout_tilted_options

  # Shading configuration
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_sun_brightness_hysteresis: !input shading_sun_brightness_hysteresis

  # Shading sensors
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_temperature_hysteresis1: !input shading_temperature_hysteresis1
  shading_temperature_hysteresis2: !input shading_temperature_hysteresis2

  # Shading forecast configuration
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_forecast_temp_sensor: !input shading_forecast_temp_sensor
  shading_forecast_type: !input shading_forecast_type
  shading_forecast_temp: !input shading_forecast_temp
  shading_forecast_temp_hysteresis: !input shading_forecast_temp_hysteresis
  shading_weather_conditions: !input shading_weather_conditions

  # Shading condition selections
  shading_conditions_start_and: !input shading_conditions_start_and
  shading_conditions_start_or: !input shading_conditions_start_or
  shading_conditions_end_and: !input shading_conditions_end_and
  shading_conditions_end_or: !input shading_conditions_end_or

  # Lockout protection flag computation
  lockout_tilted_when_closing: "{{ 'lockout_tilted_closing' in lockout_tilted_options }}"
  lockout_tilted_when_shading_starts: "{{ 'lockout_tilted_shading_start' in lockout_tilted_options }}"
  lockout_tilted_when_shading_ends: "{{ 'lockout_tilted_shading_end' in lockout_tilted_options }}"

  # Feature enable flag computation
  is_shading_enabled: "{{ 'auto_shading_enabled' in auto_options }}"
  is_up_enabled: "{{ 'auto_up_enabled' in auto_options }}"
  is_down_enabled: "{{ 'auto_down_enabled' in auto_options }}"
  is_brightness_enabled: "{{ 'auto_brightness_enabled' in auto_options }}"
  is_sun_elevation_enabled: "{{ 'auto_sun_enabled' in auto_options }}"
  is_time_field_enabled: "{{ 'time_control_input' in time_control }}"
  is_time_control_disabled: "{{ 'time_control_disabled' in time_control }}"

  # Ventilation and tilt are only available for blinds, not awnings
  is_ventilation_enabled: "{{ not is_awning and 'auto_ventilate_enabled' in auto_options }}"

  # Reset override flag computation
  reset_override_config: !input reset_override_config
  reset_override_time: !input reset_override_time
  reset_override_timeout: !input reset_override_timeout
  is_reset_disabled: "{{ 'reset_disabled' in reset_override_config }}"
  is_reset_fixed_time: "{{ 'reset_fixed_time' in reset_override_config }}"
  is_reset_timeout: "{{ 'reset_timeout' in reset_override_config }}"

  # Force entities
  auto_up_force: !input auto_up_force
  auto_down_force: !input auto_down_force
  auto_ventilate_force: !input auto_ventilate_force
  auto_shading_start_force: !input auto_shading_start_force

  # Cover status helper configuration
  cover_status_helper: !input cover_status_helper

  # Invalid states list - Shared constant
  invalid_states:
    - ''                    # Empty string
    - 'unavailable'         # Entity unavailable
    - 'unknown'             # State unknown
    - 'none'                # Python none (lowercase)
    - 'None'                # Python None (capitalized)
    - 'null'                # JSON null
    - 'query failed'        # Failed sensor queries
    - []                    # Empty list

################################################################################
# VARIABLES
################################################################################

variables:
  version: "2026.01.alpha"

  # Blind
  blind_entities: "{{ expand(blind) | map(attribute='entity_id') | list }}"

  # Get current position based on configuration
  current_position: >-
    {% set source = position_source %}
    {% if source == 'current_position_attr' %}
      {{ state_attr(blind, 'current_position') | int(default=101) }}
    {% elif source == 'position_attr' %}
      {{ state_attr(blind, 'position') | int(default=101) }}
    {% elif source == 'custom_sensor' and custom_position_sensor != [] %}
      {{ states(custom_position_sensor) | int(default=101) }}
    {% else %}
      {{ 101 }}
    {% endif %}

  # Same for tilt if enabled
  current_tilt_position: "{{ state_attr(blind, 'current_tilt_position') | int(default=101) }}"

  # COVER TYPE & POSITION COMPARISON LOGIC
  # Position comparison results
  # Handles both blind (0%=closed) and awning (0%=retracted) logic automatically
  position_comparisons:
    # Current position vs targets (considers awning inversion)
    current_above_open: "{{ current_position < open_position if is_awning else current_position > open_position }}"
    current_above_close: "{{ current_position < close_position if is_awning else current_position > close_position }}"
    current_above_shading: "{{ current_position < shading_position if is_awning else current_position > shading_position }}"
    current_above_ventilate: "{{ current_position < ventilate_position if is_awning else current_position > ventilate_position }}"

    current_below_open: "{{ current_position > open_position if is_awning else current_position < open_position }}"
    current_below_close: "{{ current_position > close_position if is_awning else current_position < close_position }}"
    current_below_shading: "{{ current_position > shading_position if is_awning else current_position < shading_position }}"
    current_below_ventilate: "{{ current_position > ventilate_position if is_awning else current_position < ventilate_position }}"

    # Position ordering (for config validation)
    open_above_close: "{{ open_position < close_position if is_awning else open_position > close_position }}"
    open_above_ventilate: "{{ open_position < ventilate_position if is_awning else open_position > ventilate_position }}"
    shading_above_close: "{{ shading_position < close_position if is_awning else shading_position > close_position }}"
    shading_below_open: "{{ shading_position > open_position if is_awning else shading_position < open_position }}"
    ventilate_above_close: "{{ ventilate_position < close_position if is_awning else ventilate_position > close_position }}"

  current_sun_azimuth: "{{ state_attr(default_sun_sensor, 'azimuth') }}"
  current_sun_elevation: "{{ state_attr(default_sun_sensor, 'elevation') }}"

  # Current sun elevation thresholds (supports fixed, dynamic, and hybrid modes)
  sun_elevation_up_current: >-
    {% set mode = sun_elevation_mode %}
    {% set sensor = sun_elevation_up_sensor %}
    {% set fixed_value = sun_elevation_up | float %}
    {% set sensor_valid = sensor != [] and states(sensor) not in invalid_states and is_number(states(sensor)) %}
    {% if mode == 'dynamic' %}
      {% if sensor_valid %}
        {{ states(sensor) | float }}
      {% else %}
        {{ fixed_value }}
      {% endif %}
    {% elif mode == 'hybrid' %}
      {% if sensor_valid %}
        {{ (states(sensor) | float) + fixed_value }}
      {% else %}
        {{ fixed_value }}
      {% endif %}
    {% else %}
      {{ fixed_value }}
    {% endif %}

  sun_elevation_down_current: >-
    {% set mode = sun_elevation_mode %}
    {% set sensor = sun_elevation_down_sensor %}
    {% set fixed_value = sun_elevation_down | float %}
    {% set sensor_valid = sensor != [] and states(sensor) not in invalid_states and is_number(states(sensor)) %}
    {% if mode == 'dynamic' %}
      {% if sensor_valid %}
        {{ states(sensor) | float }}
      {% else %}
        {{ fixed_value }}
      {% endif %}
    {% elif mode == 'hybrid' %}
      {% if sensor_valid %}
        {{ (states(sensor) | float) + fixed_value }}
      {% else %}
        {{ fixed_value }}
      {% endif %}
    {% else %}
      {{ fixed_value }}
    {% endif %}

  is_today_off: "{{ workday_sensor_today != [] and is_state(workday_sensor_today, 'off') }}"
  is_tomorrow_off: "{{ workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'off') }}"
  is_tomorrow_on: "{{ workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on') }}"

  is_cover_tilt_enabled_and_possible: "{{ is_cover_tilt_enabled and state_attr(blind, 'current_tilt_position') != none }}"
  is_cover_tilt_reposition_enabled: "{{ 'cover_tilt_reposition_enabled' in cover_tilt_reposition_config }}"

  # Delays and Timing
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time
  time_up_early_today: "{{ time_up_early_non_workday if is_today_off else time_up_early }}"
  time_up_late_today: "{{ time_up_late_non_workday if is_today_off else time_up_late }}"
  time_down_early_today: >-
    {{
      time_down_early_non_workday if is_tomorrow_off else
      time_down_early if is_tomorrow_on else
      time_down_early_non_workday if is_today_off else
      time_down_early
    }}
  time_down_late_today: >-
    {{
      time_down_late_non_workday if is_tomorrow_off else
      time_down_late if is_tomorrow_on else
      time_down_late_non_workday if is_today_off else
      time_down_late
    }}

  # SHADING TILT POSITION - Elevation-based selection
  # Determine tilt angle based on current sun elevation (multi-stage)
  shading_tilt_position: >-
    {% set elevation = current_sun_elevation | int(default=0) %}
    {% if elevation >= shading_tilt_elevation_3 | int %}
      {{ shading_tilt_position_3 | int }}
    {% elif elevation >= shading_tilt_elevation_2 | int %}
      {{ shading_tilt_position_2 | int }}
    {% elif elevation >= shading_tilt_elevation_1 | int %}
      {{ shading_tilt_position_1 | int }}
    {% else %}
      {{ shading_tilt_position_0 | int }}
    {% endif %}

  # POSITION CHECKERS - Single source of truth
  # Check if current position matches target (with tolerance and tilt validation)
  in_open_position: >-
    {% set min = open_position - position_tolerance %}
    {% set max = open_position + position_tolerance %}
    {{
      (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible) or
        (is_cover_tilt_enabled_and_possible and current_tilt_position == open_tilt_position | int)
      )
    }}

  in_close_position: >-
    {% set min = close_position - position_tolerance %}
    {% set max = close_position + position_tolerance %}
    {{
      (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible) or
        (is_cover_tilt_enabled_and_possible and current_tilt_position == close_tilt_position | int)
      )
    }}

  in_shading_position: >-
    {% set min = shading_position - position_tolerance %}
    {% set max = shading_position + position_tolerance %}
    {{
      is_shading_enabled
      and (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible) or
        (current_tilt_position == shading_tilt_position | int)
      )
    }}

  in_ventilate_position: >-
    {% set min = ventilate_position - position_tolerance %}
    {% set max = ventilate_position + position_tolerance %}
    {{
      is_ventilation_enabled
      and (current_position >= min and current_position <= max)
      and (
        (not is_cover_tilt_enabled_and_possible) or
        (current_tilt_position == ventilate_tilt_position | int)
      )
    }}

  # Brightness and sun configuration
  brightness_time_duration: !input brightness_time_duration
  sun_time_duration: !input sun_time_duration

  # SHADING - Additional Configuration Flags
  # Shading timing and retry
  shading_waitingtime_start: !input shading_waitingtime_start
  shading_waitingtime_end: !input shading_waitingtime_end
  shading_start_max_duration: !input shading_start_max_duration
  shading_end_max_duration: !input shading_end_max_duration
  # shading_end_behavior: !input shading_end_behavior
  shading_config: !input shading_config

  # Additional shading configuration passthrough
  shading_end_immediate_by_sun_position: !input shading_end_immediate_by_sun_position
  is_shading_end_immediate_by_sun_position: "{{ shading_end_immediate_by_sun_position }}"

  # Forecast source determination
  # Priority: sensor > weather entity > attributes
  forecast_source:
    use_sensor: "{{ shading_forecast_temp_sensor != [] }}"
    use_weather: "{{ shading_forecast_sensor != [] and shading_forecast_temp_sensor == [] }}"
    prevent_service: "{{ 'weather_attributes' in shading_forecast_type }}"

  # Shading condition enablement
  # Which START conditions are enabled (combines AND + OR lists)
  shading_start_condition_enabled:
    azimuth: "{{ 'cond_azimuth' in shading_conditions_start_and or 'cond_azimuth' in shading_conditions_start_or }}"
    elevation: "{{ 'cond_elevation' in shading_conditions_start_and or 'cond_elevation' in shading_conditions_start_or }}"
    brightness: "{{ 'cond_brightness' in shading_conditions_start_and or 'cond_brightness' in shading_conditions_start_or }}"
    temp1: "{{ 'cond_temp1' in shading_conditions_start_and or 'cond_temp1' in shading_conditions_start_or }}"
    temp2: "{{ 'cond_temp2' in shading_conditions_start_and or 'cond_temp2' in shading_conditions_start_or }}"
    forecast_temp: "{{ 'cond_forecast_temp' in shading_conditions_start_and or 'cond_forecast_temp' in shading_conditions_start_or }}"
    forecast_weather: "{{ 'cond_forecast_weather' in shading_conditions_start_and or 'cond_forecast_weather' in shading_conditions_start_or }}"

  # Which END conditions are enabled (combines AND + OR lists)
  shading_end_condition_enabled:
    azimuth: "{{ 'cond_azimuth' in shading_conditions_end_and or 'cond_azimuth' in shading_conditions_end_or }}"
    elevation: "{{ 'cond_elevation' in shading_conditions_end_and or 'cond_elevation' in shading_conditions_end_or }}"
    brightness: "{{ 'cond_brightness' in shading_conditions_end_and or 'cond_brightness' in shading_conditions_end_or }}"
    temp1: "{{ 'cond_temp1' in shading_conditions_end_and or 'cond_temp1' in shading_conditions_end_or }}"
    temp2: "{{ 'cond_temp2' in shading_conditions_end_and or 'cond_temp2' in shading_conditions_end_or }}"
    forecast_temp: "{{ 'cond_forecast_temp' in shading_conditions_end_and or 'cond_forecast_temp' in shading_conditions_end_or }}"
    forecast_weather: "{{ 'cond_forecast_weather' in shading_conditions_end_and or 'cond_forecast_weather' in shading_conditions_end_or }}"

  # Cover Status Helper ‚Äì JSON parsing
  # Helper is mandatory and validated at action start
  helper_json: "{{ states(cover_status_helper) | from_json }}"

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # STATE MANAGER - Centralized State Access
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  # STATE CURRENT - What state is the cover in RIGHT NOW?
  # Maps from v6 state codes or v5 status flags to readable state
  state_current: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.current }}
    {% else %}
      {% if (helper_json | regex_search('manual')) and (helper_json.manual.a | default(0) | int == 1) %}manual
      {% elif (helper_json | regex_search('open')) and (helper_json.open.a | default(0) | int == 1) %}open
      {% elif (helper_json | regex_search('close')) and (helper_json.close.a | default(0) | int == 1) %}close
      {% elif (helper_json | regex_search('shading')) and (helper_json.shading.a | default(0) | int == 1) and not (helper_json.shading.p | default(0) | bool) %}shade
      {% elif (helper_json | regex_search('vpart')) and (helper_json.vpart.a | default(0) | int == 1) %}vpart
      {% elif (helper_json | regex_search('vfull')) and (helper_json.vfull.a | default(0) | int == 1) %}vfull
      {% else %}none{% endif %}
    {% endif %}

  # STATE TARGET - What state SHOULD the cover be in?
  # Represents the background automation intent (important for force recovery)
  state_target: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.target }}
    {% else %}
      {{ state_current }}
    {% endif %}

  # STATE FORCE - Which force function is currently active?
  # Centralized force status: none|open|close|shade|vpart|vfull
  state_force: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.force }}
    {% elif auto_up_force != [] and states(auto_up_force) in ['on', 'true'] %}
      open
    {% elif auto_down_force != [] and states(auto_down_force) in ['on', 'true'] %}
      close
    {% elif auto_shading_start_force != [] and states(auto_shading_start_force) in ['on', 'true'] %}
      shade
    {% elif auto_ventilate_force != [] and states(auto_ventilate_force) in ['on', 'true'] %}
      vpart
    {% else %}
      none
    {% endif %}

  # RESIDENT STATUS - Is someone present?
  state_resident: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.resident }}
    {% elif resident_sensor != [] %}
      {{ 1 if is_state(resident_sensor, 'on') else 0 }}
    {% else %}
      0
    {% endif %}

  # MANUAL FLAG - Is manual override active?
  state_manual: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.man }}
    {% else %}
      {{ 1 if state_current == 'manual' else 0 }}
    {% endif %}

  # SHADED STATUS - Is cover currently shaded (not pending)?
  # True when state is 'shade' AND no pending start time active
  state_is_shaded: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.state.current == 'shade' and not (helper_json.pending.start | default(0) | int > 0) }}
    {% else %}
      {{ (helper_json | regex_search('shading')) and (helper_json.shading.a | default(false) | bool) and not (helper_json.shading.p | default(false) | bool) }}
    {% endif %}

  # PENDING START - Is shading start pending?
  state_pending_start: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.pending.start | default(0) | int > 0 }}
    {% else %}
      {{ (helper_json | regex_search('shading')) and (helper_json.shading.p | default(false) | bool) }}
    {% endif %}

  # PENDING END - Is shading end pending?
  state_pending_end: >-
    {% if helper_json.v == 6 %}
      {{ helper_json.pending.end | default(0) | int > 0 }}
    {% else %}
      {{ (helper_json | regex_search('shading')) and (helper_json.shading.q | default(false) | bool) }}
    {% endif %}

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # COMPUTED FLAGS - Simplified Movement Permissions
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # These replace the complex is_cover_movement_blocked dictionary

  # Can the cover move in each direction?
  can_move_open: "{{ state_force in ['none', 'open'] }}"
  can_move_close: "{{ state_force in ['none', 'close'] }}"
  can_move_shade: "{{ state_force in ['none', 'shade'] }}"
  can_move_ventilate: "{{ state_force in ['none', 'vpart', 'vfull'] }}"

  # Is any force active?
  is_forced: "{{ state_force != 'none' }}"

  # Does the cover need to move to reach target?
  needs_movement: "{{ state_current != state_target and not is_forced }}"

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # RESIDENT PERMISSION FLAGS - Centralized Resident-based Access Control
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # These flags check resident status (from state_resident) once, avoiding
  # redundant sensor reads across multiple branches.

  # Can open with current resident status?
  # Logic: Allow if opening_enabled OR (allow_opening matches resident state)
  can_open_with_resident: >-
    {{ not resident_flags.opening_enabled or
       (not resident_flags.allow_opening and state_resident == 0) or
       (resident_flags.allow_opening and state_resident == 1) }}

  # Can close with current resident status?
  # Logic: Allow if closing_enabled OR resident present
  can_close_with_resident: >-
    {{ not resident_flags.closing_enabled or state_resident == 1 }}

  # Can shade with current resident status?
  # Logic: Allow if allow_shading disabled OR resident not present
  can_shade_with_resident: >-
    {{ not resident_flags.allow_shading or state_resident == 0 }}

  # Can ventilate with current resident status?
  # Logic: Allow if allow_ventilation disabled OR resident not present
  can_ventilate_with_resident: >-
    {{ not resident_flags.allow_ventilation or state_resident == 0 }}


  # Resident sensor configuration
  resident_config: !input resident_config
  resident_flags:
    opening_enabled: "{{ 'resident_opening_enabled' in resident_config }}"
    closing_enabled: "{{ 'resident_closing_enabled' in resident_config }}"
    allow_shading: "{{ 'resident_allow_shading' in resident_config }}"
    allow_opening: "{{ 'resident_allow_opening' in resident_config }}"
    allow_ventilation: "{{ 'resident_allow_ventilation' in resident_config }}"

  # Override flags
  ignore_after_manual_config: !input ignore_after_manual_config
  override_flags:
    opening: "{{ 'ignore_opening_after_manual' in ignore_after_manual_config }}"
    closing: "{{ 'ignore_closing_after_manual' in ignore_after_manual_config }}"
    ventilation: "{{ 'ignore_ventilation_after_manual' in ignore_after_manual_config }}"
    shading: "{{ 'ignore_shading_after_manual' in ignore_after_manual_config }}"

  # Ventilation configuration
  auto_ventilate_options: !input auto_ventilate_options
  contact_delay_trigger: !input contact_delay_trigger
  contact_delay_status: !input contact_delay_status
  ventilation_flags:
    delay_enabled: "{{ 'ventilation_delay_enabled' in auto_ventilate_options }}"
    if_lower_enabled: "{{ 'ventilation_if_lower_enabled' in auto_ventilate_options }}"
    after_shading_end: "{{ 'ventilation_after_shading_end' in auto_ventilate_options }}"

  # Individual configuration
  prevent_config: !input individual_config
  prevent_flags:
    higher_position_closing: "{{ 'prevent_higher_position_closing' in prevent_config }}"
    lowering_when_closing_if_shaded: "{{ 'prevent_lowering_when_closing_if_shaded' in prevent_config }}"
    shading_end_if_closed: "{{ 'prevent_shading_end_if_closed' in prevent_config }}"
    opening_after_shading_end: "{{ 'prevent_opening_after_shading_end' in prevent_config }}"
    opening_after_ventilation_end: "{{ 'prevent_opening_after_ventilation_end' in prevent_config }}"
    default_cover_actions: "{{ 'prevent_default_cover_actions' in prevent_config }}"
    shading_multiple_times: "{{ 'prevent_shading_multiple_times' in prevent_config }}"
    opening_multiple_times: "{{ 'prevent_opening_multiple_times' in prevent_config }}"
    closing_multiple_times: "{{ 'prevent_closing_multiple_times' in prevent_config }}"

  auto_recover_after_force: !input auto_recover_after_force
  is_auto_recover_enabled: "{{ 'auto_recover_enabled' in auto_recover_after_force }}"

  # Configuration check
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel
  check_status_helper_length: "{{ state_attr(cover_status_helper, 'max') if cover_status_helper != [] else None }}"

# CCA uses 'queued' mode to prevent race conditions when multiple sensors
# change state simultaneously (e.g., window sensor + lock sensor).
# - If automation is running, new triggers are queued (max 10)
# - Each trigger is processed in order with current sensor values
# - This ensures no trigger is lost due to timing issues
mode: queued
max: 10
max_exceeded: warning

################################################################################
# TRIGGERS
################################################################################

triggers:

  ########################################
  # Trigger for opening cover
  ########################################

  - trigger: template
    value_template: >-
      {% set is_today_off = workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}
      {% set time_compare = time_up_early_non_workday if is_today_off else time_up_early %}
      {{ now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_open_1"

  - trigger: template # comparing the times to avoid double triggering if early+late are identical
    value_template: >-
      {% set is_today_off = workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}
      {% set early = time_up_early_non_workday if is_today_off else time_up_early %}
      {% set late = time_up_late_non_workday if is_today_off else time_up_late %}
      {{ early != late and now() >= today_at(late) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_open_2"

  - trigger: template
    value_template: "{{ states(default_brightness_sensor) | float(default=brightness_up) > (brightness_up + brightness_hysteresis) }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_open_4"

  # Trigger on sun elevation threshold (supports fixed, dynamic, and hybrid modes)
  - trigger: template
    value_template: >-
      {% set mode = sun_elevation_mode %}
      {% set sensor = sun_elevation_up_sensor %}
      {% set fixed_value = sun_elevation_up | float %}
      {% set current_elevation = state_attr(default_sun_sensor, 'elevation') | float(0) %}
      {% set sensor_valid = sensor != [] and states(sensor) not in invalid_states and is_number(states(sensor)) %}
      {% if mode == 'dynamic' %}
        {% if sensor_valid %}
          {% set threshold = states(sensor) | float %}
        {% else %}
          {% set threshold = fixed_value %}
        {% endif %}
      {% elif mode == 'hybrid' %}
        {% if sensor_valid %}
          {% set threshold = (states(sensor) | float) + fixed_value %}
        {% else %}
          {% set threshold = fixed_value %}
        {% endif %}
      {% else %}
        {% set threshold = fixed_value %}
      {% endif %}
      {{ current_elevation > threshold }}
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_open_5"

  - trigger: state
    entity_id: !input resident_sensor
    from: "on"
    to: "off"
    enabled: "{{ resident_sensor != [] }}"
    id: "t_open_6"

  # Resident sensor state change (for updating state_resident in helper)
  - trigger: state
    entity_id: !input resident_sensor
    enabled: "{{ resident_sensor != [] }}"
    id: "t_resident_update"

  - trigger: state
    entity_id: !input auto_up_force
    from: "off"
    to: "on"
    enabled: "{{ auto_up_force != [] }}"
    id: "t_force_enabled_open"

  - trigger: state
    entity_id: !input auto_up_force
    from: "on"
    to: "off"
    enabled: "{{ auto_up_force != [] }}"
    id: "t_force_disabled_open"

  ########################################
  # Trigger for closing cover
  ########################################

  - trigger: template
    value_template: >-
      {% set is_tomorrow_off = workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'off') %}
      {% set is_tomorrow_on = workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on') %}
      {% set is_today_off = workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}
      {% set time_compare =
        time_down_early_non_workday if is_tomorrow_off else
        time_down_early if is_tomorrow_on else
        time_down_early_non_workday if is_today_off else
        time_down_early %}
      {{ now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_close_1"

  - trigger: template # Avoid double triggering with 'early != late' if early and late times are identical
    value_template: >-
      {% set is_tomorrow_off = workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'off') %}
      {% set is_tomorrow_on = workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow, 'on') %}
      {% set is_today_off = workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}
      {% set time_compare =
        time_down_late_non_workday if is_tomorrow_off else
        time_down_late if is_tomorrow_on else
        time_down_late_non_workday if is_today_off else
        time_down_late %}
      {{ (time_down_early_non_workday != time_compare and time_down_early != time_compare) and now() >= today_at(time_compare) }}
    enabled: "{{ is_time_field_enabled }}"
    id: "t_close_2"

  - trigger: template
    value_template: "{{ states(default_brightness_sensor) | float(default=brightness_down) < (brightness_down - brightness_hysteresis) }}"
    for:
      seconds: !input brightness_time_duration
    enabled: "{{ is_brightness_enabled and default_brightness_sensor != [] }}"
    id: "t_close_4"

  - trigger: template
    value_template: >-
      {% set mode = sun_elevation_mode %}
      {% set sensor = sun_elevation_down_sensor %}
      {% set fixed_value = sun_elevation_down | float %}
      {% set current_elevation = state_attr(default_sun_sensor, 'elevation') | float(0) %}
      {% set sensor_valid = sensor != [] and states(sensor) not in invalid_states and is_number(states(sensor)) %}
      {% if mode == 'dynamic' %}
        {% if sensor_valid %}
          {% set threshold = states(sensor) | float %}
        {% else %}
          {% set threshold = fixed_value %}
        {% endif %}
      {% elif mode == 'hybrid' %}
        {% if sensor_valid %}
          {% set threshold = (states(sensor) | float) + fixed_value %}
        {% else %}
          {% set threshold = fixed_value %}
        {% endif %}
      {% else %}
        {% set threshold = fixed_value %}
      {% endif %}
      {{ current_elevation < threshold }}
    for:
      seconds: !input sun_time_duration
    enabled: "{{ is_sun_elevation_enabled and default_sun_sensor != [] }}"
    id: "t_close_5"

  - trigger: state
    entity_id: !input resident_sensor
    from: "off"
    to: "on"
    enabled: "{{ resident_sensor != [] }}"
    id: "t_close_6"

  - trigger: state
    entity_id: !input auto_down_force
    from: "off"
    to: "on"
    enabled: "{{ auto_down_force != [] }}"
    id: "t_force_enabled_close"

  - trigger: state
    entity_id: !input auto_down_force
    from: "on"
    to: "off"
    enabled: "{{ auto_down_force != [] }}"
    id: "t_force_disabled_close"

  ########################################
  # Calendar-based triggers
  ########################################

# Calendar event starts (state becomes "on")
  - trigger: state
    entity_id: !input calendar_entity
    to: "on"
    enabled: "{{ is_calendar_enabled }}"
    id: "t_calendar_event_start"

  # Calendar event ends (state becomes "off")
  - trigger: state
    entity_id: !input calendar_entity
    to: "off"
    enabled: "{{ is_calendar_enabled }}"
    id: "t_calendar_event_end"

  #################################################
  # Trigger for ventilation - COMBINED
  # Single trigger per sensor to prevent race conditions
  #################################################

  - trigger: state
    entity_id: !input contact_window_tilted
    enabled: "{{ is_ventilation_enabled and contact_window_tilted != [] }}"
    id: "t_contact_tilted_changed"
    for:
      seconds: !input contact_delay_trigger

  - trigger: state
    entity_id: !input contact_window_opened
    enabled: "{{ is_ventilation_enabled and contact_window_opened != [] }}"
    id: "t_contact_opened_changed"
    for:
      seconds: !input contact_delay_trigger

  - trigger: state
    entity_id: !input auto_ventilate_force
    from: "off"
    to: "on"
    enabled: "{{ auto_ventilate_force != [] }}"
    id: "t_force_enabled_ventilate"

  - trigger: state
    entity_id: !input auto_ventilate_force
    from: "on"
    to: "off"
    enabled: "{{ auto_ventilate_force != [] }}"
    id: "t_force_disabled_ventilate"

  ########################################
  # Triggers for shading start
  ########################################
  - trigger: template
    value_template: >-
      {{
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start) > shading_azimuth_start and
        state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) < shading_azimuth_end and
        state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) > shading_elevation_min and
        state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) < shading_elevation_max
      }}
    enabled: "{{ is_shading_enabled and default_sun_sensor != [] }}"
    id: "t_shading_start_pending_1"

  - trigger: template
    value_template: "{{ states(shading_brightness_sensor) not in invalid_states and states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > (shading_sun_brightness_start + shading_sun_brightness_hysteresis) }}"
    enabled: "{{ is_shading_enabled and shading_brightness_sensor != [] }}"
    id: "t_shading_start_pending_2"

  - trigger: template
    value_template: "{{ states(shading_temperatur_sensor1) not in invalid_states and states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > (shading_min_temperatur1 + shading_temperature_hysteresis1) }}"
    enabled: "{{ is_shading_enabled and shading_temperatur_sensor1 != [] }}"
    id: "t_shading_start_pending_3"

  - trigger: template
    value_template: "{{ states(shading_temperatur_sensor2) not in invalid_states and states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > (shading_min_temperatur2 + shading_temperature_hysteresis2) }}"
    enabled: "{{ is_shading_enabled and shading_temperatur_sensor2 != [] }}"
    id: "t_shading_start_pending_4"

  - trigger: template
    value_template: "{{ states(shading_forecast_sensor) not in invalid_states and states(shading_forecast_sensor) in shading_weather_conditions }}"
    enabled: "{{ is_shading_enabled and shading_forecast_sensor != [] }}"
    id: "t_shading_start_pending_5"

  - trigger: template
    value_template: "{{ states(shading_forecast_temp_sensor) not in invalid_states and states(shading_forecast_temp_sensor) | float(default=shading_forecast_temp) > (shading_forecast_temp + shading_forecast_temp_hysteresis) }}"
    enabled: "{{ is_shading_enabled and shading_forecast_temp_sensor != [] and shading_forecast_temp != [] }}"
    id: "t_shading_start_pending_6"

  - trigger: template # Required to recognize the maximum temperature value of the weather forecast before opening.
    value_template: "{{ now() >= today_at([time_up_early, time_up_early_non_workday] | min) - timedelta(hours = 1) }}"
    enabled: "{{ is_shading_enabled }}"
    id: "t_shading_start_pending_7"

  - trigger: template
    value_template: >-
      {% set helper_state = states(cover_status_helper) %}
      {{
        helper_state not in invalid_states and
        helper_state | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        helper_state | from_json | regex_search('shading') and
        (helper_state | from_json).shading.p is defined and
        (helper_state | from_json).shading.p > 0 and
        now() >= ((helper_state | from_json).shading.p) | as_datetime | as_local
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] }}"
    id: "t_shading_start_execution"

  - trigger: state
    entity_id: !input auto_shading_start_force
    from: "off"
    to: "on"
    enabled: "{{ auto_shading_start_force != [] }}"
    id: "t_force_enabled_shading"

  - trigger: state
    entity_id: !input auto_shading_start_force
    from: "on"
    to: "off"
    enabled: "{{ auto_shading_start_force != [] }}"
    id: "t_force_disabled_shading"

  ########################################
  # Triggers for shading tilt
  ########################################

  - trigger: template
    value_template: >-
      {{
        states(cover_status_helper) not in invalid_states and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_1
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: "t_shading_tilt_1"

  - trigger: template
    value_template: >-
      {{
        states(cover_status_helper) not in invalid_states and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_2 and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_1
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: "t_shading_tilt_2"

  - trigger: template
    value_template: >-
      {{
        states(cover_status_helper) not in invalid_states and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_3 and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_2
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: "t_shading_tilt_3"

  - trigger: template
    value_template: >-
      {{
        states(cover_status_helper) not in invalid_states and
        states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') and
        state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_3
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and is_cover_tilt_enabled and default_sun_sensor != [] }}"
    id: "t_shading_tilt_4"

  ########################################
  # Triggers for shading end
  ########################################

  - trigger: template
    value_template: "{{ states(shading_temperatur_sensor1) not in invalid_states and states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) < (shading_min_temperatur1 - shading_temperature_hysteresis1) }}"
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_temperatur_sensor1 != [] }}"
    id: "t_shading_end_pending_1"

  - trigger: template
    value_template: "{{ states(shading_temperatur_sensor2) not in invalid_states and states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) < (shading_min_temperatur2 - shading_temperature_hysteresis2) }}"
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_temperatur_sensor2 != [] }}"
    id: "t_shading_end_pending_2"

  - trigger: template
    value_template: "{{ states(shading_brightness_sensor) not in invalid_states and states(shading_brightness_sensor) | float(default=shading_sun_brightness_end) < (shading_sun_brightness_end - shading_sun_brightness_hysteresis) }}"
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_brightness_sensor != [] }}"
    id: "t_shading_end_pending_3"

  - trigger: template
    value_template: "{{ states(shading_forecast_sensor) not in shading_weather_conditions }}"
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_weather_conditions != [] and shading_forecast_sensor != [] }}"
    id: "t_shading_end_pending_4"

  - trigger: template
    value_template: >-
      {{
        (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start) < shading_azimuth_start) or
        (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end) > shading_azimuth_end) or
        (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max) > shading_elevation_max) or
        (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min) < shading_elevation_min)
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and default_sun_sensor != [] }}"
    id: "t_shading_end_pending_5"

  - trigger: template
    value_template: "{{ states(shading_forecast_temp_sensor) not in invalid_states and states(shading_forecast_temp_sensor) | float(default=shading_forecast_temp) < (shading_forecast_temp - shading_forecast_temp_hysteresis) }}"
    enabled: "{{ is_shading_enabled and cover_status_helper != [] and shading_forecast_temp_sensor != [] and shading_forecast_temp != [] }}"
    id: "t_shading_end_pending_6"

  - trigger: template
    value_template: >-
      {% set helper_state = states(cover_status_helper) %}
      {{
        helper_state not in invalid_states and
        helper_state | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        helper_state | from_json | regex_search('shading') and
        (helper_state | from_json).shading.q is defined and
        (helper_state | from_json).shading.q > 0 and
        now() >= ((helper_state | from_json).shading.q) | as_datetime | as_local
      }}
    enabled: "{{ is_shading_enabled and cover_status_helper != [] }}"
    id: "t_shading_end_execution"

  - trigger: template
    value_template: "{{ now() >= today_at('23:55:00') }}"
    id: "t_shading_reset"
    enabled: "{{ is_shading_enabled }}"

  ########################################
  # Trigger for manual cover controls
  ########################################

  # Position detection via current_position attribute (standard)
  - trigger: state
    entity_id: !input blind
    attribute: current_position
    enabled: "{{ position_source == 'current_position_attr' }}"
    id: "t_manual_position"
    for:
      seconds: 60 

  # Position detection via position attribute
  - trigger: state
    entity_id: !input blind
    attribute: position
    enabled: "{{ position_source == 'position_attr' }}"
    id: "t_manual_position"
    for:
      seconds: 60

  # Position detection via custom sensor
  - trigger: state
    entity_id: !input custom_position_sensor
    enabled: "{{ position_source == 'custom_sensor' and custom_position_sensor != [] }}"
    id: "t_manual_position"
    for:
      seconds: 60

  # Tilt detection
  - trigger: state
    entity_id: !input blind
    attribute: current_tilt_position
    id: "t_manual_tilt"
    for:
      minutes: 1
    enabled: "{{ is_cover_tilt_enabled }}"

  - trigger: template
    value_template: "{{ now() >= today_at(reset_override_time) }}"
    enabled: "{{ is_reset_fixed_time }}"
    id: "t_reset_fixedtime"
    for:
      minutes: 2

  - trigger: template
    value_template: >-
      {% set helper_state = states(cover_status_helper) %}
      {{
        helper_state not in invalid_states and
        helper_state | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") and
        helper_state | from_json | regex_search('manual') and
        (helper_state | from_json).manual.t is defined and
        (helper_state | from_json).manual.a is defined and
        (helper_state | from_json).manual.a | bool is true and
         now() >= ((helper_state | from_json).manual.t + 60 * reset_override_timeout) | as_datetime | as_local
      }}
    enabled: "{{ is_reset_timeout and cover_status_helper != [] }}"
    id: "t_reset_timeout"
    for:
      seconds: 2

################################################################################
# GLOBAL CONDITIONS
################################################################################

conditions:
  - condition: !input auto_global_condition
  - or:
      - "{{ trigger.to_state is not defined }}" # for "trigger: time"-Trigger
      - "{{ trigger.to_state is defined and trigger.to_state.state not in invalid_states }}" # The following values are not valid to trigger
  - or:
      - "{{ trigger.id is not defined }}"
      - "{{ not trigger.id | regex_match('^t_calendar_event') }}"
      - and:
          - "{{ trigger.id | regex_match('^t_calendar_event') }}"
          - "{{ state_attr(calendar_entity, 'message') is not none }}"
          - >-
            {{
              calendar_open_title_lc in (state_attr(calendar_entity, 'message') | lower) or
              calendar_close_title_lc in (state_attr(calendar_entity, 'message') | lower)
            }}
  - condition: template
    value_template: >-
      {% if trigger.id is match('^t_shading_start_pending_[1-6]$') %}
        {{ states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*0') }}
      {% elif trigger.id is match('^t_shading_end_pending_[1-6]$') %}
        {{ states(cover_status_helper) | regex_search('"shading"\s*:\s*\{[^}]*"a"\s*:\s*1') }}
      {% else %}
        true
      {% endif %}

################################################################################
# ACTIONS
################################################################################

actions:

  # YAML Anchors ###############################################################
  - variables:
      cover_move_action: &cover_move_action
        sequence:
          - condition: template
            value_template: "{{ not prevent_flags.default_cover_actions }}"
          - repeat:
              for_each: "{{ blind_entities | list }}"
              sequence:
                - choose:
                    # Full Close
                    - conditions: "{{ target_position | default(101) | int == 0 }}"
                      sequence:
                        - service: cover.close_cover
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"

                    # Full Open
                    - conditions: "{{ target_position | default(101) | int == 100 }}"
                      sequence:
                        - service: cover.open_cover
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"

                    # Partial Position (1-99)
                    - conditions: "{{ 0 < target_position | default(101) | int < 100 }}"
                      sequence:
                        - service: cover.set_cover_position
                          data:
                            position: "{{ target_position | default(101) | int }}"
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"

                - delay: # Small random delay between covers to avoid RF interference
                    seconds: "{{ range(1, 3) | random }}"

      tilt_move_action: &tilt_move_action
        sequence:
          - condition: template
            value_template: "{{ not prevent_flags.default_cover_actions and is_cover_tilt_enabled_and_possible }}"
          - repeat:
              for_each: "{{ blind_entities | list }}"
              sequence:
                - if: "{{ state_attr(repeat.item if repeat is defined else '', 'current_tilt_position') is defined }}"
                  then:
                    # Optional: Reset tilt to 0 (Reposition Mode)
                    - if: "{{ tilt_first | default(false) }}"
                      then:
                        - service: cover.set_cover_tilt_position
                          data:
                            tilt_position: 0
                          target:
                            entity_id: "{{ repeat.item if repeat is defined else '' }}"
                        - delay:
                            seconds: !input tilt_delay

                    # Wait Strategy: Ensure cover is idle before tilting
                    - choose:
                        # Mode: Wait until movement stops
                        - conditions: "{{ is_tilt_wait_idle_mode | default(false) }}"
                          sequence:
                            - wait_template: "{{ states(repeat.item if repeat is defined else '') in ['open', 'closed'] }}"
                              timeout: "{{ tilt_wait_timeout | int }}"
                              continue_on_timeout: true
                            # Safety buffer after reaching idle state
                            - if: "{{ wait.completed if wait is defined else '' }}"
                              then:
                                - delay: 1
                      # Mode: Standard fixed delay
                      default:
                        - delay:
                            seconds: !input tilt_delay

                    # Set target tilt position
                    - service: cover.set_cover_tilt_position
                      data:
                        tilt_position: "{{ target_tilt_position | default(101) }}"
                      target:
                        entity_id: "{{ repeat.item if repeat is defined else '' }}"

                    # RF Anti-Interference delay
                    - delay:
                        seconds: "{{ range(1, 3) | random }}"

      helper_update: &helper_update
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: |-
                {% set dict_var = helper_json %}
                {% set updates = update_values | default({}) %}
                {% if dict_var.v == 6 %}
                  
                  {% set ts_now = as_timestamp(now()) | round(0) %}
                  {% set new_state = dict_var.state %}
                  {% set new_pending = dict_var.pending %}
                  {% set new_ts = dict_var.ts %}

                  
                  {% if 'state' in updates %}
                    {% set new_state = dict(new_state, **updates.state) %}
                  {% endif %}
                  {% if 'pending' in updates %}
                    {% set new_pending = dict(new_pending, **updates.pending) %}
                  {% endif %}
                  {% if 'ts' in updates %}
                    {% set new_ts = dict(new_ts, **updates.ts) %}
                  {% endif %}

                  {% set dict_new = dict(dict_var, state=new_state, pending=new_pending, ts=new_ts, t=ts_now) %}
                  {{ dict_new | to_json }}
                {% else %}
                  
                  {% set dict_new = dict(dict_var, **updates) %}
                  {{ dict_new | to_json }}
                {% endif %}

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Load weather forecast data from service (only when needed)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  - if:
      - "{{ is_shading_enabled }}"
      - "{{ forecast_source.use_weather and not forecast_source.prevent_service }}"
      - "{{ states(shading_forecast_sensor) not in invalid_states }}"
      - "{{ trigger.id is defined }}"
      - "{{ trigger.id | regex_match('^(t_shading_start|t_open_1|t_open_3)') }}" # Important: All triggers for shading start necessary!
    then:
      - action: weather.get_forecasts
        target:
          entity_id: !input shading_forecast_sensor
        data:
          type: !input shading_forecast_type
        response_variable: weather_forecast
        continue_on_error: true

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Load calendar events for today (00:00 to 23:59)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  - if:
      # Only load when calendar is enabled and entity is valid
      - "{{ is_calendar_enabled }}"
      - "{{ calendar_entity != [] }}"
      - "{{ states(calendar_entity) not in invalid_states }}"
      - "{{ trigger.id is defined }}"
      # Performance: Only load on relevant triggers
      - or:
          - "{{ trigger.id | regex_match('^t_open') }}"
          - "{{ trigger.id | regex_match('^t_close') }}"
          - "{{ trigger.id | regex_match('^t_shading_start') }}"
          - "{{ trigger.id | regex_match('^t_calendar_event') }}"
          - "{{ trigger.id.startswith('t_force_disabled') }}"
    then:
      - action: calendar.get_events
        target:
          entity_id: !input calendar_entity
        data:
          # Get all events for today (00:00:00 to 23:59:59)
          start_date_time: "{{ today_at('00:00:00').isoformat() }}"
          end_date_time: "{{ (today_at('23:59:59') + timedelta(seconds=1)).isoformat() }}"
        response_variable: calendar_events
        continue_on_error: true  # Don't fail if calendar is temporarily unavailable

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Recalculate ALL forecast-dependent variables (even if forecast wasn't loaded)
  # This ensures variables are always defined and prevents crashes
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  - variables:
      # Forecast data normalisation.
      # Temperature from sensor (priority) or weather entity
      forecast_temp_raw: >-
        {% set sensor = shading_forecast_temp_sensor %}
        {% set weather = shading_forecast_sensor %}
        {% if sensor != [] and states(sensor) not in invalid_states %}
          {{ states(sensor) | float(default=None) }}
        {% elif weather == [] or states(weather) in invalid_states %}
          {{ None }}
        {% elif 'weather_attributes' in shading_forecast_type %}
          {{ state_attr(weather, 'temperature') | float(default=None) }}
        {% elif weather_forecast is defined and weather in weather_forecast %}
          {{ weather_forecast[weather].forecast[0].temperature | default(None) | float(default=None) }}
        {% else %}
          {{ None }}
        {% endif %}

      # Weather condition (only from weather entity)
      forecast_weather_condition_raw: >-
        {% set weather = shading_forecast_sensor %}
        {% if weather == [] or states(weather) in invalid_states %}
          {{ None }}
        {% elif 'weather_attributes' in shading_forecast_type %}
          {{ state_attr(weather, 'condition') }}
        {% elif weather_forecast is defined and weather in weather_forecast %}
          {{ weather_forecast[weather].forecast[0].condition | default(None) }}
        {% else %}
          {{ None }}
        {% endif %}

      # SHADING START - Individual Condition Evaluations
      # All START conditions evaluated and stored in one dictionary
      shading_start_condition_states:
        azimuth_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.azimuth or
            default_sun_sensor == [] or
            (
              current_sun_azimuth | float(default=0) > shading_azimuth_start and
              current_sun_azimuth | float(default=0) < shading_azimuth_end
            )
          }}
        elevation_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.elevation or
            default_sun_sensor == [] or
            (
              current_sun_elevation | float(default=0) > shading_elevation_min and
              current_sun_elevation | float(default=0) < shading_elevation_max
            )
          }}
        brightness_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.brightness or
            shading_brightness_sensor == [] or
            (
              states(shading_brightness_sensor) not in invalid_states and
              states(shading_brightness_sensor) | float(default=shading_sun_brightness_start) > (shading_sun_brightness_start + shading_sun_brightness_hysteresis)
            )
          }}
        temp1_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.temp1 or
            shading_temperatur_sensor1 == [] or
            (
              states(shading_temperatur_sensor1) not in invalid_states and
              states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1) > (shading_min_temperatur1 + shading_temperature_hysteresis1)
            )
          }}
        temp2_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.temp2 or
            shading_temperatur_sensor2 == [] or
            (
              states(shading_temperatur_sensor2) not in invalid_states and
              states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2) > (shading_min_temperatur2 + shading_temperature_hysteresis2)
            )
          }}
        forecast_temp_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.forecast_temp or
            shading_forecast_temp == [] or
            (
              forecast_temp_raw is not none and
              forecast_temp_raw > (shading_forecast_temp + shading_forecast_temp_hysteresis)
            ) or
            (
              'shading_compare_forecast_with_sensor2' in shading_config and
              shading_temperatur_sensor2 != [] and
              shading_forecast_temp != [] and
              (states(shading_temperatur_sensor2) | float(default=0) > (shading_forecast_temp + shading_forecast_temp_hysteresis))
            )
          }}
        forecast_weather_valid: >-
          {{
            not is_shading_enabled or
            not shading_start_condition_enabled.forecast_weather or
            shading_weather_conditions == [] or
            forecast_source.use_sensor or
            (
              forecast_weather_condition_raw is not none and
              forecast_weather_condition_raw not in invalid_states and
              forecast_weather_condition_raw in shading_weather_conditions
            )
          }}

      # SHADING START - Combined AND/OR Logic
      # START AND: All required conditions must be true
      shading_start_and_result: >-
        {{
          (
            ('cond_azimuth' not in shading_conditions_start_and or
            default_sun_sensor == [] or
            shading_start_condition_states.azimuth_valid)
            and
            ('cond_elevation' not in shading_conditions_start_and or
            default_sun_sensor == [] or
            shading_start_condition_states.elevation_valid)
            and
            ('cond_brightness' not in shading_conditions_start_and or
            shading_brightness_sensor == [] or
            shading_start_condition_states.brightness_valid)
            and
            ('cond_temp1' not in shading_conditions_start_and or
            shading_temperatur_sensor1 == [] or
            shading_start_condition_states.temp1_valid)
            and
            ('cond_temp2' not in shading_conditions_start_and or
            shading_temperatur_sensor2 == [] or
            shading_start_condition_states.temp2_valid)
            and
            ('cond_forecast_temp' not in shading_conditions_start_and or
            shading_forecast_temp == [] or
            shading_start_condition_states.forecast_temp_valid)
            and
            ('cond_forecast_weather' not in shading_conditions_start_and or
            shading_weather_conditions == [] or
            shading_start_condition_states.forecast_weather_valid)
          )
        }}

      # START OR: At least one optional condition must be true (or none required)
      shading_start_or_result: >-
        {{
          (shading_conditions_start_or | count == 0) or
          (
            ('cond_azimuth' in shading_conditions_start_or and
            default_sun_sensor != [] and
            shading_start_condition_states.azimuth_valid)
            or
            ('cond_elevation' in shading_conditions_start_or and
            default_sun_sensor != [] and
            shading_start_condition_states.elevation_valid)
            or
            ('cond_brightness' in shading_conditions_start_or and
            shading_brightness_sensor != [] and
            shading_start_condition_states.brightness_valid)
            or
            ('cond_temp1' in shading_conditions_start_or and
            shading_temperatur_sensor1 != [] and
            shading_start_condition_states.temp1_valid)
            or
            ('cond_temp2' in shading_conditions_start_or and
            shading_temperatur_sensor2 != [] and
            shading_start_condition_states.temp2_valid)
            or
            ('cond_forecast_temp' in shading_conditions_start_or and
            shading_forecast_temp != [] and
            shading_start_condition_states.forecast_temp_valid)
            or
            ('cond_forecast_weather' in shading_conditions_start_or and
            shading_weather_conditions != [] and
            shading_start_condition_states.forecast_weather_valid)
          )
        }}

      # Final START condition: All AND conditions + at least one OR condition
      shading_start_conditions_met: >-
        {{
          is_shading_enabled and
          shading_start_and_result and
          shading_start_or_result
        }}

      # SHADING END - Individual Condition Evaluations
      # All END conditions evaluated with inverse logic and stored in one dictionary
      shading_end_condition_states:
        azimuth_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.azimuth and
            default_sun_sensor != [] and
            (
              current_sun_azimuth | float(default=999) <= shading_azimuth_start or
              current_sun_azimuth | float(default=0) >= shading_azimuth_end
            )
          }}
        elevation_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.elevation and
            default_sun_sensor != [] and
            (
              current_sun_elevation | float(default=999) <= shading_elevation_min or
              current_sun_elevation | float(default=0) >= shading_elevation_max
            )
          }}
        brightness_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.brightness and
            shading_brightness_sensor != [] and
            states(shading_brightness_sensor) not in invalid_states and
            states(shading_brightness_sensor) | float(default=999999) < (shading_sun_brightness_end - shading_sun_brightness_hysteresis)
          }}
        temp1_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.temp1 and
            shading_temperatur_sensor1 != [] and
            states(shading_temperatur_sensor1) not in invalid_states and
            states(shading_temperatur_sensor1) | float(default=999) < (shading_min_temperatur1 - shading_temperature_hysteresis1)
          }}
        temp2_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.temp2 and
            shading_temperatur_sensor2 != [] and
            states(shading_temperatur_sensor2) not in invalid_states and
            states(shading_temperatur_sensor2) | float(default=999) < (shading_min_temperatur2 - shading_temperature_hysteresis2)
          }}
        forecast_temp_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.forecast_temp and
            shading_forecast_temp != [] and
            forecast_temp_raw is not none and
            forecast_temp_raw < (shading_forecast_temp - shading_forecast_temp_hysteresis)
          }}
        forecast_weather_invalid: >-
          {{
            is_shading_enabled and
            shading_end_condition_enabled.forecast_weather and
            shading_weather_conditions != [] and
            (
              forecast_weather_condition_raw is none or
              forecast_weather_condition_raw in invalid_states or
              forecast_weather_condition_raw not in shading_weather_conditions
            )
          }}

      # SHADING END - Combined AND/OR Logic
      # END AND: All specified conditions must become invalid
      shading_end_and_result: >-
        {{
          shading_conditions_end_and | count > 0 and
          (
            ('cond_azimuth' not in shading_conditions_end_and or shading_end_condition_states.azimuth_invalid)
            and
            ('cond_elevation' not in shading_conditions_end_and or shading_end_condition_states.elevation_invalid)
            and
            ('cond_brightness' not in shading_conditions_end_and or shading_end_condition_states.brightness_invalid)
            and
            ('cond_temp1' not in shading_conditions_end_and or shading_end_condition_states.temp1_invalid)
            and
            ('cond_temp2' not in shading_conditions_end_and or shading_end_condition_states.temp2_invalid)
            and
            ('cond_forecast_temp' not in shading_conditions_end_and or shading_end_condition_states.forecast_temp_invalid)
            and
            ('cond_forecast_weather' not in shading_conditions_end_and or shading_end_condition_states.forecast_weather_invalid)
          )
        }}

      # END OR: At least one specified condition must become invalid
      # TODO: Unlike shading_start_or_result, this checks ALL conditions regardless of whether they are in shading_conditions_end_or list.
      #       This is inconsistent behavior that may cause unexpected shading end triggers. Consider aligning with START logic.
      shading_end_or_result: >-
        {{
          shading_conditions_end_or | count > 0 and
          (
            shading_end_condition_states.azimuth_invalid or
            shading_end_condition_states.elevation_invalid or
            shading_end_condition_states.brightness_invalid or
            shading_end_condition_states.temp1_invalid or
            shading_end_condition_states.temp2_invalid or
            shading_end_condition_states.forecast_temp_invalid or
            shading_end_condition_states.forecast_weather_invalid
          )
        }}

      # Final END condition: AND result OR OR result
      shading_end_conditions_met: >-
        {{
          is_shading_enabled and
          (
            shading_end_and_result or
            shading_end_or_result
          )
        }}


      # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
      # ‚ïë CALENDAR EVENT PARSING                                             ‚ïë
      # ‚ïë Parse today's calendar events to extract time windows              ‚ïë
      # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

      # Parse "Open Cover" event from today's calendar events
      # Returns dictionary with: found (bool), start (datetime), end (datetime)
      calendar_open_event: >-
        {% set result = namespace(found=false, start=none, end=none) %}
        {% if is_calendar_enabled and calendar_events is defined and calendar_entity in calendar_events %}
          {% set events = calendar_events[calendar_entity].events | default([]) %}
          {% for event in events %}
            {% set summary = (event.summary | default('')) | lower | trim %}
            {% if calendar_open_title_lc != '' and calendar_open_title_lc in summary %}
              {% set result.found = true %}
              {% set result.start = event.start %}
              {% set result.end = event.end %}
            {% endif %}
          {% endfor %}
        {% endif %}
        {{ {
          'found': result.found,
          'start': result.start,
          'end': result.end
        } }}

      # Parse "Close Cover" event from today's calendar events
      calendar_close_event: >-
        {% set result = namespace(found=false, start=none, end=none) %}
        {% if is_calendar_enabled and calendar_events is defined and calendar_entity in calendar_events %}
          {% set events = calendar_events[calendar_entity].events | default([]) %}
          {% for event in events %}
            {% set summary = (event.summary | default('')) | lower | trim %}
            {% if calendar_close_title_lc != '' and calendar_close_title_lc in summary %}
              {% set result.found = true %}
              {% set result.start = event.start %}
              {% set result.end = event.end %}
            {% endif %}
          {% endfor %}
        {% endif %}
        {{ {
          'found': result.found,
          'start': result.start,
          'end': result.end
        } }}

      # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
      # ‚ïë CALENDAR TIMESTAMPS                                                ‚ïë
      # ‚ïë Convert event times to timestamps for numeric comparisons          ‚ïë
      # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

      # Current time as timestamp (for calendar time comparisons)
      now_ts: "{{ as_timestamp(now()) }}"

      # Open event start time (timestamp) - equivalent to time_up_early
      calendar_open_start: >-
        {% if calendar_open_event.found and calendar_open_event.start is not none %}
          {{ as_timestamp(calendar_open_event.start) }}
        {% else %}
          {{ none }}
        {% endif %}

      # Open event end time (timestamp) - equivalent to time_up_late
      calendar_open_end: >-
        {% if calendar_open_event.found and calendar_open_event.end is not none %}
          {{ as_timestamp(calendar_open_event.end) }}
        {% else %}
          {{ none }}
        {% endif %}

      # Close event start time (timestamp) - equivalent to time_down_early
      calendar_close_start: >-
        {% if calendar_close_event.found and calendar_close_event.start is not none %}
          {{ as_timestamp(calendar_close_event.start) }}
        {% else %}
          {{ none }}
        {% endif %}

      # Close event end time (timestamp) - equivalent to time_down_late
      calendar_close_end: >-
        {% if calendar_close_event.found and calendar_close_event.end is not none %}
          {{ as_timestamp(calendar_close_event.end) }}
        {% else %}
          {{ none }}
        {% endif %}

      # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
      # ‚ïë TIME PHASE DETECTION (UNIFIED FOR TIME AND CALENDAR)               ‚ïë
      # ‚ïë These variables work for BOTH time input and calendar mode         ‚ïë
      # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

      # Opening Phase = Time window between early and late opening
      # Used for: Environmental condition checks during opening window
      is_opening_phase: >-
        {{
          (
            is_time_field_enabled and
            now() >= today_at(time_up_early_today) and
            now() < today_at(time_up_late_today)
          ) or
          (
            is_calendar_enabled and
            calendar_open_start is not none and
            calendar_open_end is not none and
            now_ts >= calendar_open_start and
            now_ts < calendar_open_end
          )
        }}

      # Daytime Phase = Cover should be open (after opening until closing starts)
      # Used for: Resident logic, general "day" detection, shading availability
      is_daytime_phase: >-
        {{
          is_time_control_disabled or
          (
            is_time_field_enabled and
            now() >= today_at(time_up_early_today) and
            now() < today_at(time_down_early_today)) or
          (
            is_calendar_enabled and
            calendar_open_start is not none and
            calendar_close_start is not none and
            now_ts >= calendar_open_start and
            now_ts < calendar_close_start)
        }}

      # Closing Phase = Time window between early and late closing
      # Used for: Environmental condition checks during closing window
      is_closing_phase: >-
        {{
          (
            is_time_field_enabled and
            now() >= today_at(time_down_early_today) and
            now() < today_at(time_down_late_today)
          ) or
          (
            is_calendar_enabled and
            calendar_close_start is not none and
            calendar_close_end is not none and
            now_ts >= calendar_close_start and
            now_ts < calendar_close_end
          )
        }}

      # Evening Phase = Cover should be closed (from closing time onwards)
      # Used for: Prevent unwanted opening after close time
      is_evening_phase: >-
        {{
          not is_time_control_disabled and
          (
            (
              is_time_field_enabled and
              now() >= today_at(time_down_early_today)
            ) or
            (
              is_calendar_enabled and
              calendar_close_start is not none and
              now_ts >= calendar_close_start
            )
          )
        }}

      # Late opening time reached (forced opening trigger)
      is_time_up_late: >-
        {{
          (
            is_time_field_enabled and
            now() >= today_at(time_up_late_today) and
            now() < today_at(time_down_early_today)
          ) or
          (
            is_calendar_enabled and
            calendar_open_end is not none and
            calendar_close_start is not none and
            now_ts >= calendar_open_end and
            now_ts < calendar_close_start
          )
        }}

      # Late closing time reached (forced closing trigger)
      is_time_down_late: >-
        {{
          (
            is_time_field_enabled and
            now() >= today_at(time_down_late_today)
          ) or
          (
            is_calendar_enabled and
            calendar_close_end is not none and
            now_ts >= calendar_close_end
          )
        }}

      # Extended daytime window: Allows shading even during closing phase
      # Used in: All shading logic to ensure shading only during daytime
      is_shading_allowed_window: >-
        {{
          is_time_control_disabled or
          (
            is_time_field_enabled and
            now() >= today_at(time_up_early_today) and
            now() <= today_at(time_down_late_today) + timedelta(seconds = 5)
          ) or
          (
            is_calendar_enabled and
            calendar_open_start is not none and
            calendar_close_end is not none and
            now_ts >= calendar_open_start and
            now_ts <= calendar_close_end
          )
        }}

      # ========== ENVIRONMENTAL CONDITIONS ==========

      # ALL enabled sensors must allow opening (AND logic)
      environment_allows_opening: >-
        {{
          (
            not is_brightness_enabled or
            default_brightness_sensor == [] or
            states(default_brightness_sensor) | float(default=brightness_up) > (brightness_up + brightness_hysteresis)
          ) and
          (
            not is_sun_elevation_enabled or
            default_sun_sensor == [] or
            current_sun_elevation | float(default=sun_elevation_up_current) > sun_elevation_up_current
          )
        }}

      # At least one enabled sensor must require closing (OR logic)
      environment_allows_closing: >-
        {{
          (
            is_brightness_enabled and
            (
              default_brightness_sensor == [] or
              states(default_brightness_sensor) | float(default=brightness_down) < (brightness_down - brightness_hysteresis)
            )
          ) or
          (
            is_sun_elevation_enabled and
            (
              default_sun_sensor == [] or
              current_sun_elevation | float(default=sun_elevation_down_current) < sun_elevation_down_current
            )
          )
        }}

      # ========== COMBINED CONDITIONS ==========

      # Should cover be open right now? (for resident logic)
      should_be_open_now: >-
        {{
          is_daytime_phase and
          not is_evening_phase and
          (
            (not is_brightness_enabled and not is_sun_elevation_enabled) or
            environment_allows_opening
          )
        }}

      # Should cover be closed right now? (not use atm)
      should_be_closed_now: >-
        {{
          is_evening_phase and
          (
            (not is_brightness_enabled and not is_sun_elevation_enabled) or
            environment_allows_closing
          )
        }}

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # MANDATORY HELPER VALIDATION
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Cover Control Automation requires a properly configured Cover Status Helper.
  # This validation ensures all prerequisites are met before automation execution.
  - if:
      - "{{ cover_status_helper == [] }}"
    then:
      - action: system_log.write
        data:
          message: >-
            Cover Control Automation ({{ friendly_name }}): CONFIGURATION ERROR - Cover Status Helper is required but not configured.
            Please configure a Cover Status Helper (input_text entity) in the automation settings.
          level: error
      - action: logbook.log
        data:
          name: "Cover Control Automation"
          message: >-
            ‚ùå {{ friendly_name }}: Automation stopped - Cover Status Helper not configured.
            A valid input_text helper is mandatory. Please configure it in the automation settings.
          entity_id: "{{ blind_entities[0] if blind_entities else none }}"
      - stop: "Missing Cover Status Helper configuration"

  - if:
      - or:
          - "{{ states(cover_status_helper) in invalid_states }}"
          - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") }}'
    then:
      - action: system_log.write
        data:
          message: >-
            Cover Control Automation ({{ friendly_name }}): HELPER VALIDATION WARNING - Cover Status Helper contains invalid or empty data.
            Helper: {{ cover_status_helper }}, Current state: {{ states(cover_status_helper) }}
            The helper will be initialized with default structure.
          level: warning
      - action: logbook.log
        data:
          name: "Cover Control Automation"
          message: >-
            ‚ö†Ô∏è {{ friendly_name }}: Cover Status Helper invalid - initializing with default structure.
          entity_id: "{{ cover_status_helper }}"

  # Initialise empty helper with JSON default values #########################
  - if:
      - or:
          - "{{ states(cover_status_helper) in invalid_states }}"
          - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)") }}'
    then:
      - action: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{{ helper_json | to_json }}"

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Upgrade JSON-helper
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  - if:
      - "{{ helper_json.v != 6 }}"
    then:
      - variables:
          ts_now: "{{ as_timestamp(now()) | round(0) }}"
      - variables:
          update_values:
            v: 6
            t: "{{ ts_now }}"
            state:
              current: "{{ state_current }}"  # current state
              target: "{{ state_current }}"  # target = current (initially)
              force: "none"  # no force active initially
              resident: "{{ 1 if (resident_sensor != [] and is_state(resident_sensor, 'on')) else 0 }}"
              man: "{{ state_manual }}"
            pending:
              start: "{{ (helper_json.shading.p | default(0)) if helper_json.v == 5 else 0 }}"
              end: "{{ (helper_json.shading.q | default(0)) if helper_json.v == 5 else 0 }}"
            ts:
              open: "{{ ((helper_json.open.t | default(0) | int) % 86400) if (helper_json.open.t | default(0) | int) > 0 else 0 }}"
              close: "{{ ((helper_json.close.t | default(0) | int) % 86400) if (helper_json.close.t | default(0) | int) > 0 else 0 }}"
              shade: "{{ ((helper_json.shading.t | default(0) | int) % 86400) if (helper_json.shading.t | default(0) | int) > 0 else 0 }}"
              vpart: "{{ ((helper_json.vpart.t | default(0) | int) % 86400) if (helper_json.vpart.t | default(0) | int) > 0 else 0 }}"
              vfull: "{{ ((helper_json.vfull.t | default(0) | int) % 86400) if (helper_json.vfull.t | default(0) | int) > 0 else 0 }}"
              man: "{{ ((helper_json.manual.t | default(0) | int) % 86400) if (helper_json.manual.t | default(0) | int) > 0 else 0 }}"
      - *helper_update

  - choose:

      ############################################################
      # BRANCH (0): OPEN
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Open, Shading
      ############################################################

      - alias: "Check for opening"
        conditions:
          - "{{ is_up_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_open|t_force_disabled|t_calendar_event)') }}"
          - condition: !input auto_up_condition
          - or: # When background state tracking is enabled, let the force-disabled triggers handle this.
              - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - "{{ not is_auto_recover_enabled }}"
          - or: # Use centralized force check
              - "{{ is_auto_recover_enabled }}"
              - "{{ can_move_open }}"  # Simplified from is_cover_movement_blocked.open
          - or: # Check state or position
              - "{{ state_current != 'open' }}"
              - "{{ not in_open_position }}"
          - "{{ not (state_current == 'manual' and override_flags.opening) }}" # Override check
          - or: # Only once a day?
              - "{{ not prevent_flags.opening_multiple_times }}"
              - "{{ prevent_flags.opening_multiple_times and ((now().day != helper_json.ts.open|timestamp_custom('%-d')|int) or helper_json.ts.man <= helper_json.ts.open) }}"
          - or: # Check whether the resident trigger is allowed
              - "{{ trigger.id != 't_open_6' }}"
              - and:  # For t_open_6: check conditions
                  - "{{ trigger.id == 't_open_6' }}"
                  - "{{ resident_flags.opening_enabled }}"
                  - "{{ should_be_open_now }}"
          - "{{ can_open_with_resident }}"
          - or: # Opening scenarios - works for BOTH time and calendar mode
              - "{{ is_time_control_disabled }}"
              - and: # Ultimate opening ONLY for time triggers (no environment checks)
                  - "{{ is_time_up_late }}"
                  - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - and: # All other triggers: WITH environment checks
                  - "{{ is_opening_phase or is_daytime_phase }}"
                  - "{{ not is_evening_phase }}"
                  - "{{ environment_allows_opening }}"
        sequence:
          - delay:
              seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"

          - choose:
              ###################################
              # Cover should be shaded
              ###################################
              - alias: "Shading detected. Move to shading position"
                conditions:
                  - or:
                      - "{{ state_is_shaded }}"
                      - "{{ state_pending_start }}"
                  - "{{ not in_shading_position }}" # Even if this is hardly possible, there may be situations that require it. Purely as a precautionary measure in case the target state and actual state do not match.
                sequence:
                  - choose: []
                    default: !input auto_shading_start_action_before
                  - variables:
                      target_position: !input shading_position
                      target_tilt_position: "{{ shading_tilt_position | int }}"
                      ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                      update_values:
                        state:
                          current: "shade"
                          target: "open"
                          man: 0
                        ts:
                          shade: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - if: "{{ can_move_shade }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                      - choose: []
                        default: !input auto_shading_start_action
                  - if:
                      - "{{ is_auto_recover_enabled or can_move_shade }}"
                    then:
                      - *helper_update
                  - stop: "Opening skipped: Shading detected"

              ###################################
              # Cover should be opened
              ###################################
              - alias: "Normal opening of the cover"
                conditions:
                  - "{{ not in_shading_position }}" # In this part, there is no plan for an open roller blind to switch from Shading to Open.
                  - or:
                      - "{{ state_current != 'open' }}"
                      - "{{ not in_open_position }}"
                sequence:
                  - choose: []
                    default: !input auto_up_action_before
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: "{{ open_tilt_position | int }}"
                      ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                      update_values:
                        state:
                          current: "open"
                          target: "open"
                          man: 0
                        ts:
                          open: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - if: "{{ can_move_open }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                      - choose: []
                        default: !input auto_up_action
                  - if:
                      - "{{ is_auto_recover_enabled or can_move_open }}"
                    then:
                      - *helper_update
                  - stop: "Opening executed"

      ############################################################
      # BRANCH (1): CLOSE
      #   Source: All (Open, Close, Ventilation, Shading)
      #   Target: Close, Ventilation
      ############################################################

      - alias: "Check for closing cover"
        conditions:
          - "{{ is_down_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_close|t_force_disabled|t_calendar_event)') }}"
          - condition: !input auto_down_condition
          - or: # When background state tracking is enabled, let choose 12 handle force-disabled triggers
              - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - "{{ not is_auto_recover_enabled }}"
          - or: # Use centralized force check
              - "{{ is_auto_recover_enabled }}"
              - "{{ can_move_close }}"  # Simplified from is_cover_movement_blocked.close
          - or: # Check state or position
              - "{{ state_current != 'close' }}"
              - "{{ not in_close_position }}"
          - "{{ not (state_current == 'manual' and override_flags.closing) }}" # Override check
          - or: # Only once a day?
              - "{{ not prevent_flags.closing_multiple_times }}"
              - "{{ prevent_flags.closing_multiple_times and ((helper_json.ts.close < today_at(time_down_early_today) | as_timestamp) or helper_json.ts.man <= helper_json.ts.close) }}"
          - or: # Closing scenarios - works for BOTH time and calendar mode
              - "{{ is_time_control_disabled }}"
              - and: # Ultimate closing ONLY for time triggers (no environment checks)
                  - "{{ is_time_down_late }}"
                  - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - and: # Resident goes sleeping (ultimate closing)
                  - "{{ trigger.id == 't_close_6' }}"
                  - "{{ can_close_with_resident }}"
                  - "{{ resident_flags.closing_enabled }}"
              - and: # All other triggers: WITH environment checks
                  - "{{ is_closing_phase or is_evening_phase }}"
                  - "{{ environment_allows_closing }}"
        sequence:
          - choose:
              #################################
              # Lockout protection when closing
              #################################
              - alias: "Lockout protection when closing"
                conditions:
                  - "{{ is_ventilation_enabled }}"
                  - or:
                      - and:
                          - "{{ contact_window_opened != [] }}"
                          - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                      - and:
                          - "{{ lockout_tilted_when_closing }}"
                          - "{{ contact_window_tilted != [] }}"
                          - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                sequence:
                  - variables:
                      ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                      update_values:
                        state:
                          current: "vfull"
                          target: "close"
                          man: 0
                        ts:
                          vfull: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - stop: "Closing skipped: Lockout enabled"

              ############################################################################
              # Window tilted. No lockout. Move to ventilation position instead of closing
              ############################################################################
              - alias: "Window tilted. No lockout. Move to ventilation position instead of closing"
                conditions:
                  - "{{ is_ventilation_enabled }}"
                  - "{{ contact_window_tilted != [] }}"
                  - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                  - "{{ not lockout_tilted_when_closing }}"
                  - or:
                      - "{{ contact_window_opened == [] }}"
                      - "{{ states(contact_window_opened) in ['false', 'off'] }}"

                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - delay:
                      seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                      update_values:
                        state:
                          current: "vpart"
                          target: "close"
                          man: 0
                        ts:
                          vpart: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - if: "{{ can_move_ventilate }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                      - choose: []
                        default: !input auto_ventilate_action
                  - if:
                      - "{{ is_auto_recover_enabled or can_move_ventilate }}"
                    then:
                      - *helper_update
                  - stop: "Closing skipped: Window tilted (Ventilation activated)"

              ###################################
              # Cover is already (almost) closed
              ###################################
              - alias: "Only status change if cover is already 'near' the close position" # No driving here!
                conditions:
                  - or:
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ prevent_flags.lowering_when_closing_if_shaded }}"
                          - "{{ state_is_shaded }}"
                          - "{{ not position_comparisons.shading_above_close }}"
                      - and: # Stop if cover is shaded and close position is lower than shading position
                          - "{{ prevent_flags.lowering_when_closing_if_shaded }}"
                          - "{{ in_shading_position }}" # Always, no further checks for 'is_status_helper_enabled'
                          - "{{ not position_comparisons.shading_above_close }}"
                      - and: # Stop if close-position is higher than the current position
                          - "{{ prevent_flags.higher_position_closing }}"
                          - "{{ position_comparisons.current_below_close or current_position == close_position }}"
                sequence:
                  - variables:
                      ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                      update_values:
                        state:
                          current: "close"
                          target: "close"
                          man: 0
                        ts:
                          close: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - stop: "Closing skipped: Cover is already at or near targeted position (or lowering blocked by shading settings)"

            ###################################
            # Normal closing of the cover
            ###################################
            default:
              - choose: []
                default: !input auto_down_action_before
              - alias: "Normal closing of the cover"
                delay:
                  seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
              - variables:
                  target_position: !input close_position
                  target_tilt_position: !input close_tilt_position
                  ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                  update_values:
                    state:
                      current: "close"
                      target: "close"
                      man: 0
                    ts:
                      close: "{{ (ts_now % 86400) | int }}"
                    pending:
                      start: 0
                      end: 0
              - if: "{{ can_move_close }}"
                then:
                  - *cover_move_action
                  - *tilt_move_action
                  - choose: []
                    default: !input auto_down_action
              - if:
                  - "{{ is_auto_recover_enabled or can_move_close }}"
                then:
                  - *helper_update
              - stop: "Closing executed"

      ############################################################
      # BRANCH (2): SHADING START
      #   Source: Open
      #   Target: Shading, Lockout
      ############################################################

      - alias: "Check for shading start"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_start|t_open_1|t_open_3|t_force_disabled)') }}"
          - condition: !input auto_shading_start_condition
          - or: # When background state tracking is enabled, let choose 12 handle force-disabled triggers
              - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - "{{ not is_auto_recover_enabled }}"
          - or: # Use centralized force check
              - "{{ is_auto_recover_enabled }}"
              - "{{ can_move_shade }}"  # Simplified from is_cover_movement_blocked.shading
          - or: # Check the helper status or the target status
              - "{{ not state_is_shaded }}"
              - "{{ not (state_current == 'vpart' or state_current == 'vfull') }}"
          - or: # Try to avoid starting the shading several times TODO / FIXME?
              - "{{ not is_cover_tilt_enabled_and_possible and not in_shading_position }}"
              - "{{ is_cover_tilt_enabled_and_possible }}"
          - "{{ not (state_current == 'manual' and override_flags.shading) }}" # Override check
          - or: # Only once a day?
              - "{{ not prevent_flags.shading_multiple_times }}"
              - "{{ prevent_flags.shading_multiple_times and ((now().day != ((helper_json.ts.shade if helper_json.v == 6 else helper_json.shading.t | default(0)) | timestamp_custom('%-d') | int)) or ((helper_json.ts.man if helper_json.v == 6 else helper_json.manual.t | default(0)) <= (helper_json.ts.shade if helper_json.v == 6 else helper_json.shading.t | default(0)))) }}"
              - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}" # Execution must not be stopped if there is a shading pending in the helper beforehand.

        sequence:
          - if:
              - or:
                  - and: # Independent temperature-based shading
                      - "{{ 'shading_temp_comparison_independent' in shading_config }}"
                      - "{{ shading_start_condition_states.forecast_temp_valid }}"
                  - "{{ shading_start_conditions_met }}" # Use flexible AND/OR logic
            then:
              - choose:
                  #####################################################################
                  # Shading start detected. Save next execution time and pending status
                  #####################################################################
                  - alias: "Shading detected. Save next execution time and pending status"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_pending)') }}"
                      - "{{ not state_pending_start }}" # Not if a pending is already active
                    sequence:
                      - variables:
                          local_waitingtime_start: "{{ shading_waitingtime_start | int }}"
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "shade"
                              target: "shade"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: "{{ (((ts_now + local_waitingtime_start) | round(0)) % 86400) | int }}"
                              end: 0
                      - *helper_update
                      - stop: "Shading Start Pending: Waiting"

                  ##################################################
                  # Consider lockout protection when shading starts
                  ##################################################
                  - alias: "Consider lockout protection when shading starts"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ state_pending_start }}" # Only when it comes back from pending status
                      - "{{ is_ventilation_enabled }}"
                      - or:
                          - and:
                              - "{{ contact_window_opened != [] }}"
                              - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                          - and:
                              - "{{ lockout_tilted_when_shading_starts }}"
                              - "{{ contact_window_tilted != [] }}"
                              - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                    sequence:
                      - variables:
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "vfull"
                              target: "open"
                              man: 0
                            ts:
                              vfull: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading Start skipped: Lockout enabled"

                  ###################################
                  # Start Shading
                  ###################################
                  - alias: "Start Shading"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ state_pending_start }}" # Only when it comes back from pending status
                      - or: # Position check: Skip if force active with background tracking (helper update only)
                          - "{{ is_forced and is_auto_recover_enabled }}"
                          - and:
                              - "{{ not is_cover_tilt_enabled_and_possible }}"
                              - "{{ position_comparisons.current_above_shading }}"
                          - and:
                              - "{{ is_cover_tilt_enabled_and_possible }}"
                              - "{{ position_comparisons.current_above_shading or current_position == shading_position }}"
                      - or: # Shading during daytime window
                          - "{{ is_shading_allowed_window }}"
                      - "{{ can_shade_with_resident }}"
                    sequence:
                      - delay:
                          seconds: "{{ range(drive_delay_fix | int(0), drive_delay_fix | int(0) + drive_delay_random | int(0) +1) | random }}"
                      - choose: []
                        default: !input auto_shading_start_action_before
                      - variables:
                          target_position: !input shading_position
                          target_tilt_position: "{{ shading_tilt_position | int }}"
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "shade"
                              target: "open"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - if: "{{ can_move_shade }}"
                        then:
                          - *cover_move_action
                          - *tilt_move_action
                          - choose: []
                            default: !input auto_shading_start_action
                      - if:
                          - "{{ is_auto_recover_enabled or can_move_shade }}"
                        then:
                          - *helper_update
                      - stop: "Shading Start executed"

                  ####################################
                  # Save shading state for the future
                  ####################################
                  - alias: "Save shading state for the future"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ state_pending_start }}" # Only when it comes back from pending status
                      - "{{ state_current == 'close' }}" # At this point, the times for shading are not taken into account so that the correct value is available when the cover is opened.
                      - "{{ not is_forced }}" # Skip if force active - let "Start Shading" handle background state
                    sequence:
                      - variables:
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              # current: "none"
                              # target: "none"
                              target: "shade"
                              man: 0
                            ts:
                            pending:
                              start: 0
                              end: 0
                      - if:
                          - "{{ not is_forced }}"
                        then:
                          - *tilt_move_action
                      - *helper_update
                      - stop: "Shading Start skipped: State saved"

            else: # Shading conditions were no longer met or not met again.
              - choose:
                  #####################################################################
                  # Shading start conditions not met - check if we should continue
                  #####################################################################
                  - alias: "Shading start conditions not met - check if we should continue"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ state_pending_start }}"
                      - "{{ shading_start_max_duration > 0 }}"
                      - or: # Continue only within time window AND before timeout
                          - "{{ is_shading_allowed_window }}"
                      - "{{ (as_timestamp(now()) - helper_json.shading.t) <= shading_start_max_duration }}"
                    sequence:
                      - variables:
                          local_waitingtime_start: "{{ shading_waitingtime_start | int }}"
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "shade"
                              target: "shade"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: "{{ (((ts_now + local_waitingtime_start) | round(0)) % 86400) | int }}"
                              end: 0
                      - *helper_update
                      - stop: "Shading Start Pending: Continue waiting"

                  ######################################################################
                  # Shading start / Stop retry (timeout OR outside time window OR disabled)
                  ######################################################################
                  - alias: "Shading start / Stop retry"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_start_execution)') }}"
                      - "{{ state_pending_start }}"
                    sequence:
                      - variables:
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "none"
                              target: "none"
                              man: 0
                            ts:
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading Start aborted: Timeout or invalid"

      ############################################################
      # BRANCH (3): SHADING Tilt
      ############################################################

      - alias: "Check for shading tilt"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_tilt)') }}"
          - and:
              - "{{ state_is_shaded }}"
              - "{{ not state_pending_start }}"
          - "{{ is_cover_tilt_enabled_and_possible }}"
          - condition: !input auto_shading_tilt_condition
          - "{{ can_move_shade }}" 
          - "{{ not (state_current == 'vpart' or state_current == 'vfull') }}"
          - "{{ not (state_current == 'manual' and override_flags.shading) }}" # Override check
        sequence:
          - variables:
              target_tilt_position: "{{ shading_tilt_position | int }}"
              tilt_first: "{{ is_cover_tilt_reposition_enabled | bool }}" # tilt the cover to close position before
              update_values:
                t: "{{ as_timestamp(now()) | round(0) }}"
          - *tilt_move_action
          - *helper_update
          - stop: "Shading Tilt executed"

      ############################################################
      # BRANCH (4): SHADING END
      #   Source: Shading
      #   Target: Open, Lockout, Ventilation
      ############################################################

      - alias: "Check for shading end"
        conditions:
          - "{{ is_shading_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id | regex_match('^(t_shading_end)') }}"
          - condition: !input auto_shading_end_condition
          - or:
              - "{{ is_auto_recover_enabled }}"
              - "{{ not is_forced }}" # All force functions must now be disabled
          - or:
              - "{{ is_shading_allowed_window }}"
          - "{{ not (state_current == 'manual' and override_flags.shading) }}" # Override check
          - "{{ not state_current == 'close' }}"
          - or:
              - "{{ state_is_shaded }}"
              - "{{ in_shading_position }}" # Be careful if the tolerance value is too high!
          - or: # Optional: Continue if cover is not already closed
              - "{{ not prevent_flags.shading_end_if_closed }}"
              - "{{ prevent_flags.shading_end_if_closed and not in_close_position}}"
          - "{{ can_shade_with_resident }}"
        sequence:
          - if:
              - "{{ shading_end_conditions_met }}" # Use flexible AND/OR logic for END
            then:
              - choose:
                  #####################################################################
                  # Shading end detected. Save next execution time and pending status
                  #####################################################################
                  - alias: "Shading end detected. Save next execution time and pending status"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_pending)') }}"
                      - "{{ not state_pending_end }}"
                    sequence:
                      - variables:
                          local_waitingtime_end: >
                            {% set local_waitingtime_end = shading_waitingtime_end | int %}
                            {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool and trigger.id == 't_shading_end_pending_5' %}
                            
                            {% set local_waitingtime_end = 20 %}
                            {% endif %}
                            {{ local_waitingtime_end }}
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "shade"
                              target: "shade"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading End Pending: Waiting"

                  ######################################
                  # Only tilt open after shading ends
                  ######################################
                  - alias: "Only tilt open after shading ends"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                      - "{{ is_cover_tilt_enabled_and_possible }}"
                      - "{{ prevent_flags.opening_after_shading_end}}"
                    sequence:
                      - variables:
                          target_tilt_position: 50 # Moving the cover to open tilt position
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "none"
                              target: "none"
                              man: 0
                            ts:
                            pending:
                              start: 0
                              end: 0
                      - if:
                          - "{{ not is_forced }}"
                        then:
                          - *tilt_move_action
                      - *helper_update
                      - stop: "Shading End: Tilt executed"

                  ######################################
                  # Lockout protection when shading ends
                  ######################################
                  - alias: "Lockout protection when shading ends"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                      - "{{ is_ventilation_enabled }}"
                      - "{{ position_comparisons.current_below_ventilate }}"
                      - or:
                          - and:
                              - "{{ contact_window_opened != [] }}"
                              - "{{ states(contact_window_opened) in ['true', 'on'] }}"
                          - and:
                              - "{{ contact_window_tilted != [] }}"
                              - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                              - "{{ lockout_tilted_when_shading_ends }}"
                    sequence:
                      - variables:
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "vfull"
                              target: "open"
                              man: 0
                            ts:
                              vfull: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading End skipped: Lockout enabled"

                  ################################
                  # Ventilation after shading ends
                  ################################
                  - alias: "Ventilation after shading ends"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                      - "{{ is_ventilation_enabled }}"
                      - "{{ ventilation_flags.after_shading_end }}"
                      - "{{ contact_window_tilted != [] }}"
                      - "{{ states(contact_window_tilted) in ['true', 'on'] }}"
                      - "{{ not lockout_tilted_when_closing }}"
                      - or:
                          - "{{ contact_window_opened == [] }}"
                          - "{{ states(contact_window_opened) in ['false', 'off'] }}"
                      - or:
                          - "{{ position_comparisons.current_below_ventilate }}"
                          - "{{ ventilation_flags.if_lower_enabled and position_comparisons.current_above_ventilate or current_position == ventilate_position }}"
                    sequence:
                      - delay: # TODO: I can no longer recognize the original trigger here. That might be a bad idea here.
                          seconds: >
                            {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool %}
                              {{ range(0, 2) | random }}
                            {% else %}
                              {{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}
                            {% endif %}
                      - choose: []
                        default: !input auto_ventilate_action_before
                      - variables:
                          target_position: !input ventilate_position
                          target_tilt_position: !input ventilate_tilt_position
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "vpart"
                              target: "open"
                              man: 0
                            ts:
                              vpart: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - if: "{{ not is_forced }}"
                        then:
                          - *cover_move_action
                          - *tilt_move_action
                          - choose: []
                            default: !input auto_ventilate_action
                      - if:
                          - "{{ is_auto_recover_enabled or is_forced }}"
                        then:
                          - *helper_update
                      - stop: "Shading End: Ventilation activated"

                  ########################################################
                  # Move cover after shading end - conditions still valid
                  ########################################################
                  - alias: "Move cover after shading end - conditions still valid"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                      - or:
                          - "{{ is_auto_recover_enabled }}"
                          - or:
                              - "{{ current_sun_azimuth > shading_azimuth_end }}"
                              - "{{ current_sun_elevation > shading_elevation_max }}"
                              - "{{ current_sun_elevation < shading_elevation_min }}"
                              - "{{ shading_brightness_sensor != [] and states(shading_brightness_sensor) | float(default=999999) < (shading_sun_brightness_end - shading_sun_brightness_hysteresis) }}"
                              - "{{ shading_temperatur_sensor1 != [] and states(shading_temperatur_sensor1) | float(default=999) < (shading_min_temperatur1 - shading_temperature_hysteresis1) }}"
                              - "{{ shading_temperatur_sensor2 != [] and states(shading_temperatur_sensor2) | float(default=999) < (shading_min_temperatur2 - shading_temperature_hysteresis2) }}"
                              - "{{ shading_end_condition_states.forecast_temp_invalid }}" # Checks during shading end execution whether conditions are still valid
                    sequence:
                      - delay: # TODO: I can no longer recognize the original trigger here. That might be a bad idea here.
                          seconds: >
                            {% if (is_shading_end_immediate_by_sun_position | default(false)) | bool %}
                              {{ range(0, 2) | random }}
                            {% else %}
                              {{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}
                            {% endif %}

                      - choose: []
                        default: !input auto_shading_end_action_before

                      - if:
                          - "{{ not prevent_flags.opening_after_shading_end}}"
                        then:
                          - variables:
                              target_position: "{{ open_position }}"
                              target_tilt_position: "{{ open_tilt_position | int }}"
                              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                              update_values:
                                state:
                                  current: "open"
                                  target: "open"
                                  man: 0
                                ts:
                                  open: "{{ (ts_now % 86400) | int }}"
                                pending:
                                  start: 0
                                  end: 0
                          - if: "{{ not is_forced }}"
                            then:
                              - *cover_move_action
                              - *tilt_move_action
                              - choose: []
                                default: !input auto_shading_end_action
                              - *helper_update
                            else:
                              - variables:
                                  update_values:
                                    state:
                                      current: "none"
                                      target: "none"
                                      man: 0
                                    ts:
                                    pending:
                                      start: 0
                                      end: 0
                              - *helper_update
                      - stop: "Shading End (Opening after shading) executed"

                  #####################################################################
                  # Shading end conditions not met - check if we should continue
                  #####################################################################
                  - alias: "Shading end conditions not met - check if we should continue"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                      - "{{ shading_end_max_duration > 0 }}"
                      - or: # Continue only within time window AND before timeout
                          - "{{ is_shading_allowed_window }}"
                      - "{{ (as_timestamp(now()) - helper_json.shading.t) <= shading_end_max_duration }}"
                    sequence:
                      - variables:
                          local_waitingtime_end: "{{ shading_waitingtime_end | int }}"
                          ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
                          update_values:
                            state:
                              current: "shade"
                              target: "shade"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading End Pending: Continue waiting"

                  ######################################################################
                  # Shading end / Stop retry (timeout OR outside time window OR disabled)
                  ######################################################################
                  - alias: "Shading end / Stop retry"
                    conditions:
                      - "{{ trigger.id | regex_match('^(t_shading_end_execution)') }}"
                      - "{{ state_pending_end }}"
                    sequence:
                      - variables:
                          update_values:
                            state:
                              current: "shade"
                              target: "shade"
                              man: 0
                            ts:
                              shade: "{{ (ts_now % 86400) | int }}"
                            pending:
                              start: 0
                              end: 0
                      - *helper_update
                      - stop: "Shading End aborted: Timeout or invalid"

      ############################################################
      # BRANCH (5): CONTACT SENSOR HANDLING
      #   Handles all contact sensor state changes:
      #   - Window opened ‚Üí Full ventilation (lockout protection)
      #   - Window tilted ‚Üí Partial ventilation
      #   - Window closed ‚Üí Return to previous state (open/close/shading)
      ############################################################

      - alias: "Contact sensor state changed"
        conditions:
          - "{{ is_ventilation_enabled }}"
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id in ['t_contact_tilted_changed', 't_contact_opened_changed'] or trigger.id.startswith('t_force_disabled') }}"
          - "{{ trigger.from_state.state not in invalid_states }}"
          - "{{ trigger.to_state.state not in invalid_states }}"
          - or: # When background state tracking is enabled, let ANCHOR 12 handle force-disabled triggers
              - "{{ not trigger.id.startswith('t_force_disabled') }}"
              - "{{ not is_auto_recover_enabled }}"
          - "{{ can_ventilate_with_resident }}"
        sequence:
          # Wait for all sensor changes to settle
          - delay:
              seconds: !input contact_delay_status

          # Re-evaluate BOTH sensors with current values after delay
          - variables:
              contact_opened_now: "{{ contact_window_opened != [] and states(contact_window_opened) in ['true', 'on'] }}"
              contact_tilted_now: "{{ contact_window_tilted != [] and states(contact_window_tilted) in ['true', 'on'] }}"

          - choose:
              ###################################
              # VENTILATION START: Window fully opened
              # Opens cover completely for lockout protection
              ###################################
              - alias: "Window opened - Full ventilation (lockout)"
                conditions:
                  - "{{ contact_opened_now }}"
                  - "{{ not in_open_position }}"
                  - or: # Force functions allow ventilation start
                      - "{{ is_auto_recover_enabled }}"
                      - "{{ can_move_ventilate }}"
                  # User-defined condition for starting ventilation
                  - condition: !input auto_ventilate_condition
                sequence:
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: !input open_tilt_position
                      ts_now: "{{ as_timestamp(now()) | round(0) }}"
                      update_values:
                        state:
                          current: "vfull"
                          target: "vfull"
                          man: 0
                        ts:
                          vfull: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - if: "{{ can_move_open }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                  - if:
                      - "{{ is_auto_recover_enabled or can_move_open }}"
                    then:
                      - *helper_update
                  - stop: "Ventilation Start (Full) executed"

              ###################################
              # VENTILATION START: Window tilted
              # Moves cover to ventilation position
              ###################################
              - alias: "Window tilted - Partial ventilation"
                conditions:
                  - "{{ contact_tilted_now }}"
                  - "{{ not contact_opened_now }}"
                  - or: # Force functions allow ventilation start 
                      - "{{ is_auto_recover_enabled }}"
                      - "{{ can_move_ventilate }}"
                  # User-defined condition for starting ventilation
                  - condition: !input auto_ventilate_condition
                  # Position check: Only move if cover is below ventilation position (or option enabled)
                  - or:
                      # Standard: Cover is below ventilate position
                      - "{{ position_comparisons.current_below_ventilate }}"
                      # Tilt-enabled covers at or near ventilate position
                      - and:
                          - "{{ is_cover_tilt_enabled_and_possible }}"
                          - "{{ position_comparisons.current_below_ventilate or current_position == ventilate_position }}"
                          - "{{ current_tilt_position <= ventilate_tilt_position }}"
                      # User option: Allow from higher positions
                      - "{{ ventilation_flags.if_lower_enabled and (position_comparisons.current_above_ventilate or current_position == ventilate_position) }}"
                      # Transition from full to partial ventilation (handle: open ‚Üí tilted)
                      - and:
                          - "{{ state_current == 'vfull' }}"
                          - "{{ position_comparisons.current_above_ventilate }}"

                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                      ts_now: "{{ as_timestamp(now()) | round(0) }}"
                      update_values:
                        state:
                          current: "vpart"
                          target: "vpart"
                          man: 0
                        ts:
                          vpart: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - if: "{{ can_move_ventilate }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                      - choose: []
                        default: !input auto_ventilate_action
                  - if:
                      - "{{ is_auto_recover_enabled or can_move_ventilate }}"
                    then:
                      - *helper_update
                  - stop: "Ventilation Start (Partial) executed"

              ###################################
              # VENTILATION END: Window closed - Return to SHADING
              ###################################
              - alias: "Window closed - Return to shading"
                conditions:
                  - "{{ not contact_opened_now and not contact_tilted_now }}"
                  - "{{ state_is_shaded }}"
                  - or: # Was ventilating before
                      - "{{ state_current == 'vpart' }}"
                      - "{{ state_current == 'vfull' }}"
                      - "{{ in_ventilate_position }}"
                      - "{{ in_open_position }}"
                  - or: # All force functions must be disabled OR background tracking is active
                      - "{{ not is_forced }}"
                      - "{{ is_auto_recover_enabled }}"
                  - "{{ not (state_current == 'manual' and override_flags.ventilation) }}" # Skip if manual override for ventilation is active
                  - condition: !input auto_ventilate_end_condition # User-defined condition for ending ventilation
                sequence:
                  - if: # Optional delay if enabled
                      - "{{ ventilation_flags.delay_enabled }}"
                    then:
                      - delay:
                          seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - choose: []
                    default: !input auto_shading_start_action_before
                  - variables:
                      target_position: !input shading_position
                      target_tilt_position: "{{ shading_tilt_position | int }}"
                      ts_now: "{{ as_timestamp(now()) | round(0) }}"
                      update_values:
                        state:
                          current: "shade"
                          target: "open"
                          man: 0
                        ts:
                          shade: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_shading_start_action
                  - stop: "Ventilation End: Return to Shading executed"

              ###################################
              # VENTILATION END: Window closed - Return to OPEN
              ###################################
              - alias: "Window closed - Return to open position"
                conditions:
                  - "{{ not contact_opened_now and not contact_tilted_now }}"
                  - "{{ state_current == 'open' }}"
                  - "{{ not state_is_shaded }}"
                  - or: # Was ventilating before
                      - "{{ state_current == 'vpart' }}"
                      - "{{ state_current == 'vfull' }}"
                      - "{{ in_ventilate_position }}"
                      - "{{ in_open_position }}"
                  - or: # All force functions must be disabled OR background tracking is active
                      - "{{ not is_forced }}"
                      - "{{ is_auto_recover_enabled }}"
                  - "{{ not (state_current == 'manual' and override_flags.ventilation) }}" # Skip if manual override for ventilation is active
                  - condition: !input auto_ventilate_end_condition # User-defined condition for ending ventilation
                sequence:
                  - if: # Optional delay if enabled
                      - "{{ ventilation_flags.delay_enabled }}"
                    then:
                      - delay:
                          seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - choose: []
                    default: !input auto_up_action_before
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: !input open_tilt_position
                      ts_now: "{{ as_timestamp(now()) | round(0) }}"
                      update_values:
                        state:
                          current: "open"
                          target: "open"
                          man: 0
                        ts:
                          open: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - if:
                      - "{{ not prevent_flags.opening_after_ventilation_end }}"
                    then:
                      - *cover_move_action
                      - *tilt_move_action
                  - choose: []
                    default: !input auto_up_action
                  - stop: "Ventilation End: Return to Open executed"

              ###################################
              # VENTILATION END: Window closed - Return to CLOSE
              ###################################
              - alias: "Window closed - Return to close position"
                conditions:
                  - "{{ not contact_opened_now and not contact_tilted_now }}"
                  - "{{ state_current == 'close' }}"
                  - or: # Was ventilating before
                      - "{{ state_current == 'vpart' }}"
                      - "{{ state_current == 'vfull' }}"
                      - "{{ in_ventilate_position }}"
                      - "{{ in_open_position }}"
                  - or: # All force functions must be disabled OR background tracking is active
                      - "{{ not is_forced }}"
                      - "{{ is_auto_recover_enabled }}"
                  - "{{ not (state_current == 'manual' and override_flags.ventilation) }}" # Skip if manual override for ventilation is active
                  - condition: !input auto_ventilate_end_condition # User-defined condition for ending ventilation
                sequence:
                  - if: # Optional delay if enabled
                      - "{{ ventilation_flags.delay_enabled }}"
                    then:
                      - delay:
                          seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
                  - choose: []
                    default: !input auto_down_action_before
                  - variables:
                      target_position: !input close_position
                      target_tilt_position: !input close_tilt_position
                      ts_now: "{{ as_timestamp(now()) | round(0) }}"
                      update_values:
                        state:
                          current: "close"
                          target: "close"
                          man: 0
                        ts:
                          close: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *cover_move_action
                  - *tilt_move_action
                  - *helper_update
                  - choose: []
                    default: !input auto_down_action
                  - stop: "Ventilation End: Return to Close executed"

      ############################################################
      # BRANCH (6): FORCE OPEN
      ############################################################

      - alias: "Forced opening of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_enabled_open' }}"
          - "{{ can_move_open }}"
        sequence:
          - choose: []
            default: !input auto_up_action_before
          - variables:
              target_position: !input open_position
              target_tilt_position: !input open_tilt_position
              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
              update_values:
                state:
                  current: "open"
                  man: 0
                  force: "open"  
                ts:
                  open: "{{ (ts_now % 86400) | int }}"
                pending:
                  start: 0
                  end: 0
                t: "{{ ts_now }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_up_action
          - stop: "Force Open executed"

      ############################################################
      # BRANCH (7): FORCE CLOSE
      ############################################################

      - alias: "Forced closing of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_enabled_close' }}"
          - "{{ can_move_close }}"
        sequence:
          - choose: []
            default: !input auto_down_action_before
          - variables:
              target_position: !input close_position
              target_tilt_position: !input close_tilt_position
              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
              update_values:
                state:
                  current: "close"
                  man: 0
                  force: "close"  
                ts:
                  close: "{{ (ts_now % 86400) | int }}"
                pending:
                  start: 0
                  end: 0
                t: "{{ ts_now }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_down_action
          - stop: "Force Close executed"

      ############################################################
      # BRANCH (8): FORCE VENTILATION
      ############################################################

      - alias: "Forced ventilation of the cover"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_enabled_ventilate' }}"
          - "{{ can_move_ventilate }}" 
        sequence:
          - choose: []
            default: !input auto_ventilate_action_before
          - variables:
              target_position: !input ventilate_position
              target_tilt_position: !input ventilate_tilt_position
              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
              update_values:
                state:
                  current: "vpart"
                  man: 0
                  force: "vpart" 
                ts:
                  vpart: "{{ (ts_now % 86400) | int }}"
                pending:
                  start: 0
                  end: 0
                t: "{{ ts_now }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_ventilate_action
          - stop: "Force Ventilation executed"

      ############################################################
      # BRANCH (9): FORCE SHADING START
      ############################################################

      - alias: "Forced activating of the sun shading"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_force_enabled_shading' }}"
          - "{{ can_move_shade }}" 
        sequence:
          - choose: []
            default: !input auto_shading_start_action_before
          - variables:
              target_position: !input shading_position
              target_tilt_position: "{{ shading_tilt_position |int }}"
              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
              update_values:
                state:
                  current: "shade"
                  man: 0
                  force: "shade" 
                ts:
                  shade: "{{ (ts_now % 86400) | int }}"
                pending:
                  start: 0
                  end: 0
                t: "{{ ts_now }}"
          - *cover_move_action
          - *tilt_move_action
          - *helper_update
          - choose: []
            default: !input auto_shading_start_action
          - stop: "Force Shading executed"

      ############################################################
      # BRANCH (10): MANUAL
      ############################################################

      - alias: "Checking for manual position changes"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id in ['t_manual_position', 't_manual_tilt'] }}"
          - "{{ this.attributes.current | int(99) == 0 }}"
          - "{{ 'cover_helper_enabled' in cover_status_options }}"
          - "{{ cover_status_helper != [] }}"
          - "{{ as_timestamp(now()) > helper_json.t + drive_time | default(90) + 60 }}"
          - "{{ trigger.from_state is not none and trigger.to_state is not none }}"
          - "{{ trigger.from_state.state not in invalid_states }}"
          - "{{ trigger.to_state.state not in invalid_states }}"
          - or:
              # Position change via custom sensor (state-based)
              - and:
                  - "{{ trigger.id == 't_manual_position' }}"
                  - "{{ position_source == 'custom_sensor' }}"
                  - "{{ trigger.from_state.state not in invalid_states }}"
                  - "{{ trigger.to_state.state not in invalid_states }}"
                  - "{{ is_number(trigger.from_state.state) }}"
                  - "{{ is_number(trigger.to_state.state) }}"
                  - "{{ trigger.from_state.state != trigger.to_state.state }}"

              # Position change via current_position attribute
              - and:
                  - "{{ trigger.id == 't_manual_position' }}"
                  - "{{ position_source == 'current_position_attr' }}"
                  - "{{ trigger.attribute == 'current_position' }}"
                  - "{{ trigger.from_state.attributes.current_position not in invalid_states }}"
                  - "{{ trigger.to_state.attributes.current_position not in invalid_states }}"
                  - "{{ is_number(trigger.from_state.attributes.current_position) }}"
                  - "{{ is_number(trigger.to_state.attributes.current_position) }}"
                  - "{{ trigger.from_state.attributes.current_position != trigger.to_state.attributes.current_position }}"

              # Position change via position attribute
              - and:
                  - "{{ trigger.id == 't_manual_position' }}"
                  - "{{ position_source == 'position_attr' }}"
                  - "{{ trigger.attribute == 'position' }}"
                  - "{{ trigger.from_state.attributes.position not in invalid_states }}"
                  - "{{ trigger.to_state.attributes.position not in invalid_states }}"
                  - "{{ is_number(trigger.from_state.attributes.position) }}"
                  - "{{ is_number(trigger.to_state.attributes.position) }}"
                  - "{{ trigger.from_state.attributes.position != trigger.to_state.attributes.position }}"

              # Tilt change detection
              - and:
                  - "{{ trigger.id == 't_manual_tilt' }}"
                  - "{{ trigger.from_state.attributes.current_tilt_position not in invalid_states }}"
                  - "{{ trigger.to_state.attributes.current_tilt_position not in invalid_states }}"
                  - "{{ is_number(trigger.from_state.attributes.current_tilt_position | default(none)) }}"
                  - "{{ is_number(trigger.to_state.attributes.current_tilt_position | default(none)) }}"
                  - "{{ trigger.from_state.attributes.current_tilt_position != trigger.to_state.attributes.current_tilt_position }}"

        sequence:
          - variables:
              ts_now: "{{ as_timestamp(now()) | round(0) }}"
          - choose:
              - conditions: # Manually tilted
                  - "{{ trigger.id == 't_manual_tilt' }}"
                sequence:
                  - variables:
                      update_values:
                        state: { man: 1 }
                        ts: { man: "{{ (ts_now % 86400) | int }}" }
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual Tilt detected"

              - conditions: # Manually opened
                  - "{{ is_up_enabled }}"
                  - or:
                      - "{{ in_open_position }}"
                      - "{{ position_comparisons.current_above_open or current_position == open_position }}"
                      - "{{ (is_awning and current_position == 0) or (not is_awning and current_position == 100) }}"
                sequence:
                  - variables:
                      update_values:
                        state:
                          current: "open"
                          target: "open"
                          man: 1
                        ts:
                          open: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual Open detected"

              - conditions: # Manually ventilated
                  - "{{ is_ventilation_enabled }}"
                  - "{{ in_ventilate_position }}"
                  - "{{ not in_open_position }}" # If ventilate_position and open_position are too close together, the ventilation-status should not be assigned.
                sequence:
                  - variables:
                      update_values:
                        state:
                          current: "vpart"
                          target: "vpart"
                          man: 1
                        ts:
                          vpart: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual Ventilation detected"

              - conditions: # Manually shaded
                  - "{{ is_shading_enabled }}"
                  - "{{ in_shading_position }}"
                sequence:
                  - variables:
                      update_values:
                        state:
                          current: "shade"
                          target: "shade"
                          man: 1
                        ts:
                          shade: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual Shading detected"

              - conditions: # Manually closed
                  - "{{ is_down_enabled }}"
                  - "{{ not in_shading_position }}"
                  - or:
                      - "{{ in_close_position }}"
                      - "{{ position_comparisons.current_below_close or current_position == close_position }}"
                      - "{{ (is_awning and current_position == 100) or (not is_awning and current_position == 0) }}"
                sequence:
                  - variables:
                      update_values:
                        state:
                          current: "close"
                          target: "close"
                          man: 1
                        ts:
                          close: "{{ (ts_now % 86400) | int }}"
                        pending:
                          start: 0
                          end: 0
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual Close detected"

              - conditions: # Defined positions cannot be assigned
                  - not:
                      - "{{ is_up_enabled and in_open_position }}"
                      - "{{ is_down_enabled and in_close_position }}"
                      - "{{ is_ventilation_enabled and in_ventilate_position }}"
                      - "{{ is_shading_enabled and in_shading_position }}"
                sequence:
                  - variables:
                      update_values:
                        state: { man: 1 }
                        ts: { man: "{{ (ts_now % 86400) | int }}" }
                  - *helper_update
                  - choose: []
                    default: !input auto_manual_action
                  - stop: "Manual position (unknown) detected"

      ############################################################
      # BRANCH (11): RESET MANUAL DETECTION
      ############################################################

      - alias: "Reset manual detection"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ not is_reset_disabled }}"
          - "{{ trigger.id in ['t_reset_fixedtime', 't_reset_timeout'] }}"
        sequence:
          - variables:
              ts_now: "{{ as_timestamp(now()) | round(0) }}" # Note: ts_now must be evaluated at runtime after delays, not at blueprint load time
              update_values:
                state:
                  current: "none"
                  target: "none"
                  man: 0
                ts:
                pending:
                  start: 0
                  end: 0
          - *helper_update
          - choose: []
            default: !input auto_override_reset_action
          - stop: "Reset Manual Override executed"

      ############################################################
      # BRANCH (12): RETURN TO BACKGROUND STATE AFTER FORCE DISABLE
      ############################################################

      - alias: "Return to background position after force disable"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id.startswith('t_force_disabled') }}"
          - "{{ is_auto_recover_enabled }}"
          - "{{ not is_forced }}" # All force functions must now be disabled
        sequence:
          # First: Reset force state in helper
          - if:
              - "{{ helper_json.v == 6 }}"
            then:
              - variables:
                  update_values:
                    state: { force: "none" } 
              - *helper_update
          - delay:
              seconds: "{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0) +1) | random }}"
          - variables:
              # Read current target state from helper
              background_is_open: "{{ state_current == 'open' }}"
              background_is_closed: "{{ state_current == 'close' }}"
              background_is_shaded: "{{ state_is_shaded }}"
              background_is_vpart: "{{ state_current == 'vpart' }}"
              background_is_vfull: "{{ state_current == 'vfull' }}"
          - choose:
              # Return to CLOSE position
              - conditions:
                  - "{{ background_is_closed }}"
                  - "{{ not background_is_vpart }}"
                  - "{{ not background_is_vfull }}"
                sequence:
                  - choose: []
                    default: !input auto_down_action_before
                  - variables:
                      target_position: !input close_position
                      target_tilt_position: "{{ close_tilt_position | int }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - choose: []
                    default: !input auto_down_action
                  - stop: "Return to Close executed"

              # Return to SHADING position
              - conditions:
                  - "{{ background_is_shaded }}"
                sequence:
                  - choose: []
                    default: !input auto_shading_start_action_before
                  - variables:
                      target_position: !input shading_position
                      target_tilt_position: "{{ shading_tilt_position | int }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - choose: []
                    default: !input auto_shading_start_action
                  - stop: "Return to Shading executed"

              # Return to VENTILATION position (partial)
              - conditions:
                  - "{{ background_is_vpart }}"
                sequence:
                  - choose: []
                    default: !input auto_ventilate_action_before
                  - variables:
                      target_position: !input ventilate_position
                      target_tilt_position: !input ventilate_tilt_position
                  - *cover_move_action
                  - *tilt_move_action
                  - choose: []
                    default: !input auto_ventilate_action
                  - stop: "Return to Ventilation executed"

              # Return to OPEN position
              - conditions:
                  - "{{ background_is_open }}"
                sequence:
                  - choose: []
                    default: !input auto_up_action_before
                  - variables:
                      target_position: !input open_position
                      target_tilt_position: "{{ open_tilt_position | int }}"
                  - *cover_move_action
                  - *tilt_move_action
                  - choose: []
                    default: !input auto_up_action
                  - stop: "Return to Open executed"
            default: []

      ############################################################
      # BRANCH (13): UPDATE RESIDENT STATUS IN HELPER
      ############################################################
      # This branch updates state_resident in the helper whenever
      # the resident_sensor changes. This ensures state_resident
      # stays synchronized with the actual sensor state.

      - alias: "Update resident status in helper"
        conditions:
          - "{{ trigger.id == 't_resident_update' }}"
        sequence:
          - variables:
              update_values:
                state:
                  resident: "{{ 1 if trigger.to_state.state in ['on', 'true'] else 0 }}"
          - *helper_update
          - stop: "Resident status updated"

      ############################################################
      # BRANCH (14): RESET SHADING STATUS AT MIDNIGHT
      ############################################################

      - alias: "Reset shading status that is no longer required - but still saved"
        conditions:
          - "{{ trigger.id is defined }}"
          - "{{ trigger.id == 't_shading_reset' }}"
          - or:
              - "{{ state_is_shaded }}"
              - "{{ state_pending_start }}"  # Also clear pending status
              - "{{ state_pending_end }}"    # Also clear end‚Äëpending status
        sequence:
          - delay:
              seconds: "{{ (range(0, 60) | random | int) }}"
          - variables:
              update_values:
                state:
                  current: "none"
                  target: "none"
                  man: 0
                ts:
                pending:
                  start: 0
                  end: 0
          - *helper_update
          - stop: "Midnight Reset executed"

    ############################################################
    # DEFAULT BRANCH - CONFIG CHECK
    ############################################################

    default:
      - if:
        - "{{ check_config }}"
        then:
          - repeat:
              for_each:
                # ========== RUNTIME CONFIGURATION CHECKS ==========
                # Only runtime checks remain here. Static configuration checks have been moved
                # to the online validator: https://hvorragend.github.io/ha-blueprints/validator/

                # ========== ENTITY ATTRIBUTE & STATE CHECKS ==========

                - condition: "{{ state_attr(blind, 'current_position') is none }}"
                  message: "Cover entity is missing the required 'current_position' attribute"
                - condition: "{{ state_attr(default_sun_sensor, 'elevation') is none }}"
                  message: "Sun sensor is missing the required 'elevation' attribute"
                - condition: "{{ state_attr(default_sun_sensor, 'azimuth') is none }}"
                  message: "Sun sensor is missing the required 'azimuth' attribute"
                - condition: "{{ resident_sensor != [] and states(resident_sensor) not in ['false', 'off', 'true', 'on'] }}"
                  message: "resident_sensor has invalid state. Must be: on, off, true, or false"
                - condition: "{{ is_brightness_enabled and (default_brightness_sensor == [] or not is_number(states(default_brightness_sensor))) }}"
                  message: "Brightness sensor not configured or has non-numeric state"

                # ========== SUN ELEVATION MODE CHECKS ==========
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'dynamic' and
                      sun_elevation_up_sensor == []
                    }}
                  message: "Sun Elevation Mode is 'dynamic' but Sun Elevation Up Sensor is not configured. Configure sensor or change mode to 'fixed'"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'dynamic' and
                      sun_elevation_down_sensor == []
                    }}
                  message: "Sun Elevation Mode is 'dynamic' but Sun Elevation Down Sensor is not configured. Configure sensor or change mode to 'fixed'"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'dynamic' and
                      sun_elevation_up_sensor != [] and
                      not is_number(states(sun_elevation_up_sensor))
                    }}
                  message: "Sun Elevation Up Sensor has non-numeric state. Sensor must provide numeric values in dynamic mode"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'dynamic' and
                      sun_elevation_down_sensor != [] and
                      not is_number(states(sun_elevation_down_sensor))
                    }}
                  message: "Sun Elevation Down Sensor has non-numeric state. Sensor must provide numeric values in dynamic mode"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'hybrid' and
                      sun_elevation_up_sensor == []
                    }}
                  message: "Sun Elevation Mode is 'hybrid' but Sun Elevation Up Sensor is not configured. Configure sensor or change mode to 'fixed'"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'hybrid' and
                      sun_elevation_down_sensor == []
                    }}
                  message: "Sun Elevation Mode is 'hybrid' but Sun Elevation Down Sensor is not configured. Configure sensor or change mode to 'fixed'"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'hybrid' and
                      sun_elevation_up_sensor != [] and
                      not is_number(states(sun_elevation_up_sensor))
                    }}
                  message: "Sun Elevation Up Sensor has non-numeric state. Sensor must provide numeric values in hybrid mode"
                - condition: >-
                    {{
                      is_sun_elevation_enabled and
                      sun_elevation_mode == 'hybrid' and
                      sun_elevation_down_sensor != [] and
                      not is_number(states(sun_elevation_down_sensor))
                    }}
                  message: "Sun Elevation Down Sensor has non-numeric state. Sensor must provide numeric values in hybrid mode"

                # ========== TILT FEATURE CHECKS ==========
                - condition: "{{ is_cover_tilt_enabled and state_attr(blind, 'current_tilt_position') is none }}"
                  message: "Tilt position control enabled but cover does not support 'current_tilt_position' attribute. Disable tilt features or check cover integration"

                # ========== WORKDAY SENSOR CHECKS ==========
                - condition: >-
                    {{
                      workday_sensor_today not in [[], none] and
                      states(workday_sensor_today) not in ['on', 'off', 'unknown', 'unavailable']
                    }}
                  message: "Workday sensor today has invalid state. Expected: on or off"
                - condition: >-
                    {{
                      workday_sensor_tomorrow not in [[], none] and
                      states(workday_sensor_tomorrow) not in ['on', 'off', 'unknown', 'unavailable']
                    }}
                  message: "Workday sensor tomorrow has invalid state. Expected: on or off"

                # ========== FORCE ENTITY CHECKS ==========
                - condition: >-
                    {{
                      auto_up_force not in [[], none] and
                      states(auto_up_force) not in ['on', 'off', 'true', 'false', 'unknown', 'unavailable']
                    }}
                  message: "Force Open entity has invalid state. Must be binary: on/off"
                - condition: >-
                    {{
                      auto_down_force not in [[], none] and
                      states(auto_down_force) not in ['on', 'off', 'true', 'false', 'unknown', 'unavailable']
                    }}
                  message: "Force Close entity has invalid state. Must be binary: on/off"
                - condition: >-
                    {{
                      auto_ventilate_force not in [[], none] and
                      states(auto_ventilate_force) not in ['on', 'off', 'true', 'false', 'unknown', 'unavailable']
                    }}
                  message: "Force Ventilate entity has invalid state. Must be binary: on/off"
                - condition: >-
                    {{
                      auto_shading_start_force not in [[], none] and
                      states(auto_shading_start_force) not in ['on', 'off', 'true', 'false', 'unknown', 'unavailable']
                    }}
                  message: "Force Shading entity has invalid state. Must be binary: on/off"
                - condition: >-
                    {{
                      [
                        auto_up_force not in [[], none] and states(auto_up_force) in ['on', 'true'],
                        auto_down_force not in [[], none] and states(auto_down_force) in ['on', 'true'],
                        auto_ventilate_force not in [[], none] and states(auto_ventilate_force) in ['on', 'true'],
                        auto_shading_start_force not in [[], none] and states(auto_shading_start_force) in ['on', 'true']
                      ].count(true) > 1
                    }}
                  message: "CRITICAL: Multiple force entities are active. Only one force entity can be active at a time. Deactivate conflicting force entities"

                # ========== SUN SENSOR CHECKS ==========
                - condition: >-
                    {{
                      default_sun_sensor not in [[], none] and
                      states(default_sun_sensor) in ['unknown', 'unavailable']
                    }}
                  message: "Sun sensor is unavailable. Check sun integration is enabled"

                # ========== FORECAST CONFIGURATION CHECKS ==========
                - condition: "{{ forecast_source.use_weather and states(shading_forecast_sensor) in ['unknown', 'unavailable'] }}"
                  message: "Weather entity is unavailable. Check weather integration"
                - condition: "{{ forecast_source.use_sensor and states(shading_forecast_temp_sensor) in ['unknown', 'unavailable'] }}"
                  message: "Forecast temperature sensor is unavailable"
                - condition: "{{ forecast_source.use_sensor and not is_number(states(shading_forecast_temp_sensor)) }}"
                  message: "Forecast temperature sensor is non-numeric"

                # ========== DYNAMIC SUN ELEVATION SENSOR CHECKS ==========

                - condition: >-
                    {{
                      sun_elevation_up_sensor != [] and
                      states(sun_elevation_up_sensor) in ['unknown', 'unavailable']
                    }}
                  message: "Dynamic sun elevation up sensor is unavailable. Check sensor configuration"

                - condition: >-
                    {{
                      sun_elevation_up_sensor != [] and
                      states(sun_elevation_up_sensor) not in invalid_states and
                      not is_number(states(sun_elevation_up_sensor))
                    }}
                  message: "Dynamic sun elevation up sensor has non-numeric state"

                - condition: >-
                    {{
                      sun_elevation_up_sensor != [] and
                      is_number(states(sun_elevation_up_sensor)) and
                      (states(sun_elevation_up_sensor) | float < -90 or states(sun_elevation_up_sensor) | float > 90)
                    }}
                  message: "Dynamic sun elevation up sensor value is outside valid range (-90¬∞ to 90¬∞)"

                - condition: >-
                    {{
                      sun_elevation_down_sensor != [] and
                      states(sun_elevation_down_sensor) in ['unknown', 'unavailable']
                    }}
                  message: "Dynamic sun elevation down sensor is unavailable. Check sensor configuration"

                - condition: >-
                    {{
                      sun_elevation_down_sensor != [] and
                      states(sun_elevation_down_sensor) not in invalid_states and
                      not is_number(states(sun_elevation_down_sensor))
                    }}
                  message: "Dynamic sun elevation down sensor has non-numeric state"

                - condition: >-
                    {{
                      sun_elevation_down_sensor != [] and
                      is_number(states(sun_elevation_down_sensor)) and
                      (states(sun_elevation_down_sensor) | float < -90 or states(sun_elevation_down_sensor) | float > 90)
                    }}
                  message: "Dynamic sun elevation down sensor value is outside valid range (-90¬∞ to 90¬∞)"

                - condition: >-
                    {{
                      sun_elevation_up_sensor != [] and
                      sun_elevation_down_sensor != [] and
                      is_number(states(sun_elevation_up_sensor)) and
                      is_number(states(sun_elevation_down_sensor)) and
                      (states(sun_elevation_up_sensor) | float) <= (states(sun_elevation_down_sensor) | float)
                    }}
                  message: "Dynamic sun elevation up sensor should be higher than down sensor"

                - condition: >-
                    {{
                      sun_elevation_up_sensor != [] and
                      sun_elevation_down_sensor == [] and
                      sun_elevation_up <= sun_elevation_down
                    }}
                  message: "WARNING: Using dynamic sensor for UP but fixed value for DOWN. Thresholds may be inconsistent"

                - condition: >-
                    {{
                      sun_elevation_up_sensor == [] and
                      sun_elevation_down_sensor != [] and
                      sun_elevation_up <= sun_elevation_down
                    }}
                  message: "WARNING: Using dynamic sensor for DOWN but fixed value for UP. Thresholds may be inconsistent"

                # ========== CALENDAR CONFIGURATION CHECKS ==========

                - condition: >-
                    {{
                      is_calendar_enabled and
                      calendar_entity != [] and
                      states(calendar_entity) in ['unknown', 'unavailable']
                    }}
                  message: "Calendar entity is unavailable. Check calendar integration"

                - condition: >-
                    {{
                      is_calendar_enabled and
                      calendar_entity != [] and
                      state_attr(calendar_entity, 'message') is none
                    }}
                  message: "Calendar entity does not have 'message' attribute. Ensure it's a valid calendar entity"

                # Check for position source consistency
                - condition: >-
                    {{
                      position_source == 'position_attr' and
                      state_attr(blind, 'position') is none
                    }}
                  message: "Position source set to 'position' attribute but cover doesn't have this attribute"

                - condition: >-
                    {{
                      position_source == 'current_position_attr' and
                      state_attr(blind, 'current_position') is none
                    }}
                  message: "Position source set to 'current_position' attribute but cover doesn't have this attribute (try 'position' or custom sensor)"

                - condition: >-
                    {{
                      position_source == 'custom_sensor' and
                      (custom_position_sensor == [] or states(custom_position_sensor) in invalid_states)
                    }}
                  message: "Custom position sensor selected but not configured or unavailable"

                - condition: >-
                    {{
                      position_source == 'custom_sensor' and
                      custom_position_sensor != [] and
                      not is_number(states(custom_position_sensor))
                    }}
                  message: "Custom position sensor has non-numeric value"

              sequence:
                - if:
                    - "{{ repeat.item.condition }}"
                  then:
                    - action: system_log.write
                      data:
                        level: "{{ check_config_debuglevel }}"
                        message: "CCA Config issue: {{ repeat.item.message }} - {{ this.entity_id }}"
                        logger: "blueprints.hvorragend.cca"

      - stop: "No operational branch matched (Opening, Closing, Shading, etc. conditions not met for current trigger)"
