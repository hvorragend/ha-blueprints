<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>CCA Trace Analyzer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <script type="module">
        // Load yaml library (eemeli/yaml) which has full parseDocument support in browser
        import * as YAML from 'https://esm.sh/yaml@2.3.4';
        window.YAML = YAML;
        console.log("‚úÖ YAML Parser (eemeli/yaml) loaded from CDN");
        console.log("‚úÖ parseDocument available:", typeof YAML.parseDocument);
        console.log("‚úÖ Available exports:", Object.keys(YAML));
    </script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --bg-card: #16161f;
            --accent-blue: #3b82f6;
            --accent-cyan: #06b6d4;
            --accent-green: #10b981;
            --accent-yellow: #f59e0b;
            --accent-red: #ef4444;
            --accent-purple: #8b5cf6;
            --accent-orange: #f97316;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #2a2a3a;
            --border-highlight: #3b3b4f;
            --shadow-glow: rgba(59, 130, 246, 0.15);
            --font-sans: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
        }

        .logo {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 20px var(--shadow-glow);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text-primary), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-top: 0.5rem;
        }

        .version-badge {
            display: inline-block;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--accent-cyan);
            border: 1px solid var(--border-color);
            margin-top: 1rem;
        }

        .upload-section {
            margin-bottom: 2rem;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            padding: 3rem 2rem;
            text-align: center;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-area::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(6, 182, 212, 0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-area:hover,
        .upload-area.drag-over {
            border-color: var(--accent-blue);
            box-shadow: 0 0 30px var(--shadow-glow);
        }

        .upload-area:hover::before,
        .upload-area.drag-over::before {
            opacity: 1;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
        }

        .upload-text {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .upload-text strong {
            color: var(--accent-blue);
        }

        .file-input {
            display: none;
        }

        .upload-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .url-fetch-section {
            margin: 0 auto 2rem auto;
            max-width: 600px;
        }

        .url-fetch-container {
            display: flex;
            gap: 0.5rem;
            background: var(--bg-card);
            padding: 0.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            transition: border-color 0.2s;
        }

        .url-fetch-container:focus-within {
            border-color: var(--accent-blue);
        }

        .url-fetch-container input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            font-family: var(--font-sans);
            outline: none;
            min-width: 0;
        }

        .url-fetch-container input::placeholder {
            color: var(--text-muted);
        }

        .results-section {
            display: none;
        }

        .results-section.visible {
            display: block;
            animation: fadeIn 0.4s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .summary-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
        }

        .summary-card.status-stopped::before {
            background: var(--accent-red);
        }

        .summary-card.status-finished::before {
            background: var(--accent-green);
        }

        .summary-card.trigger-info::before {
            background: var(--accent-blue);
        }

        .summary-card.branch-info::before {
            background: var(--accent-purple);
        }

        .summary-card.last-step-info::before {
            background: var(--accent-orange);
        }

        .card-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .card-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            word-break: break-word;
        }

        .card-detail {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .card-mono {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            background: var(--bg-tertiary);
            padding: 0.5rem;
            border-radius: 6px;
            margin-top: 0.5rem;
            word-break: break-all;
        }

        .analysis-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .panel-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .panel-header:hover {
            background: var(--bg-tertiary);
        }

        .panel-header h3 {
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-header.success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
        }

        .panel-header.warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));
        }

        .panel-header.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05));
        }

        .panel-toggle {
            font-size: 1.25rem;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .panel-header.expanded .panel-toggle {
            transform: rotate(180deg);
        }

        .panel-content {
            padding: 1.5rem;
        }

        .panel-content.collapsible {
            display: none;
        }

        .panel-content.collapsible.visible {
            display: block;
        }

        .last-step-analysis {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.1), rgba(249, 115, 22, 0.05));
            border: 1px solid rgba(249, 115, 22, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .last-step-analysis h4 {
            color: var(--accent-orange);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .last-step-path {
            font-family: var(--font-mono);
            font-size: 0.9rem;
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            word-break: break-all;
        }

        .last-step-interpretation {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 8px;
        }

        .last-step-interpretation p {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .last-step-interpretation strong {
            color: var(--text-primary);
        }

        .helper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
        }

        .helper-item {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
        }

        .helper-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .helper-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .helper-value.active {
            color: var(--accent-green);
        }

        .helper-value.inactive {
            color: var(--text-muted);
        }

        .execution-step {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .step-status {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .step-status.pass {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .step-status.fail {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .step-status.exec {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-blue);
        }

        .step-status.last {
            background: rgba(249, 115, 22, 0.3);
            color: var(--accent-orange);
        }

        .step-content {
            flex-grow: 1;
        }

        .step-path {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--accent-cyan);
            word-break: break-all;
        }

        .step-result {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .step-time {
            font-size: 0.7rem;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .variables-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .var-group {
            margin-bottom: 0.5rem;
        }

        .var-group-title {
            font-size: 0.75rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .var-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.25rem 0;
            font-size: 0.8rem;
            gap: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .var-item:last-child {
            border-bottom: none;
        }

        .var-name {
            font-family: var(--font-mono);
            color: var(--text-muted);
            font-size: 0.75rem;
            flex-shrink: 0;
            max-width: 45%;
        }

        .var-value {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            text-align: right;
            word-break: break-word;
            color: var(--text-secondary);
        }

        .var-value.bool-true {
            color: var(--accent-green);
        }

        .var-value.bool-false {
            color: var(--accent-red);
        }

        .var-value.number {
            color: var(--accent-cyan);
        }

        .quick-actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .action-btn {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            font-family: var(--font-sans);
            text-decoration: none;
        }

        .action-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-blue);
        }

        .action-btn.primary {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            border: none;
        }

        .suggestions-list {
            list-style: none;
            margin-top: 1rem;
        }

        .suggestions-list li {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .suggestions-list li::before {
            content: 'üí°';
            flex-shrink: 0;
        }

        pre {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 400px;
            overflow: auto;
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: 8px;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
            font-size: 0.85rem;
            border-top: 1px solid var(--border-color);
            margin-top: 3rem;
        }

        footer a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.75rem;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-highlight);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .branch-badge {
            display: inline-block;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .condition-result {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .condition-result.true {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }

        .condition-result.false {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .step-count {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }

        /* FEATURE 1: Condition Match Summary Styles */
        .condition-summary-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .condition-summary-card {
            background: var(--bg-card);
            border-left: 4px solid var(--border-color);
            padding: 1rem;
            border-radius: 8px;
        }

        .condition-summary-card.pass {
            border-left-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.05);
        }

        .condition-summary-card.fail {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .condition-summary-card.skip {
            border-left-color: var(--border-color);
            background: var(--bg-tertiary);
        }

        .condition-summary-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .condition-summary-status {
            font-size: 1.25rem;
        }

        .condition-summary-detail {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .condition-flow-diagram {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .flow-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .flow-item.pass {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .flow-item.fail {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .flow-arrow {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* FEATURE 2: Shading Condition Deep-Dive Styles */
        .shading-hierarchy {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .hierarchy-level {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .hierarchy-level:last-child {
            border-bottom: none;
        }

        .hierarchy-title {
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hierarchy-operator {
            display: inline-block;
            background: var(--bg-tertiary);
            color: var(--accent-cyan);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .condition-tree {
            margin-left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .condition-leaf {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .condition-leaf.pass {
            background: rgba(16, 185, 129, 0.15);
            border-left: 3px solid var(--accent-green);
        }

        .condition-leaf.fail {
            background: rgba(239, 68, 68, 0.15);
            border-left: 3px solid var(--accent-red);
        }

        .condition-leaf-icon {
            font-size: 1rem;
        }

        .condition-leaf-name {
            font-weight: 500;
            min-width: 150px;
        }

        .condition-leaf-value {
            color: var(--text-secondary);
            font-size: 0.8rem;
            flex: 1;
        }

        .condition-leaf-result {
            font-weight: 600;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            background: var(--bg-primary);
        }

        .condition-leaf-result.pass {
            color: var(--accent-green);
        }

        .condition-leaf-result.fail {
            color: var(--accent-red);
        }

        /* FEATURE 3: Pending State Timeline Styles */
        .pending-timeline {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .pending-event {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-card);
            border-radius: 8px;
            border-left: 4px solid var(--border-highlight);
        }

        .pending-event.trigger {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .pending-event.execution {
            border-left-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.05);
        }

        .pending-event.timeout {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .pending-event-time {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 140px;
        }

        .pending-event-content {
            flex: 1;
        }

        .pending-event-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .pending-event-detail {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .pending-event-duration {
            display: inline-block;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .pending-timeline-summary {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .pending-timeline-stat {
            display: inline-block;
            margin-right: 2rem;
        }

        .pending-timeline-stat-label {
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .pending-timeline-stat-value {
            font-weight: 600;
            font-family: var(--font-mono);
        }

        .no-shading-info {
            padding: 1.5rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            color: var(--text-secondary);
            text-align: center;
        }

        .no-shading-info::before {
            content: '‚ÑπÔ∏è ';
            margin-right: 0.5rem;
        }

        /* OPT #2: Branch Decision Tree Styles */
        .branch-tree {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .branch-item {
            background: var(--bg-card);
            border-left: 4px solid var(--border-color);
            padding: 1rem;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .branch-item.pass {
            border-left-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.05);
        }

        .branch-item.fail {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .branch-item.executed {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .branch-icon {
            font-size: 1.5rem;
            min-width: 2.5rem;
            text-align: center;
        }

        .branch-content {
            flex: 1;
        }

        .branch-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .branch-number {
            background: var(--bg-tertiary);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }

        .branch-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .branch-reason {
            font-size: 0.8rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
            border-left: 2px solid var(--border-highlight);
            margin-top: 0.5rem;
        }

        .branch-reason.fail {
            border-left-color: var(--accent-red);
        }

        .branch-reason.pass {
            border-left-color: var(--accent-green);
        }

        /* OPT #1: Condition Chain Error Analysis Styles */
        .condition-chain {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .condition-chain-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .condition-chain-header {
            background: var(--bg-tertiary);
            padding: 0.75rem 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .condition-chain-header.fail {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .condition-chain-header.pass {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }

        .condition-chain-content {
            padding: 1rem;
        }

        .condition-node {
            margin-bottom: 0.75rem;
            padding-left: 2rem;
            position: relative;
        }

        .condition-node::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0.5rem;
            width: 1rem;
            height: 1px;
            background: var(--border-color);
        }

        .condition-node-label {
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .condition-node-result {
            display: inline-block;
            padding: 0.15rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .condition-node-result.true {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .condition-node-result.false {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .condition-node-detail {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .error-explanation {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .success-explanation {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--accent-green);
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">üîç</div>
                <h1>CCA Trace Analyzer</h1>
            </div>
            <p class="subtitle">Analyze CCA automation traces to understand what happened</p>
            <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
                <span class="version-badge">v1.0 - For CCA Blueprint v2025.12.22+</span>
                <a href="../trace-compare/" class="version-badge"
                    style="text-decoration: none; border-color: var(--accent-purple); color: var(--accent-purple);">üìà
                    CCA Trace Compare</a>
            </div>
        </header>

        <section class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÑ</div>
                <p class="upload-text">
                    <strong>Drop your trace JSON file here</strong><br>
                    or click to browse
                </p>
                <p class="upload-hint">
                    Download: Home Assistant ‚Üí Automations ‚Üí CCA ‚Üí ‚ãÆ ‚Üí Traces ‚Üí Select trace ‚Üí ‚¨áÔ∏è Download
                </p>
                <input type="file" class="file-input" id="fileInput" accept=".json,application/json">
            </div>
        </section>

        <section class="url-fetch-section">
            <div class="url-fetch-container">
                <input type="text" id="traceUrlInput" placeholder="Paste Pastebin or Gist URL here...">
                <button class="action-btn primary" id="fetchUrlBtn">üîç Fetch Trace</button>
            </div>

            <!-- Blueprint Source Configuration -->
            <div class="url-fetch-container" style="margin-top: 0.5rem; background: var(--bg-tertiary);">
                <span style="padding: 0.5rem; color: var(--text-muted); font-size: 1.2rem;">üìú</span>
                <input type="text" id="blueprintUrlInput" placeholder="Blueprint GitHub URL"
                    value="https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml"
                    style="font-size: 0.85rem;">
                <button class="action-btn" id="fetchBlueprintBtn" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">üîÑ
                    Load Source</button>
            </div>
            <div id="blueprintStatus"
                style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; text-align: right; padding-right: 0.5rem;">
                Blueprint source not loaded
            </div>

            <div style="text-align: center; margin-top: 1rem;">
                <p class="url-hint">Supports Pastebin, GitHub Gists, and direct JSON links</p>
                <button class="action-btn" id="manualPasteToggle"
                    style="margin-top: 0.5rem; background: none; border: 1px dashed var(--border-color); font-size: 0.85rem; padding: 0.4rem 0.8rem;">
                    üìã Or paste JSON manually
                </button>
            </div>

            <div id="manualPasteSection" style="display: none; margin-top: 1.5rem; animation: fadeIn 0.3s ease;">
                <textarea id="manualPasteArea" placeholder="Paste your trace JSON here..."
                    style="width: 100%; height: 200px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; color: var(--text-primary); font-family: monospace; font-size: 0.85rem; resize: vertical; outline: none;"></textarea>
                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: center;">
                    <button class="action-btn primary" id="processPasteBtn">‚ö° Process Paste</button>
                    <button class="action-btn" id="cancelPasteBtn">Cancel</button>
                </div>
            </div>
        </section>

        <section class="results-section" id="resultsSection">
            <div class="quick-actions">
                <button class="action-btn primary" id="newAnalysis">üì§ Analyze Another</button>
                <button class="action-btn" id="copyReport">üìã Copy Report</button>
                <button class="action-btn" id="downloadReport">üíæ Download Report</button>
            </div>

            <div class="summary-grid" id="summaryGrid"></div>

            <!-- Last Step Analysis - NEW AND IMPORTANT -->
            <div class="analysis-panel" id="lastStepPanel">
                <div class="panel-header warning">
                    <h3>üéØ Last Step Analysis</h3>
                </div>
                <div class="panel-content" id="lastStepContent"></div>
            </div>

            <!-- OPT #2: Branch Decision Tree -->
            <div class="analysis-panel">
                <div class="panel-header" id="branchTreeHeader">
                    <h3>üèóÔ∏è Branch Decision Tree</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="branchTreeContent"></div>
            </div>

            <!-- OPT #1: Condition Chain Error Analysis -->
            <div class="analysis-panel" id="conditionErrorPanel" style="display: none;">
                <div class="panel-header" id="conditionErrorHeader">
                    <h3>üîç Condition Chain Analysis</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="conditionErrorContent"></div>
            </div>

            <!-- FEATURE 1: Condition Match Summary -->
            <div class="analysis-panel">
                <div class="panel-header" id="conditionSummaryHeader">
                    <h3>üé≤ Condition Match Summary</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="conditionSummaryContent"></div>
            </div>

            <!-- FEATURE 2: Shading Condition Deep-Dive -->
            <div class="analysis-panel" id="shadingDivePanel" style="display: none;">
                <div class="panel-header" id="shadingDiveHeader">
                    <h3>üìä Shading Conditions Deep-Dive</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="shadingDiveContent"></div>
            </div>

            <!-- FEATURE 3: Pending State Timeline -->
            <div class="analysis-panel" id="pendingTimelinePanel" style="display: none;">
                <div class="panel-header" id="pendingTimelineHeader">
                    <h3>‚è±Ô∏è Pending State Timeline</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="pendingTimelineContent"></div>
            </div>

            <!-- Helper Status -->
            <div class="analysis-panel">
                <div class="panel-header" id="helperHeader">
                    <h3>ü¶Æ Helper Status at Trigger Time</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="helperContent"></div>
            </div>

            <!-- Timing Analysis -->
            <div class="analysis-panel">
                <div class="panel-header" id="timingHeader">
                    <h3>‚è±Ô∏è Timing Analysis</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="timingContent"></div>
            </div>

            <!-- Variable Changes Timeline -->
            <div class="analysis-panel">
                <div class="panel-header" id="varChangesHeader">
                    <h3>üìà Variable Changes Timeline</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="varChangesContent"></div>
            </div>

            <!-- Action Execution Details -->
            <div class="analysis-panel">
                <div class="panel-header" id="actionDetailsHeader">
                    <h3>‚öôÔ∏è Action Execution Details</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="actionDetailsContent"></div>
            </div>

            <!-- Position Tracking -->
            <div class="analysis-panel">
                <div class="panel-header" id="positionTrackingHeader">
                    <h3>üìç Position Tracking</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="positionTrackingContent"></div>
            </div>

            <!-- Execution Path -->
            <div class="analysis-panel">
                <div class="panel-header" id="pathHeader">
                    <h3>üìç Execution Path <span class="step-count" id="stepCount"></span></h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="pathContent">
                    <div class="filter-buttons" id="filterButtons"></div>
                    <div id="executionSteps"></div>
                </div>
            </div>

            <!-- Variables -->
            <div class="analysis-panel">
                <div class="panel-header" id="varsHeader">
                    <h3>üìä Key Variables</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible visible" id="varsContent"></div>
            </div>

            <!-- Raw JSON -->
            <div class="analysis-panel">
                <div class="panel-header" id="jsonHeader">
                    <h3>üìÑ Raw Trace Data</h3>
                    <span class="panel-toggle">‚ñº</span>
                </div>
                <div class="panel-content collapsible" id="jsonContent">
                    <pre id="jsonPre"></pre>
                </div>
            </div>
        </section>
    </div>

    <footer>
        <p>CCA Trace Analyzer ‚Ä¢ Made with ‚ù§Ô∏è by <a href="https://github.com/hvorragend">hvorragend</a></p>
        <a href="https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539"
            target="_blank">CCA Community Thread</a> ‚Ä¢
        <a href="../validator/" target="_blank">üì¶ Configuration Validator</a> ‚Ä¢
        <a href="../trace-compare/" target="_blank">üìà CCA Trace Compare</a> ‚Ä¢
        <a href="../trace-analyzer/" target="_blank">üîç CCA Trace Analyzer</a> ‚Ä¢
        <a href="https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/FAQ.md" target="_blank">‚ùì
            FAQ</a> ‚Ä¢
        <a href="https://github.com/hvorragend/ha-blueprints" target="_blank">üì¶ GitHub Repository</a>
    </footer>

    <script>
        // =====================================================================
        // CCA TRACE ANALYZER v3
        // Properly handles Home Assistant trace structure
        // =====================================================================

        // Branch definitions from CCA Blueprint
        const BRANCH_DEFINITIONS = {
            0: { name: 'Opening', description: 'Automatic cover opening control', icon: 'üîº' },
            1: { name: 'Closing', description: 'Automatic cover closing control', icon: 'üîª' },
            2: { name: 'Shading Start', description: 'Activates sun protection/shading', icon: '‚òÄÔ∏è' },
            3: { name: 'Shading Tilt', description: 'Adjusts tilt during active shading', icon: 'üìê' },
            4: { name: 'Shading End', description: 'Deactivates sun protection', icon: 'üå•Ô∏è' },
            5: { name: 'Contact Sensor', description: 'Window/door state changes (ventilation)', icon: 'ü™ü' },
            6: { name: 'Force Open', description: 'Forced opening via entity', icon: '‚¨ÜÔ∏è' },
            7: { name: 'Force Close', description: 'Forced closing via entity', icon: '‚¨áÔ∏è' },
            8: { name: 'Force Ventilate', description: 'Forced ventilation via entity', icon: 'üí®' },
            9: { name: 'Force Shading', description: 'Forced shading via entity', icon: 'üåû' },
            10: { name: 'Manual Detection', description: 'Detects manual position changes', icon: 'üñêÔ∏è' },
            11: { name: 'Reset Override', description: 'Resets manual override status', icon: 'üîÑ' },
            12: { name: 'Return After Force', description: 'Returns to background state after force disable', icon: '‚Ü©Ô∏è' },
            13: { name: 'Midnight Reset', description: 'Resets shading status at end of day', icon: 'üåô' }
        };

        // Trigger ID explanations
        const TRIGGER_EXPLANATIONS = {
            't_open_1': 'Time-based opening (early time reached)',
            't_open_2': 'Time-based opening (late time reached)',
            't_open_4': 'Brightness exceeded opening threshold',
            't_open_5': 'Sun elevation exceeded opening threshold',
            't_open_6': 'Resident woke up (sensor turned off)',
            't_close_1': 'Time-based closing (early time reached)',
            't_close_2': 'Time-based closing (late time reached)',
            't_close_4': 'Brightness dropped below closing threshold',
            't_close_5': 'Sun elevation dropped below closing threshold',
            't_close_6': 'Resident went to sleep (sensor turned on)',
            't_calendar_event_start': 'Calendar event started',
            't_calendar_event_end': 'Calendar event ended',
            't_contact_tilted_changed': 'Window tilt sensor changed',
            't_contact_opened_changed': 'Window open sensor changed',
            't_shading_start_pending_1': 'Sun position entered shading range',
            't_shading_start_pending_2': 'Brightness exceeded shading threshold',
            't_shading_start_pending_3': 'Temperature 1 exceeded threshold',
            't_shading_start_pending_4': 'Temperature 2 exceeded threshold',
            't_shading_start_pending_5': 'Weather condition matched',
            't_shading_start_pending_6': 'Pre-opening forecast check (1h before)',
            't_shading_start_execution': 'Shading start waiting period completed',
            't_shading_end_pending_1': 'Temperature 1 dropped below threshold',
            't_shading_end_pending_2': 'Temperature 2 dropped below threshold',
            't_shading_end_pending_3': 'Brightness dropped below threshold',
            't_shading_end_pending_4': 'Weather condition no longer met',
            't_shading_end_pending_5': 'Sun position left shading range',
            't_shading_end_execution': 'Shading end waiting period completed',
            't_shading_tilt_1': 'Sun elevation change (below level 1)',
            't_shading_tilt_2': 'Sun elevation change (level 1-2)',
            't_shading_tilt_3': 'Sun elevation change (level 2-3)',
            't_shading_tilt_4': 'Sun elevation change (above level 3)',
            't_shading_reset': 'Midnight shading reset',
            't_manual_position': 'Cover position changed manually',
            't_manual_tilt': 'Cover tilt changed manually',
            't_reset_fixedtime': 'Fixed time override reset',
            't_reset_timeout': 'Timeout override reset',
            't_force_enabled_open': 'Force open entity activated',
            't_force_enabled_close': 'Force close entity activated',
            't_force_enabled_ventilate': 'Force ventilate entity activated',
            't_force_enabled_shading': 'Force shading entity activated',
            't_force_disabled_open': 'Force open entity deactivated',
            't_force_disabled_close': 'Force close entity deactivated',
            't_force_disabled_ventilate': 'Force ventilate entity deactivated',
            't_force_disabled_shading': 'Force shading entity deactivated'
        };

        // State
        let currentTrace = null;
        let currentFilter = 'all';
        let blueprintDoc = null; // YAML Document for source linking

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            // Auto-load blueprint source if possible
            fetchBlueprintSource();

            const transferred = localStorage.getItem('cca_trace_transfer');
            if (transferred) {
                try {
                    const trace = JSON.parse(transferred);
                    // Clear it immediately to avoid re-loads
                    localStorage.removeItem('cca_trace_transfer');

                    // CRITICAL: Set currentTrace so renderSummary and other tools work
                    currentTrace = trace;

                    // Small delay to ensure all DOM elements are globally accessible if needed
                    setTimeout(() => analyzeTrace(trace), 50);
                } catch (err) {
                    console.error('Error loading transferred trace:', err);
                }
            }
        });

        // DOM Elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const resultsSection = document.getElementById('resultsSection');
        const traceUrlInput = document.getElementById('traceUrlInput');
        const fetchUrlBtn = document.getElementById('fetchUrlBtn');
        const manualPasteArea = document.getElementById('manualPasteArea');
        const processPasteBtn = document.getElementById('processPasteBtn');
        const manualPasteToggle = document.getElementById('manualPasteToggle');
        const cancelPasteBtn = document.getElementById('cancelPasteBtn');

        // Event Listeners
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('drag-over'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('drag-over'));
        uploadArea.addEventListener('drop', handleFileDrop);
        fileInput.addEventListener('change', handleFileSelect);

        document.getElementById('fetchBlueprintBtn').addEventListener('click', fetchBlueprintSource);

        fetchUrlBtn.addEventListener('click', fetchExternalTrace);
        traceUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') fetchExternalTrace(); });

        manualPasteToggle.addEventListener('click', () => {
            document.getElementById('manualPasteSection').style.display = 'block';
            manualPasteToggle.style.display = 'none';
        });

        cancelPasteBtn.addEventListener('click', () => {
            document.getElementById('manualPasteSection').style.display = 'none';
            manualPasteToggle.style.display = 'inline-block';
            manualPasteArea.value = '';
        });

        processPasteBtn.addEventListener('click', () => {
            const text = manualPasteArea.value.trim();
            if (text) {
                processJsonText(text);
                document.getElementById('manualPasteSection').style.display = 'none';
                manualPasteToggle.style.display = 'inline-block';
                manualPasteArea.value = '';
            }
        });

        document.getElementById('newAnalysis').addEventListener('click', () => {
            resultsSection.classList.remove('visible');
            fileInput.value = '';
        });

        document.getElementById('copyReport').addEventListener('click', copyReport);
        document.getElementById('downloadReport').addEventListener('click', downloadReport);

        // Toggle panels
        ['branchTreeHeader', 'conditionErrorHeader', 'conditionSummaryHeader', 'shadingDiveHeader', 'pendingTimelineHeader', 'helperHeader', 'timingHeader', 'varChangesHeader', 'actionDetailsHeader', 'positionTrackingHeader', 'pathHeader', 'varsHeader', 'jsonHeader'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('click', function () {
                    this.classList.toggle('expanded');
                    const content = this.nextElementSibling;
                    content.classList.toggle('visible');
                });
            }
        });

        function handleFileDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file) processFile(file);
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) processFile(file);
        }

        async function fetchExternalTrace() {
            let url = traceUrlInput.value.trim();
            if (!url) return;

            // URL Transformation
            try {
                const urlObj = new URL(url);

                if (urlObj.hostname === 'gist.github.com') {
                    const parts = urlObj.pathname.split('/').filter(p => p);
                    if (parts.length >= 2) {
                        url = `https://gist.githubusercontent.com/${parts[0]}/${parts[1]}/raw`;
                    }
                } else if (urlObj.hostname === 'pastebin.com' && !urlObj.pathname.startsWith('/raw/')) {
                    const id = urlObj.pathname.substring(1);
                    if (id) url = `https://pastebin.com/raw/${id}`;
                }
            } catch (e) {
                console.warn('URL parsing failed, trying as is');
            }

            fetchUrlBtn.disabled = true;
            fetchUrlBtn.textContent = '‚è≥ Fetching...';

            try {
                let response;
                let errorDetails = '';

                try {
                    response = await fetch(url);
                } catch (fetchErr) {
                    errorDetails += `Direct: ${fetchErr.message}\n`;
                }

                if (!response || !response.ok) {
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                    try {
                        response = await fetch(proxyUrl);
                    } catch (proxyErr) {
                        errorDetails += `Proxy 1: ${proxyErr.message}\n`;
                    }
                }

                if (!response || !response.ok) {
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    try {
                        const proxyResponse = await fetch(proxyUrl);
                        if (proxyResponse.ok) {
                            const data = await proxyResponse.json();
                            const filename = url.split('/').pop() || 'remote_trace';
                            processJsonText(data.contents, filename);
                            return;
                        }
                    } catch (proxyErr) {
                        errorDetails += `Proxy 2: ${proxyErr.message}\n`;
                    }
                }

                if (response && response.ok) {
                    const jsonText = await response.text();
                    const filename = url.split('/').pop() || 'remote_trace';
                    processJsonText(jsonText, filename);
                } else {
                    throw new Error(errorDetails || `Status: ${response?.status || 'Unknown'}`);
                }
            } catch (err) {
                console.error('All fetch attempts failed:', err);
                alert(`Could not fetch the trace.\n\nDetails:\n${err.message}`);
            } finally {
                fetchUrlBtn.disabled = false;
                fetchUrlBtn.textContent = 'üîç Fetch Trace';
            }
        }

        function processJsonText(jsonText, filename = 'pasted_trace.json') {
            let trace = null;
            let repaired = false;

            if (typeof jsonText === 'object' && jsonText !== null) {
                trace = jsonText;
            } else if (typeof jsonText === 'string') {
                const cleanText = jsonText.trim().replace(/^\uFEFF/, '');
                try {
                    trace = JSON.parse(cleanText);
                } catch (err) {
                    try {
                        trace = repairTruncatedJson(cleanText);
                        repaired = true;
                    } catch (repairErr) {
                        alert('Error parsing JSON: ' + err.message);
                        return;
                    }
                }
            }

            if (trace) {
                currentTrace = trace;
                currentTrace._repaired = repaired;
                currentTrace._filename = filename;
                try {
                    analyzeTrace(trace);
                } catch (analysisErr) {
                    console.error('Error during trace analysis:', analysisErr);
                    alert('Error analyzing trace: ' + analysisErr.message);
                }
            }
        }

        function processFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => processJsonText(e.target.result, file.name);
            reader.readAsText(file);
        }

        /**
         * Attempts to repair truncated JSON by:
         * 1. Cutting off at the "config" section (which we don't need anyway)
         * 2. Or finding the last complete trace entry
         * 3. Closing all open brackets
         */
        function repairTruncatedJson(jsonText) {
            console.log('Attempting to repair truncated JSON...');

            let text = jsonText;

            // Strategy 1: Cut off at "config" section - we don't need it!
            // The config section contains static blueprint YAML, not runtime data
            const configMatch = text.match(/,\s*"config"\s*:\s*\{/);
            if (configMatch) {
                const configPos = configMatch.index;
                console.log(`Found "config" section at position ${configPos}, cutting it off`);
                text = text.substring(0, configPos);
            } else {
                // Strategy 2: Find last complete line before truncation
                const lines = text.split('\n');
                let validLines = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.includes('"') && !isLineComplete(line)) {
                        console.log(`Stopping at line ${i + 1}: incomplete string`);
                        break;
                    }
                    validLines.push(lines[i]);
                }
                text = validLines.join('\n');
            }

            // Remove trailing comma if present
            text = text.replace(/,\s*$/, '');

            // Count remaining open brackets
            const openBraces = (text.match(/{/g) || []).length;
            const closeBraces = (text.match(/}/g) || []).length;
            const openBrackets = (text.match(/\[/g) || []).length;
            const closeBrackets = (text.match(/]/g) || []).length;

            // Add closing brackets
            const neededBraces = openBraces - closeBraces;
            const neededBrackets = openBrackets - closeBrackets;

            // Close in reverse order of typical nesting
            let closing = '';
            for (let i = 0; i < neededBrackets; i++) closing += ']';
            for (let i = 0; i < neededBraces; i++) closing += '}';

            text += closing;

            console.log(`Repair: removed config section, added ${neededBrackets} ] and ${neededBraces} }`);

            const result = JSON.parse(text);
            console.log('Repair successful!');
            return result;
        }

        function isLineComplete(line) {
            // A line is complete if quotes are balanced
            let inString = false;
            let escaped = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (escaped) {
                    escaped = false;
                    continue;
                }
                if (char === '\\') {
                    escaped = true;
                    continue;
                }
                if (char === '"') {
                    inString = !inString;
                }
            }

            return !inString; // Complete if not inside a string
        }

        function analyzeTrace(trace) {
            // Extract main info from trace structure
            const traceInfo = trace.trace || {};
            const lastStep = traceInfo.last_step || 'N/A';
            const runId = traceInfo.run_id || 'N/A';
            const state = traceInfo.state || 'unknown';
            const scriptExecution = traceInfo.script_execution || 'unknown';
            const timestamp = traceInfo.timestamp || {};
            const innerTrace = traceInfo.trace || {};

            // Find trigger info
            const triggerInfo = extractTriggerInfo(innerTrace);

            // Find which branch was executed
            const branchInfo = extractBranchInfo(lastStep, innerTrace);

            // Get all variables from trigger step
            const variables = extractVariables(innerTrace);

            // Parse execution steps
            const steps = parseExecutionSteps(innerTrace, lastStep);

            // Render everything
            renderSummary(state, scriptExecution, triggerInfo, branchInfo, timestamp, lastStep, runId);
            renderLastStepAnalysis(lastStep, innerTrace, branchInfo);

            // OPT #2: Render Branch Decision Tree
            renderBranchDecisionTree(innerTrace, lastStep, branchInfo);

            // OPT #1: Render Condition Chain Error Analysis
            renderConditionChainAnalysis(innerTrace, lastStep);

            // FEATURE 1: Render Condition Match Summary
            renderConditionMatchSummary(lastStep, innerTrace, variables, branchInfo);

            // FEATURE 2: Render Shading Deep-Dive (only if shading-related)
            if (isShadingRelated(triggerInfo, variables)) {
                renderShadingConditionDeepDive(variables, innerTrace);
                document.getElementById('shadingDivePanel').style.display = 'block';
            }

            // FEATURE 3: Render Pending State Timeline (only if shading-related)
            if (isShadingRelated(triggerInfo, variables)) {
                renderPendingStateTimeline(innerTrace, timestamp.start);
                document.getElementById('pendingTimelinePanel').style.display = 'block';
            }

            renderHelperStatus(variables);
            renderTimingAnalysis(innerTrace, timestamp.start);
            renderVariableChangesTimeline(innerTrace, timestamp.start);
            renderActionExecutionDetails(innerTrace);
            renderPositionTracking(innerTrace, variables, timestamp.start);
            renderExecutionPath(steps, lastStep);
            renderVariables(variables);
            document.getElementById('jsonPre').textContent = JSON.stringify(trace, null, 2);

            resultsSection.classList.add('visible');
        }

        // FEATURE 1: Condition Match Summary
        function renderConditionMatchSummary(lastStep, innerTrace, variables, branchInfo) {
            let html = '<div class="condition-summary-grid">';

            // 1. Global conditions evaluation
            const globalConditionsPassed = !lastStep.startsWith('condition/');
            html += `
                <div class="condition-summary-card ${globalConditionsPassed ? 'pass' : 'fail'}">
                    <div class="condition-summary-header">
                        <span class="condition-summary-status">${globalConditionsPassed ? '‚úÖ' : '‚ùå'}</span>
                        <div>Global Conditions</div>
                    </div>
                    <div class="condition-summary-detail">
                        ${globalConditionsPassed ?
                    'All global conditions were met, automation proceeded to branch evaluation.' :
                    'A global condition was not met. The automation was blocked before branch selection.'}
                    </div>
                </div>
            `;

            // 2. Branch matching
            if (branchInfo.matched) {
                html += `
                    <div class="condition-summary-card pass">
                        <div class="condition-summary-header">
                            <span class="condition-summary-status">‚úÖ</span>
                            <div>Branch Matched</div>
                        </div>
                        <div class="condition-summary-detail">
                            ${branchInfo.icon} <strong>${branchInfo.number}: ${branchInfo.name}</strong> - ${branchInfo.description}
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div class="condition-summary-card fail">
                        <div class="condition-summary-header">
                            <span class="condition-summary-status">‚ùå</span>
                            <div>No Branch Matched</div>
                        </div>
                        <div class="condition-summary-detail">
                            ${globalConditionsPassed ?
                        'All branch conditions were evaluated, but none matched.' :
                        'Stopped at global conditions before branch evaluation.'}
                        </div>
                    </div>
                `;
            }

            // 3. Key enablement flags
            const enabledFeatures = [];
            if (variables.is_up_enabled) enabledFeatures.push('Opening');
            if (variables.is_down_enabled) enabledFeatures.push('Closing');
            if (variables.is_shading_enabled) enabledFeatures.push('Shading');
            if (variables.is_ventilation_enabled) enabledFeatures.push('Ventilation');

            if (enabledFeatures.length > 0) {
                html += `
                    <div class="condition-summary-card pass">
                        <div class="condition-summary-header">
                            <span class="condition-summary-status">‚öôÔ∏è</span>
                            <div>Enabled Features</div>
                        </div>
                        <div class="condition-summary-detail">
                            ${enabledFeatures.join(' ‚Ä¢ ')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            document.getElementById('conditionSummaryContent').innerHTML = html;
        }

        // FEATURE 2: Shading Condition Deep-Dive
        function renderShadingConditionDeepDive(variables, innerTrace) {
            let html = '';

            // Check if shading start conditions exist
            if (variables.shading_conditions_start_and || variables.shading_conditions_start_or) {
                html += '<div class="hierarchy-level">';
                html += '<div class="hierarchy-title"><span class="hierarchy-operator">SHADING START</span> Sun Position + Thresholds</div>';

                const startAnd = variables.shading_conditions_start_and || {};
                const startOr = variables.shading_conditions_start_or || {};

                html += '<div class="condition-tree">';

                // AND conditions for shading start
                if (Object.keys(startAnd).length > 0) {
                    html += `<div class="hierarchy-title" style="margin-top: 0.5rem; margin-bottom: 0.5rem;"><span class="hierarchy-operator">AND</span> All must be true:</div>`;

                    // Azimuth range check
                    if (variables.shading_azimuth_start !== undefined && variables.shading_azimuth_end !== undefined && variables.current_sun_azimuth !== undefined) {
                        const azStart = variables.shading_azimuth_start;
                        const azEnd = variables.shading_azimuth_end;
                        const azCurrent = variables.current_sun_azimuth;
                        const inRange = (azCurrent >= azStart && azCurrent <= azEnd) ||
                            (azStart > azEnd && (azCurrent >= azStart || azCurrent <= azEnd));

                        html += `
                            <div class="condition-leaf ${inRange ? 'pass' : 'fail'}">
                                <span class="condition-leaf-icon">‚òÄÔ∏è</span>
                                <span class="condition-leaf-name">Azimuth Range</span>
                                <span class="condition-leaf-value">${azCurrent.toFixed(1)}¬∞ (range: ${azStart}-${azEnd}¬∞)</span>
                                <span class="condition-leaf-result ${inRange ? 'pass' : 'fail'}">${inRange ? '‚úì' : '‚úó'}</span>
                            </div>
                        `;
                    }

                    // Sun elevation check
                    if (variables.shading_elevation_min !== undefined && variables.shading_elevation_max !== undefined && variables.current_sun_elevation !== undefined) {
                        const elMin = variables.shading_elevation_min;
                        const elMax = variables.shading_elevation_max;
                        const elCurrent = variables.current_sun_elevation;
                        const inRange = elCurrent >= elMin && elCurrent <= elMax;

                        html += `
                            <div class="condition-leaf ${inRange ? 'pass' : 'fail'}">
                                <span class="condition-leaf-icon">üìê</span>
                                <span class="condition-leaf-name">Elevation Range</span>
                                <span class="condition-leaf-value">${elCurrent.toFixed(1)}¬∞ (range: ${elMin}-${elMax}¬∞)</span>
                                <span class="condition-leaf-result ${inRange ? 'pass' : 'fail'}">${inRange ? '‚úì' : '‚úó'}</span>
                            </div>
                        `;
                    }

                    // Brightness check
                    if (variables.shading_sun_brightness_start !== undefined && variables.default_brightness_sensor !== undefined) {
                        const brightness = startAnd.brightness_check ?? null;
                        html += `
                            <div class="condition-leaf ${brightness ? 'pass' : 'fail'}">
                                <span class="condition-leaf-icon">üí°</span>
                                <span class="condition-leaf-name">Brightness Threshold</span>
                                <span class="condition-leaf-value">Minimum: ${variables.shading_sun_brightness_start} lux</span>
                                <span class="condition-leaf-result ${brightness ? 'pass' : 'fail'}">${brightness ? '‚úì' : '‚úó'}</span>
                            </div>
                        `;
                    }

                    // Temperature checks
                    if (variables.shading_min_temperatur1 !== undefined) {
                        const temp1 = startAnd.temp1_check ?? null;
                        html += `
                            <div class="condition-leaf ${temp1 ? 'pass' : 'fail'}">
                                <span class="condition-leaf-icon">üå°Ô∏è</span>
                                <span class="condition-leaf-name">Temperature 1</span>
                                <span class="condition-leaf-value">Minimum: ${variables.shading_min_temperatur1}¬∞C</span>
                                <span class="condition-leaf-result ${temp1 ? 'pass' : 'fail'}">${temp1 ? '‚úì' : '‚úó'}</span>
                            </div>
                        `;
                    }

                    if (variables.shading_min_temperatur2 !== undefined) {
                        const temp2 = startAnd.temp2_check ?? null;
                        html += `
                            <div class="condition-leaf ${temp2 ? 'pass' : 'fail'}">
                                <span class="condition-leaf-icon">üå°Ô∏è</span>
                                <span class="condition-leaf-name">Temperature 2</span>
                                <span class="condition-leaf-value">Minimum: ${variables.shading_min_temperatur2}¬∞C</span>
                                <span class="condition-leaf-result ${temp2 ? 'pass' : 'fail'}">${temp2 ? '‚úì' : '‚úó'}</span>
                            </div>
                        `;
                    }
                }

                // OR conditions for shading start (optional additional conditions)
                if (Object.keys(startOr).length > 0) {
                    html += `<div class="hierarchy-title" style="margin-top: 1rem; margin-bottom: 0.5rem;"><span class="hierarchy-operator">OR</span> At least one must be true:</div>`;
                    const forecast = startOr.forecast_check ?? null;
                    html += `
                        <div class="condition-leaf ${forecast ? 'pass' : 'fail'}">
                            <span class="condition-leaf-icon">üå¶Ô∏è</span>
                            <span class="condition-leaf-name">Weather Forecast</span>
                            <span class="condition-leaf-value">Matches configured condition</span>
                            <span class="condition-leaf-result ${forecast ? 'pass' : 'fail'}">${forecast ? '‚úì' : '‚úó'}</span>
                        </div>
                    `;
                }

                html += '</div>';
                html += '</div>';
            }

            // Shading end conditions
            if (variables.shading_conditions_end_and || variables.shading_conditions_end_or) {
                html += '<div class="hierarchy-level">';
                html += '<div class="hierarchy-title"><span class="hierarchy-operator">SHADING END</span> Sun Position + Thresholds</div>';

                const endAnd = variables.shading_conditions_end_and || {};
                const endOr = variables.shading_conditions_end_or || {};

                html += '<div class="condition-tree">';

                if (Object.keys(endAnd).length > 0) {
                    html += `<div class="hierarchy-title" style="margin-top: 0.5rem;"><span class="hierarchy-operator">AND</span></div>`;

                    const elevation = endAnd.elevation_check ?? null;
                    const brightness = endAnd.brightness_check ?? null;

                    html += `
                        <div class="condition-leaf ${elevation ? 'pass' : 'fail'}">
                            <span class="condition-leaf-icon">üìê</span>
                            <span class="condition-leaf-name">Sun Below Minimum</span>
                            <span class="condition-leaf-value">Minimum: ${variables.shading_elevation_min || 'N/A'}¬∞</span>
                            <span class="condition-leaf-result ${elevation ? 'pass' : 'fail'}">${elevation ? '‚úì' : '‚úó'}</span>
                        </div>
                        <div class="condition-leaf ${brightness ? 'pass' : 'fail'}">
                            <span class="condition-leaf-icon">üí°</span>
                            <span class="condition-leaf-name">Brightness Below Threshold</span>
                            <span class="condition-leaf-value">Maximum: ${variables.shading_sun_brightness_end || 'N/A'} lux</span>
                            <span class="condition-leaf-result ${brightness ? 'pass' : 'fail'}">${brightness ? '‚úì' : '‚úó'}</span>
                        </div>
                    `;
                }

                html += '</div>';
                html += '</div>';
            }

            if (!html) {
                html = '<div class="no-shading-info">No shading conditions configured</div>';
            }

            html = '<div class="shading-hierarchy">' + html + '</div>';
            document.getElementById('shadingDiveContent').innerHTML = html;
        }

        // FEATURE 3: Pending State Timeline
        function renderPendingStateTimeline(innerTrace, traceStart) {
            const events = [];
            const traceStartTime = new Date(traceStart);

            // Find all pending state triggers
            const pendingStates = {
                'start': [],
                'end': []
            };

            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];

                    // Shading start pending states
                    if (path.includes('t_shading_start_pending')) {
                        const match = path.match(/t_shading_start_pending_(\d+)/);
                        const num = match ? parseInt(match[1]) : 0;
                        pendingStates.start.push({
                            num,
                            path,
                            timestamp: step.timestamp,
                            result: step.result
                        });
                    }

                    // Shading execution trigger
                    if (path.includes('t_shading_start_execution')) {
                        events.push({
                            type: 'execution',
                            name: 'Shading Start Execution',
                            timestamp: step.timestamp,
                            phase: 'start'
                        });
                    }

                    // Shading end pending states
                    if (path.includes('t_shading_end_pending')) {
                        const match = path.match(/t_shading_end_pending_(\d+)/);
                        const num = match ? parseInt(match[1]) : 0;
                        pendingStates.end.push({
                            num,
                            path,
                            timestamp: step.timestamp,
                            result: step.result
                        });
                    }

                    // Shading end execution
                    if (path.includes('t_shading_end_execution')) {
                        events.push({
                            type: 'execution',
                            name: 'Shading End Execution',
                            timestamp: step.timestamp,
                            phase: 'end'
                        });
                    }
                }
            }

            // Sort pending states by number
            pendingStates.start.sort((a, b) => a.num - b.num);
            pendingStates.end.sort((a, b) => a.num - b.num);

            // Add pending trigger events
            const pendingTriggerLabels = {
                1: 'Sun Position Entered Range',
                2: 'Brightness Threshold Exceeded',
                3: 'Temperature 1 Threshold Exceeded',
                4: 'Temperature 2 Threshold Exceeded',
                5: 'Weather Forecast Matched',
                6: '1h Pre-Opening Forecast Check'
            };

            pendingStates.start.forEach(p => {
                events.push({
                    type: 'trigger',
                    name: `Shading Start Pending ${p.num}`,
                    description: pendingTriggerLabels[p.num] || 'Unknown pending condition',
                    timestamp: p.timestamp,
                    phase: 'start'
                });
            });

            pendingStates.end.forEach(p => {
                events.push({
                    type: 'trigger',
                    name: `Shading End Pending ${p.num}`,
                    description: 'End condition met',
                    timestamp: p.timestamp,
                    phase: 'end'
                });
            });

            // Sort all events by timestamp
            events.sort((a, b) => {
                if (!a.timestamp || !b.timestamp) return 0;
                return new Date(a.timestamp) - new Date(b.timestamp);
            });

            let html = '';

            if (events.length === 0) {
                html = '<div class="no-shading-info">No shading pending states found in this trace</div>';
            } else {
                // Summary stats
                const startEvents = events.filter(e => e.phase === 'start');
                const endEvents = events.filter(e => e.phase === 'end');
                const totalWaitTime = events.length > 1 ?
                    ((new Date(events[events.length - 1].timestamp) - new Date(events[0].timestamp)) / 1000).toFixed(1) : 'N/A';

                html += `
                    <div class="pending-timeline-summary">
                        <div class="pending-timeline-stat">
                            <div class="pending-timeline-stat-label">Start Phase Events</div>
                            <div class="pending-timeline-stat-value">${startEvents.length}</div>
                        </div>
                        <div class="pending-timeline-stat">
                            <div class="pending-timeline-stat-label">End Phase Events</div>
                            <div class="pending-timeline-stat-value">${endEvents.length}</div>
                        </div>
                        <div class="pending-timeline-stat">
                            <div class="pending-timeline-stat-label">Total Duration</div>
                            <div class="pending-timeline-stat-value">${totalWaitTime}s</div>
                        </div>
                    </div>
                `;

                // Timeline
                html += '<div class="pending-timeline">';
                events.forEach((event, index) => {
                    const eventTime = event.timestamp ? new Date(event.timestamp).toLocaleTimeString() : 'N/A';
                    const prevTime = index > 0 && event.timestamp && events[index - 1].timestamp ?
                        ((new Date(event.timestamp) - new Date(events[index - 1].timestamp)) / 1000).toFixed(1) : null;

                    let eventClass = event.type;
                    let eventIcon = '‚ñ™Ô∏è';

                    if (event.type === 'trigger') {
                        eventIcon = '‚ö°';
                    } else if (event.type === 'execution') {
                        eventIcon = '‚úÖ';
                    }

                    html += `
                        <div class="pending-event ${eventClass}">
                            <div class="pending-event-time">${eventTime}</div>
                            <div class="pending-event-content">
                                <div class="pending-event-title">${eventIcon} ${event.name}</div>
                                ${event.description ? `<div class="pending-event-detail">${event.description}</div>` : ''}
                                ${prevTime ? `<div class="pending-event-duration">Œî ${prevTime}s since previous event</div>` : ''}
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            document.getElementById('pendingTimelineContent').innerHTML = html;
        }

        // Helper function to detect if this trace is shading-related
        function isShadingRelated(triggerInfo, variables) {
            return triggerInfo.id.includes('shading') ||
                (variables.is_shading_enabled && variables.shading_azimuth_start !== undefined);
        }

        // OPT #2: Branch Decision Tree Visualization
        function renderBranchDecisionTree(innerTrace, lastStep, branchInfo) {
            try {
                let html = '<div class="branch-tree">';

                // Analyze all branches to understand which were evaluated
                for (let i = 0; i < 14; i++) {
                    const branchPath = `action/6/choose/${i}/conditions`;
                    const branchKey = `action/6/choose/${i}`;
                    const branchDef = BRANCH_DEFINITIONS[i];

                    let status = 'skip';
                    let reason = 'Not evaluated';

                    // Check if this branch was evaluated
                    if (innerTrace[branchPath]) {
                        const conditionPath = `${branchPath}/0`;
                        if (innerTrace[conditionPath]) {
                            const condResult = innerTrace[conditionPath][0];
                            if (condResult && condResult.result !== undefined) {
                                if (condResult.result === true) {
                                    status = 'pass';
                                    reason = 'Branch condition met';
                                } else {
                                    status = 'fail';
                                    reason = 'Branch condition not met';
                                }
                            }
                        }
                    }

                    // Check if this branch was executed
                    if (lastStep.includes(`choose/${i}/sequence`) || lastStep.includes(`choose/${i}/default`)) {
                        status = 'executed';
                        reason = 'Branch executed';
                    }

                    // Check if this was the default branch
                    if (lastStep.includes('default/')) {
                        if (i === 13 && status === 'skip') {
                            // Don't mark branch 13 as fail just because it fallthrough to default
                        }
                    }

                    const icon = branchDef ? branchDef.icon : '‚ùì';
                    const name = branchDef ? branchDef.name : `Branch ${i}`;
                    const desc = branchDef ? branchDef.description : 'Unknown branch';

                    let statusIcon = '‚äò';
                    if (status === 'pass') statusIcon = '‚úì';
                    if (status === 'fail') statusIcon = '‚úó';
                    if (status === 'executed') statusIcon = '‚Üí';

                    html += `
                        <div class="branch-item ${status}">
                            <div class="branch-icon">${icon}</div>
                            <div class="branch-content">
                                <div class="branch-title">
                                    ${statusIcon} ${name} <span class="branch-number">#${i}</span>
                                </div>
                                <div class="branch-description">${desc}</div>
                                <div class="branch-reason ${status}">${reason}</div>
                            </div>
                        </div>
                    `;
                }

                if (lastStep.includes('default/')) {
                    // Only highlight as the path if it's the TOP LEVEL default action (not nested)
                    const isMainDefault = lastStep.includes('action/6/default');
                    html += `
                        <div class="branch-item ${isMainDefault ? 'executed' : ''}" style="${isMainDefault ? 'border-left-color: var(--accent-green); background: rgba(0, 255, 136, 0.05);' : 'border-left-color: var(--border-color); background: var(--bg-tertiary); opacity: 0.8;'}">
                            <div class="branch-icon">‚öôÔ∏è</div>
                            <div class="branch-content">
                                <div class="branch-title">
                                    ‚Üí Default Action
                                </div>
                                <div class="branch-description">No specific branch conditions were met. Automation took the default path.</div>
                                <div class="branch-reason ${isMainDefault ? 'executed' : ''}" style="${isMainDefault ? 'border-left-color: var(--accent-green);' : 'border-left-color: var(--border-color);'}">Default execution path</div>
                            </div>
                        </div>
                    `;
                }

                html += '</div>';
                document.getElementById('branchTreeContent').innerHTML = html;
            } catch (err) {
                console.error('Error in renderBranchDecisionTree:', err);
                document.getElementById('branchTreeContent').innerHTML = '<div class="no-shading-info">Error rendering branch tree</div>';
            }
        }

        // OPT #1: Condition Chain Error Analysis
        function renderConditionChainAnalysis(innerTrace, lastStep) {
            try {
                // Find the failed condition chain
                const failedConditionPath = findFailedConditionChain(innerTrace, lastStep);

                if (!failedConditionPath) {
                    document.getElementById('conditionErrorPanel').style.display = 'none';
                    return;
                }

                document.getElementById('conditionErrorPanel').style.display = 'block';

                let html = '<div class="condition-chain">';

                // Get the condition evaluation data
                const conditionData = extractConditionChain(innerTrace, failedConditionPath);

                if (!conditionData || conditionData.length === 0) {
                    html += '<div class="no-shading-info">No detailed condition information available</div>';
                } else {
                    for (const condition of conditionData) {
                        const isFailed = condition.result === false;
                        const headerClass = isFailed ? 'fail' : 'pass';

                        html += `
                            <div class="condition-chain-item">
                                <div class="condition-chain-header ${headerClass}">
                                    ${isFailed ? '‚ùå' : '‚úì'} ${condition.name}
                                </div>
                                <div class="condition-chain-content">
                        `;

                        // Show sub-conditions
                        if (condition.subConditions && condition.subConditions.length > 0) {
                            for (const sub of condition.subConditions) {
                                const resultClass = sub.result ? 'true' : 'false';
                                const resultText = sub.result ? '‚úì TRUE' : '‚úó FALSE';
                                html += `
                                    <div class="condition-node">
                                        <div class="condition-node-label">
                                            ${sub.name}
                                            <span class="condition-node-result ${resultClass}">${resultText}</span>
                                        </div>
                                        ${sub.detail ? `<div class="condition-node-detail">${sub.detail}</div>` : ''}
                                    </div>
                                `;
                            }
                        } else {
                            const resultClass = condition.result ? 'true' : 'false';
                            const resultText = condition.result ? 'TRUE' : 'FALSE';
                            html += `
                                <div class="condition-node">
                                    <div class="condition-node-label">
                                        ${condition.description || 'Condition'}
                                        <span class="condition-node-result ${resultClass}">${resultText}</span>
                                    </div>
                                </div>
                            `;
                        }

                        // Add explanation
                        if (isFailed) {
                            html += `
                                <div class="error-explanation">
                                    üí° <strong>Why did this fail?</strong><br/>
                                    <div class="error-explanation-text">${generateFailureExplanation(condition)}</div>
                                </div>
                            `;
                        } else {
                            html += `
                                <div class="success-explanation">
                                    ‚úì <strong>This condition passed</strong><br/>
                                    ${condition.name} requirement was met
                                </div>
                            `;
                        }

                        html += `
                                </div>
                            </div>
                        `;
                    }
                }

                html += '</div>';
                document.getElementById('conditionErrorContent').innerHTML = html;
            } catch (err) {
                console.error('Error in renderConditionChainAnalysis:', err);
                document.getElementById('conditionErrorPanel').style.display = 'none';
            }
        }

        // Find where the condition chain failed
        function findFailedConditionChain(innerTrace, lastStep) {
            // If we stopped at a condition, that's our failed chain
            if (lastStep.includes('condition/')) {
                return lastStep;
            }
            // If we stopped in a choose block, analyze which condition failed
            const chooseMatch = lastStep.match(/choose\/(\d+)\/sequence/);
            if (chooseMatch) {
                return lastStep.replace('/sequence', '/conditions');
            }
            return null;
        }


        // Extract condition chain details
        function extractConditionChain(innerTrace, path) {
            const conditions = [];

            // Get condition path
            if (path.includes('/conditions/')) {
                // This is a nested condition
                const parts = path.split('/');
                const condNum = parseInt(parts[parts.length - 1]);

                // Get the condition step
                if (innerTrace[path]) {
                    const step = innerTrace[path][0];
                    conditions.push({
                        name: `Condition Block ${condNum}`,
                        result: step.result && step.result.result,
                        description: 'Branch condition evaluation',
                        detail: step.result ? `Result: ${step.result.result}` : 'Condition evaluation'
                    });
                }
            } else if (path.includes('choose')) {
                // Global condition
                if (innerTrace[path]) {
                    const step = innerTrace[path][0];
                    conditions.push({
                        name: 'Condition Evaluation',
                        result: step.result && step.result.result,
                        subConditions: [
                            { name: 'Condition Check', result: step.result?.result ?? false }
                        ]
                    });
                }
            }

            return conditions.length > 0 ? conditions : null;
        }

        // Generate human-readable failure explanation
        function generateFailureExplanation(condition) {
            const explanations = {
                'cover position': 'The cover is not in the expected position. Check if the cover entity is responding correctly.',
                'brightness': 'The brightness level did not meet the threshold. Check your brightness sensor configuration.',
                'temperature': 'The temperature did not meet the minimum threshold. Current temperature is below the configured minimum.',
                'time': 'The current time is outside the configured time window. Check your time configuration.',
                'elevation': 'The sun elevation is outside the configured range. Try again when the sun is at the correct angle.',
                'enable': 'This feature is not enabled. Check your automation configuration settings.',
                'helper': 'The helper entity status did not match the expected state. Check your helper configuration.',
                'prevent': 'Movement is prevented by the prevent flags. Check what is blocking movement (e.g., manual override).'
            };

            for (const [key, explanation] of Object.entries(explanations)) {
                if (condition.name.toLowerCase().includes(key)) {
                    return explanation;
                }
            }

            return `This condition was not met. Review the condition settings and current sensor values.`;
        }

        function extractTriggerInfo(innerTrace) {
            // Find the trigger step (trigger/N)
            for (const key of Object.keys(innerTrace)) {
                if (key.startsWith('trigger/')) {
                    const step = innerTrace[key][0];
                    if (step && step.changed_variables && step.changed_variables.trigger) {
                        const trigger = step.changed_variables.trigger;
                        return {
                            id: trigger.id || 'unknown',
                            idx: trigger.idx || key.split('/')[1],
                            platform: trigger.platform || 'unknown',
                            description: trigger.description || TRIGGER_EXPLANATIONS[trigger.id] || 'Unknown trigger',
                            entityId: trigger.entity_id || 'N/A'
                        };
                    }
                }
            }
            return { id: 'unknown', idx: '?', platform: 'unknown', description: 'Trigger info not found' };
        }

        function extractBranchInfo(lastStep, innerTrace) {
            // Parse branch from path like "action/6/choose/1/sequence/..."
            // action/6 is the main choose block, choose/N is the branch number
            const match = lastStep.match(/action\/\d+\/choose\/(\d+)/);
            if (match) {
                const branchNum = parseInt(match[1]);
                const branchDef = BRANCH_DEFINITIONS[branchNum];
                return {
                    number: branchNum,
                    name: branchDef ? branchDef.name : `Branch ${branchNum}`,
                    description: branchDef ? branchDef.description : 'Unknown branch',
                    icon: branchDef ? branchDef.icon : '‚ùì',
                    matched: true
                };
            }

            // Check if stopped before branch evaluation
            if (lastStep.match(/^condition\/\d+/)) {
                return {
                    number: null,
                    name: 'Global Conditions',
                    description: 'Stopped at global condition check before branch evaluation',
                    icon: 'üö´',
                    matched: false
                };
            }

            return {
                number: null,
                name: 'No Branch',
                description: 'No branch was matched or executed',
                icon: '‚ùì',
                matched: false
            };
        }

        function extractVariables(innerTrace) {
            let allVars = {};

            // 1. Shallow collect from all steps (prioritize later steps)
            for (const key of Object.keys(innerTrace)) {
                const steps = innerTrace[key];
                for (const step of steps) {
                    if (step.variables) allVars = { ...allVars, ...step.variables };
                    if (step.changed_variables) allVars = { ...allVars, ...step.changed_variables };
                }
            }

            // 2. Deep scan: If helper_json is still missing, look INTO every variable for it
            if (!allVars.helper_json) {
                for (const key of Object.keys(innerTrace)) {
                    const steps = innerTrace[key];
                    for (const step of steps) {
                        const searchObj = (vars) => {
                            if (!vars || typeof vars !== 'object') return null;
                            if (vars.helper_json) return vars.helper_json;
                            for (const k in vars) {
                                const found = searchObj(vars[k]);
                                if (found) return found;
                            }
                            return null;
                        };
                        const found = searchObj(step.variables) || searchObj(step.changed_variables);
                        if (found) {
                            allVars.helper_json = found;
                            break;
                        }
                    }
                    if (allVars.helper_json) break;
                }
            }

            return allVars;
        }

        function parseExecutionSteps(innerTrace, lastStep) {
            const steps = [];

            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];
                    steps.push({
                        path: path,
                        timestamp: step.timestamp,
                        result: step.result,
                        isLast: path === lastStep,
                        hasChangedVars: !!step.changed_variables
                    });
                }
            }

            // Sort by timestamp
            steps.sort((a, b) => {
                if (!a.timestamp || !b.timestamp) return 0;
                return new Date(a.timestamp) - new Date(b.timestamp);
            });

            return steps;
        }

        function renderSummary(state, scriptExecution, triggerInfo, branchInfo, timestamp, lastStep, runId) {
            const startTime = timestamp.start ? new Date(timestamp.start).toLocaleString('de-DE') : 'N/A';
            const duration = timestamp.start && timestamp.finish ?
                ((new Date(timestamp.finish) - new Date(timestamp.start)) / 1000).toFixed(1) + 's' : 'N/A';

            const repairWarning = currentTrace._repaired ? `
                <div class="summary-card" style="grid-column: 1 / -1; background: rgba(59, 130, 246, 0.1); border-color: var(--accent-blue);">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.5rem;">‚ÑπÔ∏è</span>
                        <div>
                            <div class="card-value" style="color: var(--accent-cyan); font-size: 1rem;">File Optimized</div>
                            <div class="card-detail">The static "config" section was removed (contains only blueprint YAML, not runtime data). All execution data is intact.</div>
                        </div>
                    </div>
                </div>
            ` : '';

            // Handle "Stopped" vs "Finished" - merger logic
            const statusDisplay = (scriptExecution === 'finished' || state === 'stopped') ? '‚úÖ Finished' : 'üõë Stopped';
            const statusClass = (scriptExecution === 'finished' || state === 'stopped') ? 'status-finished' : 'status-stopped';

            document.getElementById('summaryGrid').innerHTML = `${repairWarning}
                <div class="summary-card ${statusClass}">
                    <div class="card-label">Execution Status</div>
                    <div class="card-value">${statusDisplay}</div>
                    <div class="card-detail">Duration: ${duration}</div>
                    <div class="card-detail">${startTime}</div>
                    <div class="card-mono" style="margin-top: 0.5rem; font-size: 0.7rem; opacity: 0.7;">Source: ${currentTrace._filename || 'manual'}</div>
                </div>

                <div class="summary-card trigger-info">
                    <div class="card-label">Trigger</div>
                    <div class="card-value">${triggerInfo.id}</div>
                    <div class="card-detail">${TRIGGER_EXPLANATIONS[triggerInfo.id] || triggerInfo.description}</div>
                    <div class="card-mono">${triggerInfo.entityId}</div>
                </div>

                <div class="summary-card branch-info">
                    <div class="card-label">Branch Executed</div>
                    <div class="card-value">
                        ${branchInfo.icon} ${branchInfo.number !== null ? `(${branchInfo.number}) ` : ''}${branchInfo.name}
                    </div>
                    <div class="card-detail">${branchInfo.description}</div>
                </div>

                <div class="summary-card last-step-info">
                    <div class="card-label">Last Step</div>
                    <div class="card-value" style="font-size: 0.9rem;">${interpretLastStep(lastStep)}</div>
                    <div class="card-mono">${lastStep}</div>
                </div>
            `;
        }

        function interpretLastStep(lastStep) {
            // Parse the path and give a human-readable interpretation
            const parts = lastStep.split('/');

            if (lastStep.includes('choose') && lastStep.includes('default')) {
                return '‚úÖ Default action in branch';
            }
            if (lastStep.includes('sequence') && lastStep.includes('then')) {
                return '‚úÖ Then-block executed';
            }
            if (lastStep.includes('condition') && !lastStep.includes('choose')) {
                return 'üö´ Stopped at global condition';
            }
            if (lastStep.includes('choose') && lastStep.includes('conditions')) {
                const condMatch = lastStep.match(/conditions\/(\d+)/);
                return `üîç Branch condition ${condMatch ? condMatch[1] : '?'} checked`;
            }
            if (lastStep.includes('delay')) {
                return '‚è≥ Delay completed';
            }
            if (lastStep.includes('action') && lastStep.includes('set_value')) {
                return 'üíæ Helper updated';
            }

            return parts[parts.length - 1] || 'Unknown';
        }

        function renderLastStepAnalysis(lastStep, innerTrace, branchInfo) {
            const lastStepData = innerTrace[lastStep];
            let interpretation = '';
            let suggestions = [];

            if (branchInfo.matched) {
                interpretation = `
                    <p><strong>Branch ${branchInfo.number} (${branchInfo.name})</strong> was successfully entered and executed.</p>
                `;

                if (lastStep.includes('default')) {
                    interpretation += `<p>The automation reached the <strong>default action</strong> within the branch, meaning the main path was taken.</p>`;
                }

                if (lastStep.includes('then/0')) {
                    interpretation += `<p>A conditional block's <strong>then</strong> section was executed (condition was true).</p>`;
                }

                // Check if it was a cover movement or helper update
                if (lastStepData && lastStepData[0]) {
                    const result = lastStepData[0].result;
                    if (result && result.choice === 'default') {
                        interpretation += `<p>Result: <code>choice: default</code> - Standard path taken.</p>`;
                    }
                }

                // Check for stop action (Moved to end of function)

                suggestions = [
                    'This trace shows successful execution through the selected branch.',
                    'Check the cover entity to verify the expected position was reached.',
                    'If cover did not move, check the "prevent_flags" settings.'
                ];

            } else {
                interpretation = `<p>The automation <strong>did not enter any branch</strong>. It stopped at: <code>${lastStep}</code></p>`;

                // Analyze why no branch was matched
                if (lastStep.includes('condition')) {
                    const condResult = lastStepData && lastStepData[0] ? lastStepData[0].result : null;
                    const condName = (condResult && condResult.message) ? condResult.message : 'Condition check';

                    interpretation += `
                        <div class="fail-badge" style="display:inline-block; background:rgba(239, 68, 68, 0.2); color:var(--accent-red); padding:0.2rem 0.6rem; border-radius:4px; font-weight:600; margin-bottom:1rem;">
                            ‚ùå Condition not met
                        </div>
                        <p>The execution stopped because a requirement was not fulfilled: <strong>${condName}</strong></p>
                    `;

                    suggestions = [
                        'Check the condition evaluations in the Execution Path below.',
                        'Look for conditions that returned "false".',
                        'Common causes: wrong time window, feature not enabled, helper status mismatch.'
                    ];
                }
            }

            // Check for stop action - GLOBAL CHECK (run for both matched and unmatched branches)
            const stepData = innerTrace[lastStep];
            if (stepData && stepData[0]) {
                const firstStep = stepData[0];
                let stopMsg = null;

                if (firstStep.stop) {
                    stopMsg = firstStep.stop;
                } else if (firstStep.result && firstStep.result.stop) {
                    stopMsg = firstStep.result.stop;
                }

                if (stopMsg) {
                    interpretation += `
                        <div class="stop-badge" style="display:inline-block; background:rgba(139, 92, 246, 0.2); color:var(--accent-purple); padding:0.2rem 0.6rem; border-radius:4px; font-weight:600; margin-bottom:1rem; margin-top: 1rem;">
                            ‚èπÔ∏è Stop message
                        </div>
                        <p style="font-size: 1.1rem; color: var(--accent-purple); font-weight: 500;">"${stopMsg}"</p>
                    `;
                }
            }

            document.getElementById('lastStepContent').innerHTML = `
                <div class="last-step-analysis">
                    <h4>üéØ What happened at the last step?</h4>
                    <div class="last-step-path" style="font-family:var(--font-mono); font-size:0.8rem; background:var(--bg-primary); padding:0.5rem; border-radius:4px; margin-bottom:1rem; opacity:0.8;">${lastStep}</div>
                    <div class="last-step-interpretation">
                        ${interpretation}
                    </div>
                </div>
                ${suggestions.length > 0 ? `
                    <ul class="suggestions-list" style="margin-top:1.5rem; border-top:1px solid var(--border-color); padding-top:1rem;">
                        ${suggestions.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                ` : ''}
            `;
        }

        function formatHelperValue(hJson) {
            if (!hJson || typeof hJson !== 'object') return String(hJson || 'unknown');

            // CCA Status Object structure: { "key": { "a": 1, "t": ... }, ... }
            const keys = [
                'open', 'close', 'closed', 'shading', 'shaded',
                'shading_start_pending', 'shading_end_pending',
                'vpart', 'vfull', 'manual'
            ];
            for (const key of keys) {
                const status = hJson[key];
                if (status && (status.a === 1 || status.a === true)) {
                    // Prettify the key
                    let label = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
                    if (label === 'Close') label = 'Closed';
                    if (label === 'Shading') label = 'Shaded';
                    return label;
                }
            }

            // Fallback for string keys if present
            if (hJson.cover_status) return String(hJson.cover_status);

            return 'unknown';
        }

        function renderHelperStatus(variables) {
            const helperStatus = variables.helper_status || {};
            let helperJson = variables.helper_json;

            // Extreme Fallback: Search the entire currentTrace object for helper_json if missing
            if (!helperJson && currentTrace) {
                const deepSearch = (obj, depth = 0) => {
                    if (!obj || typeof obj !== 'object' || depth > 10) return null;
                    if (obj.helper_json) return obj.helper_json;
                    for (const k in obj) {
                        const found = deepSearch(obj[k], depth + 1);
                        if (found) return found;
                    }
                    return null;
                };
                helperJson = deepSearch(currentTrace);
            }
            if (!helperJson) helperJson = {};

            // Robust parsing if it's a string
            if (typeof helperJson === 'string' && (helperJson.trim().startsWith('{') || helperJson.trim().startsWith('['))) {
                try {
                    helperJson = JSON.parse(helperJson);
                } catch (e) {
                    console.warn('Failed to parse helper_json string:', helperJson);
                }
            }

            const innerTrace = currentTrace.trace?.trace || {};

            // Extract previous and new values
            const prevValue = formatHelperValue(helperJson);
            let newValue = 'no change';

            // Find new value from actions
            for (const [path, steps] of Object.entries(innerTrace)) {
                for (const step of steps) {
                    if (step.result && step.result.params && step.result.params.service === 'set_value' && step.result.params.domain === 'input_text') {
                        let potentialValue = step.result.params.service_data?.value || step.result.params.data?.value || 'empty';
                        // Handle object values (sometimes stored as { value: '...' })
                        if (typeof potentialValue === 'object' && potentialValue !== null) {
                            newValue = formatHelperValue(potentialValue);
                        } else {
                            newValue = potentialValue;
                        }
                    }
                }
            }

            const items = [
                { key: 'open', label: 'Open' },
                { key: 'closed', label: 'Closed' },
                { key: 'shaded', label: 'Shaded' },
                { key: 'shading_start_pending', label: 'Start Pending' },
                { key: 'shading_end_pending', label: 'End Pending' },
                { key: 'vpart', label: 'V-Part' },
                { key: 'vfull', label: 'V-Full' },
                { key: 'manual', label: 'Manual' }
            ];

            let html = `
                <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem; background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 12px; border: 1px solid var(--border-color);">
                    <div style="flex: 1;">
                        <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.25rem;">Previous Helper Value</div>
                        <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-secondary);">${prevValue}</div>
                    </div>
                    <div style="display: flex; align-items: center; color: var(--text-muted); font-size: 1.2rem;">‚ûú</div>
                    <div style="flex: 1; text-align: right;">
                        <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.25rem;">New Helper Value</div>
                        <div style="font-size: 1.1rem; font-weight: 700; color: ${newValue !== 'no change' ? 'var(--accent-green)' : 'var(--text-muted)'};">${newValue}</div>
                    </div>
                </div>

                <div class="helper-grid">
                    ${items.map(item => {
                const value = helperStatus[item.key];
                const isActive = value === true;
                return `
                            <div class="helper-item">
                                <div class="helper-label">${item.label}</div>
                                <div class="helper-value ${isActive ? 'active' : 'inactive'}">
                                    ${isActive ? '‚úì ON' : '‚Äì OFF'}
                                </div>
                            </div>
                        `;
            }).join('')}
                </div>
            `;

            if (helperJson.t) {
                html += `
                    <div style="margin-top: 1rem; font-size: 0.8rem; color: var(--text-muted); display: flex; justify-content: space-between;">
                        <span>Last Update: ${new Date(helperJson.t * 1000).toLocaleString('de-DE')}</span>
                        <span style="font-family: var(--font-mono); opacity: 0.5;">t: ${helperJson.t}</span>
                    </div>
                `;
            }

            document.getElementById('helperContent').innerHTML = html;
        }

        // NEW: Timing Analysis
        function renderTimingAnalysis(innerTrace, startTime) {
            const steps = [];
            let prevTime = startTime ? new Date(startTime) : null;

            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];
                    if (step.timestamp) {
                        const currentTime = new Date(step.timestamp);
                        let delay = null;
                        if (prevTime) {
                            delay = (currentTime - prevTime) / 1000; // seconds
                        }
                        steps.push({ path, timestamp: step.timestamp, delay });
                        prevTime = currentTime;
                    }
                }
            }

            // Find significant delays
            const significantDelays = steps.filter(s => s.delay !== null && s.delay > 1);
            const maxDelay = significantDelays.length > 0 ? Math.max(...significantDelays.map(s => s.delay)) : 0;

            let html = '<div style="display: grid; gap: 1rem;">';

            // Summary stats
            html += `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Total Steps</div>
                        <div style="font-size: 1.5rem; font-weight: 600;">${steps.length}</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Max Delay</div>
                        <div style="font-size: 1.5rem; font-weight: 600; color: ${maxDelay > 5 ? 'var(--accent-yellow)' : 'var(--accent-green)'};">
                            ${maxDelay > 0 ? maxDelay.toFixed(2) + 's' : 'N/A'}
                        </div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Delays > 1s</div>
                        <div style="font-size: 1.5rem; font-weight: 600;">${significantDelays.length}</div>
                    </div>
                </div>
            `;

            // Show significant delays
            if (significantDelays.length > 0) {
                html += '<div style="margin-top: 1rem;"><h4 style="margin-bottom: 0.75rem; font-size: 0.9rem; color: var(--text-secondary);">Significant Delays (>1s)</h4>';
                html += '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                significantDelays.slice(0, 10).forEach(step => {
                    const delayClass = step.delay > 5 ? 'var(--accent-yellow)' : 'var(--accent-cyan)';
                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-secondary);">${step.path}</div>
                            <div style="font-weight: 600; color: ${delayClass};">${step.delay.toFixed(2)}s</div>
                        </div>
                    `;
                });
                html += '</div></div>';
            }

            html += '</div>';
            document.getElementById('timingContent').innerHTML = html;
        }

        // NEW: Variable Changes Timeline
        function renderVariableChangesTimeline(innerTrace, startTime) {
            const changes = [];
            const start = startTime ? new Date(startTime) : null;

            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];
                    if (step.changed_variables && step.timestamp) {
                        const time = new Date(step.timestamp);
                        const relativeTime = start ? ((time - start) / 1000).toFixed(2) : null;

                        // Extract key variable changes
                        const vars = step.changed_variables;
                        const keyChanges = [];

                        if (vars.target_position !== undefined) keyChanges.push(`target_position: ${vars.target_position}`);
                        if (vars.target_tilt_position !== undefined) keyChanges.push(`target_tilt_position: ${vars.target_tilt_position}`);
                        if (vars.update_values) {
                            const updates = vars.update_values;
                            if (updates.open) keyChanges.push(`open: a=${updates.open.a}`);
                            if (updates.close) keyChanges.push(`close: a=${updates.close.a}`);
                            if (updates.shading) keyChanges.push(`shading: a=${updates.shading.a}, p=${updates.shading.p || 0}, q=${updates.shading.q || 0}`);
                            if (updates.vpart) keyChanges.push(`vpart: a=${updates.vpart.a}`);
                            if (updates.vfull) keyChanges.push(`vfull: a=${updates.vfull.a}`);
                            if (updates.manual) keyChanges.push(`manual: a=${updates.manual.a}`);
                        }

                        if (keyChanges.length > 0) {
                            changes.push({ path, timestamp: step.timestamp, relativeTime, changes: keyChanges });
                        }
                    }
                }
            }

            if (changes.length === 0) {
                document.getElementById('varChangesContent').innerHTML = '<div class="no-shading-info">No variable changes detected in this trace.</div>';
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 0.75rem;">';
            changes.forEach(change => {
                html += `
                    <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-blue);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                            <div style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--accent-cyan);">${change.path}</div>
                            ${change.relativeTime !== null ? `<div style="font-size: 0.75rem; color: var(--text-muted);">+${change.relativeTime}s</div>` : ''}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            ${change.changes.map(c => `<span style="padding: 0.25rem 0.5rem; background: var(--bg-primary); border-radius: 4px; font-size: 0.75rem; font-family: var(--font-mono);">${c}</span>`).join('')}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            document.getElementById('varChangesContent').innerHTML = html;
        }

        // NEW: Action Execution Details
        function renderActionExecutionDetails(innerTrace) {
            const actions = [];

            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];
                    if (step.result && step.result.params) {
                        const params = step.result.params;
                        if (params.service || params.action) {
                            actions.push({
                                path,
                                timestamp: step.timestamp,
                                service: params.service || params.action,
                                domain: params.domain,
                                target: params.target,
                                data: params.service_data || params.data
                            });
                        }
                    }
                }
            }

            if (actions.length === 0) {
                document.getElementById('actionDetailsContent').innerHTML = '<div class="no-shading-info">No service calls detected in this trace.</div>';
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 0.75rem;">';
            actions.forEach(action => {
                const serviceName = `${action.domain || ''}.${action.service || ''}`.replace(/^\./, '');
                html += `
                    <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-green);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                            <div style="font-weight: 600; color: var(--accent-green);">${serviceName}</div>
                            <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-muted);">${action.path}</div>
                        </div>
                        ${action.target && action.target.entity_id ? `
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                                <strong>Target:</strong> ${Array.isArray(action.target.entity_id) ? action.target.entity_id.join(', ') : action.target.entity_id}
                            </div>
                        ` : ''}
                        ${action.data && Object.keys(action.data).length > 0 ? `
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                                <strong>Data:</strong> <span style="font-family: var(--font-mono);">${JSON.stringify(action.data, null, 2)}</span>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            html += '</div>';
            document.getElementById('actionDetailsContent').innerHTML = html;
        }

        // NEW: Position Tracking
        function renderPositionTracking(innerTrace, variables, startTime) {
            const positions = [];
            const start = startTime ? new Date(startTime) : null;
            const initialPosition = variables.current_position;

            // Track position changes
            for (const [path, stepArray] of Object.entries(innerTrace)) {
                if (stepArray && stepArray.length > 0) {
                    const step = stepArray[0];
                    if (step.changed_variables && step.changed_variables.target_position !== undefined && step.timestamp) {
                        const time = new Date(step.timestamp);
                        const relativeTime = start ? ((time - start) / 1000).toFixed(2) : null;
                        positions.push({
                            path,
                            timestamp: step.timestamp,
                            relativeTime,
                            targetPosition: step.changed_variables.target_position,
                            targetTilt: step.changed_variables.target_tilt_position
                        });
                    }
                }
            }

            if (positions.length === 0) {
                document.getElementById('positionTrackingContent').innerHTML = `
                    <div class="no-shading-info">
                        No position changes detected. Current position: ${initialPosition !== undefined ? initialPosition + '%' : 'N/A'}
                    </div>
                `;
                return;
            }

            let html = `
                <div style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.25rem;">Initial Position</div>
                    <div style="font-size: 1.25rem; font-weight: 600;">${initialPosition !== undefined ? initialPosition + '%' : 'N/A'}</div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
            `;

            positions.forEach(pos => {
                const positionLabel = pos.targetPosition === 0 ? 'Close (0%)' :
                    pos.targetPosition === 100 ? 'Open (100%)' :
                        `${pos.targetPosition}%`;
                html += `
                    <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-purple);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                            <div style="font-weight: 600; color: var(--accent-purple);">${positionLabel}</div>
                            ${pos.relativeTime !== null ? `<div style="font-size: 0.75rem; color: var(--text-muted);">+${pos.relativeTime}s</div>` : ''}
                        </div>
                        <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-muted);">${pos.path}</div>
                        ${pos.targetTilt !== undefined ? `
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                                Tilt: ${pos.targetTilt}%
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            html += '</div>';
            document.getElementById('positionTrackingContent').innerHTML = html;
        }

        function renderExecutionPath(steps, lastStep) {
            document.getElementById('stepCount').textContent = `(${steps.length} steps)`;

            // Create filter buttons
            const filters = [
                { id: 'all', label: 'All' },
                { id: 'conditions', label: 'Conditions' },
                { id: 'actions', label: 'Actions' },
                { id: 'failed', label: '‚ùå Failed' }
            ];

            document.getElementById('filterButtons').innerHTML = filters.map(f => `
                <button class="filter-btn ${currentFilter === f.id ? 'active' : ''}" data-filter="${f.id}">
                    ${f.label}
                </button>
            `).join('');

            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentFilter = btn.dataset.filter;
                    renderExecutionPath(steps, lastStep);
                });
            });

            // Filter steps
            let filteredSteps = steps;
            if (currentFilter === 'conditions') {
                filteredSteps = steps.filter(s => s.path.includes('condition'));
            } else if (currentFilter === 'actions') {
                filteredSteps = steps.filter(s => !s.path.includes('condition'));
            } else if (currentFilter === 'failed') {
                filteredSteps = steps.filter(s => s.result && s.result.result === false);
            }

            document.getElementById('executionSteps').innerHTML = filteredSteps.map(step => {
                let statusClass = 'exec';
                let statusIcon = '‚ñ∂';

                if (step.isLast) {
                    statusClass = 'last';
                    statusIcon = 'üéØ';
                } else if (step.result) {
                    if (step.result.result === true) {
                        statusClass = 'pass';
                        statusIcon = '‚úì';
                    } else if (step.result.result === false) {
                        statusClass = 'fail';
                        statusIcon = '‚úó';
                    } else if (step.result.choice !== undefined) {
                        statusClass = 'pass';
                        statusIcon = '‚Üí';
                    }
                }

                const time = step.timestamp ? new Date(step.timestamp).toLocaleTimeString() : '';
                let resultStr = '';
                if (step.result) {
                    if (step.result.result !== undefined) {
                        resultStr = `Result: ${step.result.result}`;
                    } else if (step.result.choice !== undefined) {
                        resultStr = `Choice: ${step.result.choice}`;
                    }
                }

                return `
                    <div class="execution-step">
                        <div class="step-status ${statusClass}">${statusIcon}</div>
                        <div class="step-content">
                            <div class="step-path">
                                ${step.path}
                                ${resolveBlueprintLink(step.path)}
                            </div>
                            ${resultStr ? `<div class="step-result">${resultStr}</div>` : ''}
                        </div>
                        <div class="step-time">${time}</div>
                    </div>
                `;
            }).join('');
        }

        function renderVariables(variables) {
            const groups = {
                'Cover & Position': [
                    'blind', 'cover_type', 'is_awning',
                    'current_position', 'current_tilt_position',
                    'open_position', 'close_position', 'shading_position', 'ventilate_position',
                    'position_tolerance',
                    'in_open_position', 'in_close_position', 'in_shading_position', 'in_ventilate_position'
                ],
                'Position Comparisons': [
                    'position_comparisons'
                ],
                'Features Enabled': [
                    'is_up_enabled', 'is_down_enabled', 'is_shading_enabled', 'is_ventilation_enabled',
                    'is_brightness_enabled', 'is_sun_elevation_enabled',
                    'is_cover_tilt_enabled', 'is_cover_tilt_enabled_and_possible',
                    'is_status_helper_enabled', 'is_auto_recover_enabled'
                ],
                'Time Configuration': [
                    'time_control', 'is_time_field_enabled', 'is_time_control_disabled', 'is_calendar_enabled',
                    'time_up_early', 'time_up_late', 'time_down_early', 'time_down_late',
                    'time_up_early_today', 'time_up_late_today', 'time_down_early_today', 'time_down_late_today',
                    'is_today_off', 'is_tomorrow_off', 'is_tomorrow_on'
                ],
                'Sun & Brightness': [
                    'current_sun_azimuth', 'current_sun_elevation',
                    'sun_elevation_up', 'sun_elevation_down',
                    'sun_elevation_up_current', 'sun_elevation_down_current',
                    'brightness_up', 'brightness_down', 'brightness_hysteresis'
                ],
                'Shading Configuration': [
                    'shading_azimuth_start', 'shading_azimuth_end',
                    'shading_elevation_min', 'shading_elevation_max',
                    'shading_sun_brightness_start', 'shading_sun_brightness_end',
                    'shading_min_temperatur1', 'shading_min_temperatur2',
                    'shading_forecast_temp',
                    'shading_waitingtime_start', 'shading_waitingtime_end'
                ],
                'Shading Conditions': [
                    'shading_conditions_start_and', 'shading_conditions_start_or',
                    'shading_conditions_end_and', 'shading_conditions_end_or',
                    'shading_start_condition_enabled', 'shading_end_condition_enabled'
                ],
                'Helper Status': [
                    'helper_status', 'helper_json', 'helper_ts'
                ],
                'Blocking & Force': [
                    'is_cover_movement_blocked',
                    'auto_up_force', 'auto_down_force', 'auto_ventilate_force', 'auto_shading_start_force'
                ],
                'Override & Manual': [
                    'override_flags', 'ignore_after_manual_config',
                    'is_reset_disabled', 'is_reset_fixed_time', 'is_reset_timeout'
                ],
                'Prevent Flags': [
                    'prevent_flags', 'prevent_config'
                ],
                'Ventilation & Contacts': [
                    'ventilation_flags', 'contact_window_opened', 'contact_window_tilted',
                    'lockout_tilted_when_closing', 'lockout_tilted_when_shading_starts', 'lockout_tilted_when_shading_ends'
                ],
                'Resident': [
                    'resident_sensor', 'resident_flags', 'resident_config'
                ],
                'Delays & Timing': [
                    'drive_delay_fix', 'drive_delay_random', 'drive_time',
                    'brightness_time_duration', 'sun_time_duration',
                    'contact_delay_trigger', 'contact_delay_status'
                ],
                'Forecast': [
                    'forecast_source', 'shading_forecast_sensor', 'shading_forecast_type'
                ],
                'Tilt Settings': [
                    'open_tilt_position', 'close_tilt_position', 'ventilate_tilt_position',
                    'shading_tilt_position',
                    'shading_tilt_position_0', 'shading_tilt_position_1', 'shading_tilt_position_2', 'shading_tilt_position_3',
                    'shading_tilt_elevation_1', 'shading_tilt_elevation_2', 'shading_tilt_elevation_3'
                ],
                'Sensors': [
                    'default_brightness_sensor', 'default_sun_sensor',
                    'shading_brightness_sensor', 'shading_temperatur_sensor1', 'shading_temperatur_sensor2',
                    'workday_sensor_today', 'workday_sensor_tomorrow'
                ],
                'System': [
                    'version', 'blind_entities', 'cover_status_helper'
                ]
            };

            let html = '<div class="variables-grid">';

            for (const [groupName, varNames] of Object.entries(groups)) {
                const groupVars = varNames.filter(name => variables[name] !== undefined);
                if (groupVars.length === 0) continue;

                html += `<div class="var-group"><div class="var-group-title">${groupName}</div>`;
                for (const name of groupVars) {
                    const value = variables[name];
                    html += renderVariableItem(name, value);
                }
                html += '</div>';
            }

            html += '</div>';
            document.getElementById('varsContent').innerHTML = html;
        }

        function renderVariableItem(name, value) {
            let displayValue = '';
            let valueClass = '';
            let isExpandable = false;

            if (value === null || value === undefined) {
                displayValue = 'null';
                valueClass = 'bool-false';
            } else if (typeof value === 'boolean') {
                displayValue = value ? '‚úì true' : '‚úó false';
                valueClass = value ? 'bool-true' : 'bool-false';
            } else if (typeof value === 'number') {
                displayValue = String(value);
                valueClass = 'number';
            } else if (Array.isArray(value)) {
                if (value.length === 0) {
                    displayValue = '[ ]';
                    valueClass = 'bool-false';
                } else if (value.length <= 3 && value.every(v => typeof v === 'string')) {
                    displayValue = value.join(', ');
                } else {
                    displayValue = `[${value.length} items]`;
                    isExpandable = true;
                }
            } else if (typeof value === 'object') {
                // Format objects nicely
                const keys = Object.keys(value);
                if (keys.length <= 4) {
                    // Small object: show inline
                    const parts = keys.map(k => {
                        const v = value[k];
                        if (typeof v === 'boolean') return `${k}: ${v ? '‚úì' : '‚úó'}`;
                        if (typeof v === 'number') return `${k}: ${v}`;
                        return `${k}: ${JSON.stringify(v)}`;
                    });
                    displayValue = parts.join(' | ');
                } else {
                    displayValue = `{${keys.length} keys}`;
                    isExpandable = true;
                }
            } else if (typeof value === 'string') {
                displayValue = value;
                if (value === '' || value === '[]') {
                    valueClass = 'bool-false';
                }
            } else {
                displayValue = String(value);
            }

            // Truncate long values
            if (displayValue.length > 80) {
                displayValue = displayValue.substring(0, 77) + '...';
            }

            const expandableData = isExpandable ?
                `data-full="${encodeURIComponent(JSON.stringify(value, null, 2))}"` : '';

            return `
                <div class="var-item" ${expandableData}>
                    <span class="var-name">${name}</span>
                    <span class="var-value ${valueClass}">${displayValue}</span>
                </div>
            `;
        }

        function generateReport() {
            if (!currentTrace) return '';

            const traceInfo = currentTrace.trace || {};
            const innerTrace = traceInfo.trace || {};
            const triggerInfo = extractTriggerInfo(innerTrace);
            const branchInfo = extractBranchInfo(traceInfo.last_step, innerTrace);
            const variables = extractVariables(innerTrace);
            const helperStatus = variables.helper_status || {};

            return `
CCA TRACE ANALYSIS REPORT
=========================
Generated: ${new Date().toISOString()}

SUMMARY
-------
Status: ${traceInfo.script_execution || traceInfo.state}
Start: ${traceInfo.timestamp?.start || 'N/A'}
End: ${traceInfo.timestamp?.finish || 'N/A'}
Run ID: ${traceInfo.run_id || 'N/A'}

TRIGGER
-------
ID: ${triggerInfo.id}
Description: ${TRIGGER_EXPLANATIONS[triggerInfo.id] || triggerInfo.description}
Entity: ${triggerInfo.entityId}

BRANCH
------
Number: ${branchInfo.number !== null ? branchInfo.number : 'None'}
Name: ${branchInfo.name}
Description: ${branchInfo.description}

LAST STEP
---------
Path: ${traceInfo.last_step}
Interpretation: ${interpretLastStep(traceInfo.last_step)}

HELPER STATUS
-------------
Open: ${helperStatus.open}
Closed: ${helperStatus.closed}
Shaded: ${helperStatus.shaded}
Start Pending: ${helperStatus.shading_start_pending}
End Pending: ${helperStatus.shading_end_pending}
V-Part: ${helperStatus.vpart}
V-Full: ${helperStatus.vfull}
Manual: ${helperStatus.manual}

KEY VARIABLES
-------------
Position: ${variables.current_position}
is_up_enabled: ${variables.is_up_enabled}
is_down_enabled: ${variables.is_down_enabled}
is_shading_enabled: ${variables.is_shading_enabled}
in_open_position: ${variables.in_open_position}
in_close_position: ${variables.in_close_position}

---
Generated by CCA Trace Analyzer v3
            `.trim();
        }

        function copyReport() {
            const report = generateReport();
            navigator.clipboard.writeText(report).then(() => {
                const btn = document.getElementById('copyReport');
                btn.textContent = '‚úÖ Copied!';
                setTimeout(() => btn.textContent = 'üìã Copy Report', 2000);
            });
        }

        function downloadReport() {
            const report = generateReport();
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cca-trace-report-${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // =====================================================================
        // BLUEPRINT SOURCE LINKING FEATURE
        // =====================================================================

        async function fetchBlueprintSource() {
            const btn = document.getElementById('fetchBlueprintBtn');
            const statusFn = document.getElementById('blueprintStatus');
            const urlInput = document.getElementById('blueprintUrlInput');

            let url = urlInput.value.trim();
            if (!url) return;

            // Transform GitHub blob URL to raw
            if (url.includes('github.com') && url.includes('/blob/')) {
                url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            statusFn.textContent = 'Fetching source...';

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network response was not ok');
                const text = await response.text();

                // Parse YAML with Line Numbers (Handle variable flexibility)
                const YAMLParser = window.jsyaml || window.YAML || window.yaml;

                if (YAMLParser && YAMLParser.parseDocument) {
                    blueprintDoc = YAMLParser.parseDocument(text);
                    console.log('üìÑ Blueprint doc:', blueprintDoc);
                    console.log('üìÑ Contents:', blueprintDoc.contents);
                    console.log('üìÑ Contents type:', blueprintDoc.contents?.constructor?.name);
                    console.log('üìÑ Contents keys:', Object.keys(blueprintDoc.contents || {}));
                    console.log('üìÑ Contents methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(blueprintDoc.contents || {})).filter(m => typeof blueprintDoc.contents[m] === 'function'));

                    // Try different access methods
                    if (blueprintDoc.contents) {
                        console.log('üìÑ Has .get?', typeof blueprintDoc.contents.get);
                        console.log('üìÑ Has .items?', blueprintDoc.contents.items);
                        console.log('üìÑ Has .toJSON?', typeof blueprintDoc.contents.toJSON);

                        // Try toJSON first
                        if (blueprintDoc.contents.toJSON) {
                            const json = blueprintDoc.contents.toJSON();
                            console.log('üìÑ toJSON result:', json);
                            console.log('üìÑ JSON has action?', 'action' in json, json?.action);
                        }

                        // Try .get() with key
                        if (blueprintDoc.contents.get) {
                            const actionViaGet = blueprintDoc.contents.get('action');
                            console.log('üìÑ Action via .get("action"):', actionViaGet);

                            // Inspect items structure (yaml library uses Pair objects)
                            if (blueprintDoc.contents.items) {
                                console.log('üìÑ Contents.items length:', blueprintDoc.contents.items.length);

                                // Log ALL keys to see what's available
                                const allKeys = [];
                                blueprintDoc.contents.items.forEach((pair, idx) => {
                                    const keyVal = pair.key?.value || pair.key;
                                    console.log(`üìÑ Item[${idx}]:`, 'key =', keyVal, typeof keyVal);
                                    allKeys.push(keyVal);
                                });
                                console.log('üìÑ ALL KEYS:', allKeys);

                                // Find 'action' pair - log each check
                                const actionPair = blueprintDoc.contents.items.find(pair => {
                                    const keyValue = pair.key?.value || pair.key;
                                    const isAction = keyValue === 'action';
                                    if (isAction || keyValue?.toString().includes('action')) {
                                        console.log('üìÑ üîç Checking key:', keyValue, 'isAction:', isAction);
                                    }
                                    return isAction;
                                });
                                console.log('üìÑ Found action pair:', actionPair);
                                if (actionPair) {
                                    console.log('üìÑ ‚úÖ Action pair.value:', actionPair.value);
                                    console.log('üìÑ ‚úÖ Action value type:', actionPair.value?.constructor?.name);
                                    console.log('üìÑ ‚úÖ Action value.items:', actionPair.value?.items);
                                    if (actionPair.value?.items?.[0]) {
                                        console.log('üìÑ ‚úÖ Action items[0]:', actionPair.value.items[0]);
                                        console.log('üìÑ ‚úÖ Action items[0].range:', actionPair.value.items[0].range);
                                    }
                                } else {
                                    console.warn('üìÑ ‚ùå action pair NOT FOUND in items!');
                                }
                            }
                        }
                    }

                    statusFn.textContent = '‚úÖ Blueprint source loaded';
                    statusFn.style.color = 'var(--accent-green)';

                    // Re-run analysis to inject links if we already have a trace
                    if (currentTrace) {
                        try {
                            analyzeTrace(currentTrace);
                        } catch (e) {
                            console.error('Re-analysis failed', e);
                        }
                    }

                } else {
                    console.error('YAML Parser not found. window.jsyaml:', window.jsyaml, 'window.YAML:', window.YAML, 'window.yaml:', window.yaml);
                    statusFn.textContent = '‚ö†Ô∏è YAML parser not loaded (Check Console)';
                    statusFn.style.color = 'var(--accent-orange)';
                }
            } catch (err) {
                console.error('Failed to fetch blueprint:', err);
                statusFn.textContent = '‚ùå Load failed: ' + err.message;
                statusFn.style.color = 'var(--accent-red)';
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîÑ Load Source';
            }
        }

        function resolveBlueprintLink(tracePath) {
            if (!blueprintDoc) {
                console.log('üîó No blueprintDoc for path:', tracePath);
                return '';
            }
            if (tracePath === 'trigger') return '';

            try {
                const parts = tracePath.split('/');

                // Root for automation execution is the 'action' sequence in the blueprint.
                let node = blueprintDoc.contents.get('action');
                if (!node) {
                    console.warn('üîó No action node found in blueprint for path:', tracePath);
                    return '';
                }

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];

                    if (!node) break;

                    if (!isNaN(part)) {
                        // Numeric index -> assume Sequence/List access
                        const idx = parseInt(part);
                        if (node.items && node.items[idx]) {
                            node = node.items[idx];
                        } else {
                            // Path doesn't match blueprint structure
                            return '';
                        }
                    } else {
                        // String key -> assume Map access
                        if (node.get && node.get(part)) {
                            node = node.get(part);
                        } else {
                            // Key not found
                            return '';
                        }
                    }
                }

                if (node && node.range) {
                    const rangeStart = node.range[0];
                    const line = getLineNumberFromOffset(blueprintDoc.toString(), rangeStart);
                    const baseUrl = document.getElementById('blueprintUrlInput').value.trim();
                    console.log(`üîó Link created for ${tracePath} -> Line ${line}`);
                    return `<a href="${baseUrl}#L${line}" target="_blank" class="source-link" title="Open in GitHub: Line ${line}" style="text-decoration:none; margin-left:0.5rem; opacity:0.7;">üîó</a>`;
                } else {
                    console.warn('üîó Node found but no range for path:', tracePath, 'node:', node);
                }

            } catch (e) {
                console.warn('üîó Link resolution error for', tracePath, ':', e);
            }
            return '';
        }
        function getLineNumberFromOffset(text, offset) {
            // Simple line counting
            let line = 1;
            for (let i = 0; i < offset; i++) {
                if (text[i] === '\\n') line++;
            }
            return line;
        }
    </script>
</body>

</html>